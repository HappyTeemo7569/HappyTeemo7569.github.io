<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
<<<<<<< Updated upstream
      <title></title>
      <link href="/202108/1799/"/>
      <url>/202108/1799/</url>
      
        <content type="html"><![CDATA[]]></content>
=======
      <title>Linux开关机命令</title>
      <link href="/202108/46749/"/>
      <url>/202108/46749/</url>
      
        <content type="html"><![CDATA[<h1 id="引入："><a href="#引入：" class="headerlink" title="引入："></a><strong>引入：</strong></h1><ul><li>1.在DOS年代，当你需要关闭计算机的时候，可能直接拔掉电源就可以。使用Windows系统的时候，长按住关机键就可以强制关机。</li><li>2.因为Windows(非NT内核)系统中，由于是单人假多任务的情况，即使你关闭了计算机，对其他人也不产生影响</li><li>3.但是Linux中，每个程序都是在后台执行。在背后，可能有很多人同时在你的主机上面工作(浏览网页、FTP传输文件等…)，如果你直接关机，可能会造成意想不到的后果</li><li>4.因此，在Linux下面关机、重启、睡眠等都是非常需要注意的</li><li>5.下面的命令最好都以管理员(root)的身份进行</li></ul><h1 id="一、关机、重启前的准备"><a href="#一、关机、重启前的准备" class="headerlink" title="一、关机、重启前的准备"></a><strong>一、关机、重启前的准备</strong></h1><p><strong>1.查看网络联机状态、后台可执行程序</strong></p><p>查看一下两样东西，可以让你稍微了解主机目前的使用状态</p><ul><li>查看网络联机状态：netstat -a</li><li>查看后台执行的程序：ps -aux</li></ul><p><strong>2.数据同步写入磁盘：sync</strong></p><p><strong>①引入：</strong></p><ul><li>在计算机导论中曾提到过，我们的数据需要写入内存才能够被CPU处理。内存中的数据保存和读取时需要与硬盘进行沟通，但是硬盘和内存之间的读取速度会影响运行速度，因此有部分数据不会被直接读取到硬盘中，而是临时保存在内存中，到后面需要时，一次性读取到硬盘。</li><li>此时，如果你不小心造成非正常关机，导致内存中的部分数据还没有来得及读取到硬盘中，就会造成数据的丢失。后果不堪设想</li></ul><p><strong>②sync命令</strong></p><ul><li>sync命令的作用就是将内存中尚未更新到硬盘中的数据写入到硬盘，这个命令在关机或重启前多执行几次，比较好</li><li>目前的系统中，shutdown、reboot、halt等命令中都已经包含了sync这个程序的调用。不过，多了解一下还是比较好的</li></ul><p><strong>③使用</strong></p><ul><li>建议以管理员的身份进行命令执行(原因：一般用户身边更新到硬盘中的数据只有自己部分的数据，管理员的身份可以更新整个系统的数据)</li><li>将身份变为管理员：su -</li><li>数据同步到硬盘：sync</li></ul><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/1598252087232-40cc2a0b-6d2e-4d9f-a59d-26c3fb3e7445.png" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/1598252087232-40cc2a0b-6d2e-4d9f-a59d-26c3fb3e7445.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/1598252087274-96dcb25e-0835-448a-bd13-399daf9decc6.png" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/1598252087274-96dcb25e-0835-448a-bd13-399daf9decc6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p><h1 id="二、关机（shutdown）"><a href="#二、关机（shutdown）" class="headerlink" title="二、关机（shutdown）"></a><strong>二、关机（shutdown）</strong></h1><p><strong>1.介绍：</strong>若你在物理终端登录系统时，不论什么身份都能够执行关机操作。但是如果你使用远程管理工具(如通过pietty使用ssh服务来从其他计算机登录主机)就只有root的身份才可以进行关机</p><p><strong>2.命令格式</strong></p><ul><li>基本格式：/sbin/shutdown [选项] [时间] [警告信息]</li><li>参数</li></ul><table><thead><tr><th>-k</th><th>不是真的要关机，只是发出警告而已</th></tr></thead><tbody><tr><td>-r</td><td>将系统的服务听到之后就重新启动</td></tr><tr><td>-h</td><td>将系统的服务停掉后，立即关机</td></tr><tr><td>-c</td><td>取消已经在进行的shutdown命令</td></tr></tbody></table><ul><li>时间</li></ul><table><thead><tr><th>默认时间</th><th>若时间缺省，默认在1分钟之后关机</th></tr></thead><tbody><tr><td>now</td><td>立即执行</td></tr><tr><td>自定义时间</td><td>例如：20:25(在20:25进行关机，如果当前时间超过了20:25，则隔天关机)</td></tr><tr><td>+时间</td><td>例如：+30(在30分钟之后关机)</td></tr></tbody></table><ul><li>警告信息：关机时发出一些提示信息</li></ul><p><strong>3.演示案例</strong></p><ul><li>立刻关机：shutdown -h now</li><li>系统将在20:25关机：shutdown -h 20:25</li><li>系统立刻重启：shutdown -r now</li><li>提示系统将在30分钟会后重启：shutdown -r +30  ‘The system will reboot’</li><li>仅发出警告，但不是真的关机：shutdown -k now  ‘The system will reboot’</li></ul><h1 id="三、重启和其他关机（reboot、halt、poweroff）"><a href="#三、重启和其他关机（reboot、halt、poweroff）" class="headerlink" title="三、重启和其他关机（reboot、halt、poweroff）"></a><strong>三、重启和其他关机（reboot、halt、poweroff）</strong></h1><p>1.还有三个命令和关机重启有关，就是****reboot、halt、poweroff****。这三个命令其实都差不多，根据自身情况与爱好选择使用</p><ul><li><strong>reboot：</strong>重启</li><li><strong>poweroff：</strong>系统关机</li><li><strong>halt：</strong>系统停止，屏幕可能会保留系统已经停止的信息</li></ul><p><strong>2.代码演示</strong></p><ul><li>重启：sync; sync; sync; reboot</li><li>系统停止：halt</li><li>系统关机：poweroff</li></ul><h1 id="四、systemctl"><a href="#四、systemctl" class="headerlink" title="四、systemctl"></a><strong>四、systemctl</strong></h1><p><strong>1.介绍：</strong>目前系统中所有服务的管理的命令是：systemctl。这个命令相当复杂，在后面会详细介绍</p><ul><li>我们前面所谈到的shutdown、reboot、poweroff、halt等其实都是调用systemctl这个命令</li></ul><p><strong>2.命令格式</strong></p><ul><li>system [命令]</li></ul><p>[命令]包括以下内容：只介绍与本片文章有关的命令</p><ul><li>halt：进入系统停止的模式，屏幕可能会保留一些信息(这与你的电源管理模式有关)</li><li>poweroff：进入系统关机模式，直接关机</li><li>reboot：直接重新启动</li><li>suspend：进入休眠模式</li></ul><p><strong>3.演示</strong></p><ul><li>系统重新启动：systemctl reboot</li><li>系统直接关机：systemctl poweroff</li></ul>]]></content>
>>>>>>> Stashed changes
      
      
      <categories>
          
<<<<<<< Updated upstream
          <category> Go语言基础 </category>
=======
          <category> Linux </category>
>>>>>>> Stashed changes
          
      </categories>
      
      
        <tags>
            
<<<<<<< Updated upstream
            <tag> Go </tag>
=======
            <tag> Linux命令 </tag>
>>>>>>> Stashed changes
            
        </tags>
      
    </entry>
    
    
    
    <entry>
<<<<<<< Updated upstream
      <title>【手把手教你写Go】01.为什么要选择Go语言</title>
      <link href="/202108/1799/"/>
      <url>/202108/1799/</url>
      
        <content type="html"><![CDATA[<p>一门语言的兴起一定有他的原因，所谓天下苦Java久矣，Go的到来可以说很多后端开发的福音，尤其是在微服务、分布式这么火的今天，那么，他的优势到底是什么呢？</p><p>首先，我们需要现有后端语言的优势痛点：</p><blockquote><p>其实每个语言的优势和痛点往往是同一个，毕竟这个世界上没有完美的东西，你要享受它的好，就要承受他的痛。</p></blockquote><ul><li>PHP，脚本语言，开发速度飞快，而且可复用性高，如果是写全栈代码，可以说是神器。<ul><li>脚本语言，写起来快，运行时慢。好处就是上传了实时生效，不用重启。坏处就是运行时编译，效率低。（如果是小型公司创业初期，或者你只是做一个小型网站，PHP真的是首选 ）</li><li>一个请求一个进程。不用考虑并发问题，这也是PHPer转Go最大的问题。这也使得PHP的并发量天然受限。</li><li>swoole的出现很大程度上改善了PHP的效率问题，但并发、异步、定时器之类的处理依然不够。</li></ul></li><li>Java，强类型，编译型语言。<ul><li>Java可以说是工业级语言，是一把宰牛刀，如果企业的业务量起来了，用Java重构是个很好的选择。但是同样的，这使得它运行起点很高，可能我网站请求才用2%的CPU，jvm可能就用了20%了。</li><li>开发较慢。强类型、编译久、一切从类开始，使得开发效率会相对慢一些。</li></ul></li><li>go，小而强。<ul><li>在我看来，Go就是服务端界的c，它很小巧，但它很强，参考我的C语言相关的文章。<a href="https://juejin.cn/post/6988787262603395079">【重看C语言】hello world</a></li><li>编译快，一键异步，自带定时器、通道、协程、锁。可以说让那些因为进程间关系掉的头发又长了回来。</li><li>包的体积小，无依赖，直接放到服务器就可以运行，让被PHP.ini和nginx各种配置折磨的phper如沐春风。</li></ul></li></ul><p>可以说，Go的前景还是很可观的。但是，我希望大家学习一门语言的时候，千万不要只是因为很多人学，要明白，语言只是工具。就好比，如果我现在写一个后台，还是会用PHP，为什么？查询好写，开发快，还可以直接全栈。找到一门语言的优势和它的精髓才是重点。</p><blockquote><p>很多人学习一门语言就是看看语法，然后找找框架，看看CURD怎么写，最后把原来的查询翻译过来，完事。</p></blockquote><p>好了，进入正题，开始学习Go语言。</p><h1 id="1、初识Go语言"><a href="#1、初识Go语言" class="headerlink" title="1、初识Go语言"></a>1、初识Go语言</h1><h2 id="1-1-Go语言简介"><a href="#1-1-Go语言简介" class="headerlink" title="1.1 Go语言简介"></a>1.1 Go语言简介</h2><h3 id="1-1-1-Go语言是什么"><a href="#1-1-1-Go语言是什么" class="headerlink" title="1.1.1 Go语言是什么"></a>1.1.1 Go语言是什么</h3><p>2009年11月10日，Go语言正式成为开源编程语言家庭的一员。</p><p>Go语言（或称Golang）是云计算时代的C语言。Go语言的诞生是为了让程序员有更高的生产效率，Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。</p><p>开发人员在为项目选择语言时，不得不在快速开发和性能之间做出选择。C和C++这类语言提供了很快的执行速度，而 Ruby 和 Python 这类语言则擅长快速开发。Go语言在这两者间架起了桥梁，不仅提供了高性能的语言，同时也让开发更快速。</p><p>Go语言是一门并发支持、垃圾回收的编译型语言。</p><p>从某种意义上可以说是C的优化版本。</p><h3 id="1-1-2-Go语言优势"><a href="#1-1-2-Go语言优势" class="headerlink" title="1.1.2 Go语言优势"></a>1.1.2 Go语言优势</h3><ul><li><p>直接编译成机器码，不依赖其他库，glibc的版本有一定要求，部署就是扔一个文件上去就完成了。</p></li><li><p> 静态类型语言，但是有动态语言的感觉，静态类型的语言就是可以在编译的时候检查出来隐藏的大多数问题，动态语言的感觉就是有很多的包可以使用，写起来的效率很高。</p></li><li><p>语言层面支持并发，这个就是Go最大的特色，天生的支持并发。Go就是基因里面支持的并发，可以充分的利用多核，很容易的使用并发。</p></li><li><p>内置runtime，支持垃圾回收，这属于动态语言的特性之一吧，虽然目前来说GC(内存垃圾回收机制)不算完美，但是足以应付我们所能遇到的大多数情况，特别是Go1.1之后的GC。</p></li><li><p>简单易学，Go语言的作者都有C的基因，那么Go自然而然就有了C的基因，那么Go关键字是25个，但是表达能力很强大，几乎支持大多数你在其他语言见过的特性：继承、重载、对象等。</p></li><li><p>丰富的标准库，Go目前已经内置了大量的库，特别是网络库非常强大。</p></li><li><p>内置强大的工具，Go语言里面内置了很多工具链，最好的应该是gofmt工具，自动化格式化代码，能够让团队review变得如此的简单，代码格式一模一样，想不一样都很困难。</p></li><li><p>跨平台编译，如果你写的Go代码不包含cgo，那么就可以做到window系统编译linux的应用，如何做到的呢？Go引用了plan9的代码，这就是不依赖系统的信息。</p></li><li><p>内嵌C支持，Go里面也可以直接包含C代码，利用现有的丰富的C库。</p></li></ul><h3 id="1-1-3-Go适合做什么"><a href="#1-1-3-Go适合做什么" class="headerlink" title="1.1.3 Go适合做什么"></a>1.1.3 Go适合做什么</h3><ul><li><p>服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</p></li><li><p>分布式系统，数据库代理器等。</p></li><li><p>网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用。</p></li><li><p>内存数据库，如google开发的groupcache，couchbase的部分组建。</p></li><li><p>云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。</p></li></ul><h3 id="1-1-4-Go的语言特点"><a href="#1-1-4-Go的语言特点" class="headerlink" title="1.1.4 Go的语言特点"></a>1.1.4 Go的语言特点</h3><ol><li>保留但大幅度简化指针</li><li>多参数返回</li><li>array slice map等内置基本数据结构</li><li>错误处理（panic recover error）</li><li>interface</li><li>goroutine</li><li>多核处理和网络开发</li><li>部分函数式编程（匿名函数、闭包），反射，语言交互性</li><li>Package即目录</li></ol><p> </p><h3 id="1-1-5-Go的哲学"><a href="#1-1-5-Go的哲学" class="headerlink" title="1.1.5 Go的哲学"></a>1.1.5 Go的哲学</h3><p>连接：组件的耦合方式，组件是如何被连接起来的</p><p>组合：形成复合对象的基础。</p><blockquote><p>Less can be more<br>大道至简,小而蕴真 </p></blockquote><p>让事情变得复杂很容易，让事情变得简单才难，深刻的工程文化。</p>]]></content>
=======
      <title>你有没有为梦想努力过？</title>
      <link href="/202108/44239/"/>
      <url>/202108/44239/</url>
      
        <content type="html"><![CDATA[<p>每一个人，我相信，在人生的某个阶段，都有梦想，而且往往它是不断变化的。</p><p>原因有以下几点：</p><ul><li>不是真爱。涉世未深的我们会被很多事情吸引，有时候只看到了它光鲜的一面，而没有了解过背后的苦难，等到某一天，发现那并不是我们要的。</li><li>移情别恋。很多事情是有通性的，比如数学和侦探，我们可能只是喜欢一种推理、分析的感觉，而究竟哪种才是想要的，要到后面才知道。</li><li>随波逐流。大多数人不赞同这个，比如你要是立志当一名鸭王，大多数人尤其是你的父母应该会拦着你的。</li></ul><p>但是不知从何时起，这个词汇渐渐从我们的生活中消失。消失的并不是我们的想法，而是我们的热情。</p><blockquote><p>没有一帆风顺的人生，只有一成不变的生活。</p></blockquote><p><strong>时间是最好的良药，却也是最好的砂纸。</strong>它抚平了我们的创伤，也磨平了我们的斗志。生活的不如意让我们总有放弃战斗的想法，就更别提那”一文不值“的梦想了。</p><p>每个人一开始都是有自己的想法的，但是大多数人渐渐地随波逐流，成为了社会上的一颗螺丝钉，但，在某个夜晚，会不会突然想起，那个被自己写进日记，贴在床头的梦想？</p><p><strong>世界上的路，是给人走的，每个人都有选择的权利，也有后悔的权利。但是，没有重来的权利。</strong>我们需要在能够战斗的时候，就不要颓废、倒下、丧失斗志。也许我们不会成功，也许我们会被他人明嘲暗讽，也许我们会过得稀烂，也许我们。。。</p><p>但，那又怎么样呢？人活一世，最惨不过是死，能够有一个目标，并为之努力，已经是幸福。<strong>命，就是拿来拼的。</strong></p><p>在能够选择的时候，不要退缩。</p><p>好好守护心底的那道光。</p>]]></content>
>>>>>>> Stashed changes
      
      
      <categories>
          
<<<<<<< Updated upstream
          <category> Go语言基础 </category>
=======
          <category> 随笔 </category>
>>>>>>> Stashed changes
          
      </categories>
      
      
        <tags>
            
<<<<<<< Updated upstream
            <tag> Go </tag>
=======
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么要自建博客</title>
      <link href="/202108/61320/"/>
      <url>/202108/61320/</url>
      
        <content type="html"><![CDATA[<p>说起来，写博客有些年了。</p><p>从CSDN到博客园要掘金，都有写过。但是最后，我还是想自建博客了。</p><p>自建博客原因有以下几点;</p><ul><li>不用审核，我不会因为平台规定而限制自己的文字内容。想写什么就写什么（主要是说题材）。</li><li>不用考虑怕平台倒闭或崩溃。（博客园挂的时候大家都有体会）</li><li>自由度高，可以自己DIY一切。</li><li>减少功利心，各大平台都有自己的激励政策，我自认为做不要不动心，所以我决定远离。</li></ul><p>当然，最重要的，还是觉得比较酷一点。</p><p>我写程序，纯粹就是为了成就感和虚荣心，换句话说，就是装13。不能装13的技术不是好技术。我就喜欢解决别人不能解决的问题，然后被别人喊一句”大佬，牛逼“，就是这种虚荣心，让我不断前进，不想被捧杀，就要一直拥有被捧的资本。</p><p>对于成就感，就想我很喜欢说的一句话，”<strong>编程就像蹦极，站上面的时候很怕，跳下去的时候感觉要完，回弹的时候感觉真爽，上来了就还想再跳一次。</strong>“</p><p>编程带来的成就感和这个问题的难度是成正比的，你熬的越久，最后的成就感就越强。而这就导致，如果没有bug，我一天的生活就索然无味。而且越是高难度的bug越是能让我兴奋。</p><p>而自建博客，确实是比较麻烦的事情，不管是github+hexo，还是WordPress，都是需要花时间搭建的和自己定制一下的。</p><ul><li>对于hexo这种静态页面，好处在于能够随时修改，统一生成，而且免费。如果只是写博客是完全OK的。</li><li>而wordPress这种带后台的，可以实现的功能就无限多了，虽然需要花钱，但是对于一个成熟的网站来说还是更有优势的。</li></ul><p>但是，<strong>不喜欢折腾，当什么程序员</strong>？</p><blockquote><p> 做选择的时候，选难的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
>>>>>>> Stashed changes
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20岁应该知道的事</title>
      <link href="/202108/23224/"/>
      <url>/202108/23224/</url>
      
        <content type="html"><![CDATA[<p>1、二十多岁谈恋爱的时候,女生满脑子想的是言情小说,男生满脑子想的是AV<br>如果女生打算谈恋爱，不妨先考虑一下自己对性可以接受到什么程度?<br>开房开多了,早晚会发生关系,不要以为只是边缘性行为就没事。<br>常在河边走,早晚会鞋湿。</p><p>2、喜欢一个人的最好方式不是像一个保姆一样鞍前马后,请吃请喝,每天接送,这样只会让对方看不起你,<br><strong>正确的做法是有自己的追求然后成为更好的自己。</strong><br>女人不会很喜欢你一天到晚宠着她,她更希望你有自己的追求,更希望你认认真真的实现自己的抱负、而不是像跟屁虫一样只知道围着她转,除了对她好以外什么都不知道,什么都不会,什么都不行。<br>这种男人早晚会被绿,女人无论表面说多喜欢他,也都是假的。舔狗之所以一无所有,是因为他们除了女人,脑子里什么都没有。<br>人的本性：<strong>男人好色，女人慕强。</strong></p><p>3、<strong>没有经历过深夜痛哭的人不足以语人生。</strong><br>你只有经历过三观尽毁,万念俱灰,你才能对这个世界,对人性,对真实有更透彻,更犀利的见解。</p><p>5、如果你20岁刚上大学不久,大学又很烂,你可以好好考虑一下复读。<br>这个社会,很多人考研考了三四年,见怪不怪。<br>如果高考也可以复读,为什么不去考虑一下呢?<br>在垃圾大学里面浪费四年,不如多花一年好好考一个好大学。</p><p>6、不要有自己在大学混的不如意,到了社会就突然咸鱼翻身,大杀四方。<br>不存在的,<strong>优秀的人往往一直优秀</strong>,比如学霸一路上都是学霸,学习很好,工作了也可以把工作做的很好。<br>废柴的人则往往一直废柴,当学生的时候学习不行,工作了也是这个不会,那个不会,做什么都不行。<br>也许财富会突然增加,但是能力并不存在突然增加的情况**,能力只能一步一步的提升,不能存在侥幸的想法。**</p><p>7、不要觉得靠关系可以吃遍天下,觉得自己会做人,会讨好领导就可以高枕无忧。<br>老板是讲绩效的,是看重KPI指标的,是不会容忍一个只会讨好人的废物存在的。</p><blockquote><p>你的价值才是你的护身符而不是你的人际关系。</p></blockquote><p>所以不要为了混学生会,社团把成绩丢了,到时候你会悔到肠子都青了。</p><p>8、女人介意男人的心中有没有过其他女人,男人介意女人身体中有没有进过其他男人。<br>不要觉得现在大清都亡了,对这些就毫无顾忌。<br>聪明的人知道自己该隐藏什么,不说什么,而不是一五一十的坦诚相告。<br>也许你很坦白,但是你们的感觉也毁掉了,这种坦白毫无意义。</p><p>9.和女生在一起,男人要懂得克制自己的本能,不能让人觉得你满脑子只有男女之事,当对方有这个印象的时候,离失去她就不远了。</p><p>10、当另一半对你后退一步的时候,你不该咄咄逼人的质问对方。<br>你应该静悄悄的退后两步。<br>以退为进才是高明的策略,才不会让对方有压力,感到不适,才能让你的形象变得强大,洒脱。<br>而不是哭與啼啼的跪舔。</p><p>11、恋爱中只有真诚是没用的,没有技巧,真诚只会让自己万劫不复,走向火坑。<br>多少人付出了自己的全部真诚,换来的却是对方的背叛、不珍惜。<br>看看王宝强,看看贾乃亮,你就知道什么是”男不坏,女不爱”。</p><p>12、学生在学校的时候最好有一技傍身。<br>商科生、文科生可以考虑CPA,理工科可以考虑编程。<br>一技傍身,吃遍天下,你不会担心自己没有饭吃。<br>很多人的中年危机在于他们没有过硬的技能,很容易被取代。</p><p>13,如果觉得自己过得浑浑噩噩,松松垮垮,不如去社会上感受一下社会的艰辛,<br>当你每天早上六点钟就要起床赶车去上班的时候,<br>当你在工作中遇到一大堆你不懂的问题的时候,<br>你会觉得自己的学生时代是天堂,<br>你会后悔自己浪费了大量的时间在一些无意义的事情上。</p><p>14、精英之所以是精英在于他们的要求和一般人不一样。平庸的人凡事都是做的差不多就行了,但是精英的要求很高。<br>年轻人想成为精英就要和精英在一起,让精英用精英的标准要求你,拔高你的标准上限,这样若干年后,你也会变成货真价实的精英。</p><p>15、年轻人总是因为眼界的狭容觉得当老板牛逼,其实老板并不牛逼,很多老板活得还不如打工的,要钱没钱,要地位没地位。<br>所以没必要非要让自己去创业,创业是一件水到渠成的事情,当你各方面条件都差不多具备的时候,自然就去创业了,这种成功性还高,还容易赚到钱。<br>大学刚毕业缺少积累的条件下就去创业,十有八九是亏的翻不了身。</p><p>16,不要对人性有过高的期望,那样子你很容易受伤。<br>也不要妄想靠感情可以留住一个人,不要迷信感情的力量,你要相信人和人都是差不多的,天下间那么多在一起很久的恋人分手,离婚,你不要觉得只有你例外。<br>分开与否很多时候只是差时机和条件罢了,并不存在永恒。<br>看透这一点,你会更好的保护好自己,更加珍惜眼前的快乐你不如接受人性中的种种劣根性,比如势利,比如贱,比如忘恩负义,你的心态会更加平和,而不是愤世嫉俗的骂骂咧咧,成天负能量。</p><p>17二十岁的时候,最能毁掉你的是得来太容易的快感。<br>比如擔管,比如打游戏,比如酗酒,这会让你活在一个虚幻的世界里面消耗自己。<br>等哪一天你发现身体垮了，学业毁了,事业一无所成,身边的姑娘离你而去,自己岁数大了,你才会勃然醒悟,可惜再回首已是百年身。<br>如果你大学觉得过得很轻松,很舒服,你大概率缺少自己的目标和规划,后果就是你出社会后会花费大量的时间去弥补。而这要付出的代价通常是你所不能承受的。<br>我们可以看到很多人毕业后,要么转行,要么换专业,即使成功了,也通常会耗费数年的时间,这数年时间是一个人最宝贵的黄金职场期。<br>不想在毕业数年后再重新开始,大学的时候就需要多去尝试,多去接触社会,想好今后自己的路,不要只会撸管,打游戏,睡觉。</p><p>18、如果你本科不是211,无论如何请把你的成绩提高,方便出国,保研。<br>如果这些做不到,那就拼命去考研吧。相信我,现在连985研究生都很难找到像样的工作了,你一个二本毕业的本科生,没有国过硬的技术,你大概率是去不入流的企业做销售、客服、一年到头辛辛苦苦赚不到什么钱,更恐怖的是日子一天天过去,你却似乎毫无进步,毫无期望可言。<br>985研究生,虽然不代表必定有前途,但是可以选择的机会多很多。你也大概率知道什么是好企业,什么是真正的好机会,而不是被安利,保险公司洗脑,认为他们口中的风口就是机会(越是不入流的学校越是有不入流的企业去招人)。</p><p>19、好好去体验爱情吧。<br>无论是受伤也好,真爱也罢。爱情可以让你变得更加成熟,情商更高,更懂得如何应对人和人之间微妙的分寸。当你懂得什么女人喜欢什么,男人喜欢什么,你离掌握什么是人心,什么是人性就不远了。<br>男人不一定渴望女人有钱,但是一定渴望女人漂亮,男人的好色是刻在骨子里的东西。<br>男人眼中的优秀是漂亮,温柔,身材好,而不是会赚钱,会加班,学历高,很多女人误会了,为了爱情在相反的道路上努力。</p><p>20、要保持平常心,不要把外物看的太重。比如钱,女人,名望,这些只会干扰你的心境,你的判断。<br>无论是受伤也好,真爱也罢。爱情可以让你变得更加成熟,情商更高,更懂得如何应对人和人之间微妙的分寸。当你懂得什么女人喜欢什么,男人喜欢什么,你离掌握什么是人心,什么是人性就不远了。男人不一定渴望女人有钱,但是一定渴望女人漂亮,男人的好色是刻在骨子里的东西。男人眼中的优秀是漂亮,温柔,身材好,而不是会赚钱,会加班,学历高,很多女人误会了,为了爱情在相反的道路上努力。</p><p>20、要保持平常心,不要把外物看的太重。比如钱,女人,名望,这些只会干扰你的心境,你的判断。<br>失去平常心,你会害怕,害怕失去,害怕做错,害怕自己不行,然后诡异的是,你越是害怕什么就越是招什么。<br>不要担心自己的女朋友会被社会上有钱的大叔抢走,也许你恐惧大叔的金钱地位,但是你也许不知道,有钱的大叔也在恐惧你们小鲜肉的青春阳光,俊朗的身体形象,以及充裕的时间。<br>如何做到保持平常心?爱自己多一分就够了。爱别人永远不要超过爱自己。你的一切付出存在的意义是对方领情,一旦对方不领情,你的付出对自己是消耗和愚蠢,对别人是骚扰和犯贱</p><p>21、如果你不知道未来自己做什么,不知道未来做什么工作,那就去找一个有钱的工作吧。<br>至少在未来,你可以为了钱,一直工作下去。大部分人,是既不喜欢自己的工作,又赚不到什么钱,每天累得要死,然后一直抱怨着。</p><p>22、夸讲你的话基本上都是假话,那些批评你的,让你难堪的话很多都是真话。当你什么时候可以从容的面对别人的质疑,讥讽而不针锋相对,你就成熟了。</p><p>23、看人要看优点而不是挑刺。只有你看到的是优点,你才会去学习,才不会小肚鸡肠,容不下别人的好。赞美别人并不会让你少什么,并不会显得你的不优秀。</p><p>24、不要以靠父母为耻辱。这个社会是看结果的,没人看你的过程。<br>你该考虑的是如何让自己牛逼,而不是以不靠父母为荣。王思聪这么有钱还得靠他爸王健林,你凭什么说只靠自己就够了?团结一切广大的资源为我所用,才是办事的人的思考。</p><p>25、好好储蓄,不要超前消费,不要瞧不起每个月500-1000的储蓄。<br>很多人因为一直不稀罕存小钱,结果三十多岁还在还花呗,借呗,一分存款都没有。<br>如果家境好,工作好还可以。万一家庭变故,工作变动,你的储蓄可以让你不至于落魄,不至于尊严扫地，万劫不复。</p>]]></content>
      
      
      <categories>
          
          <category> 摘抄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年龄渐长，技术人的发展之路该怎么走？</title>
      <link href="/202108/17772/"/>
      <url>/202108/17772/</url>
      
        <content type="html"><![CDATA[<p>每一个程序员，不关你是科班出身，还是半路转行，又或者只是点开了一个培训机构的广告。但是你入门之后，一定有一颗坚定的心：</p><blockquote><p>coding可以改变世界。</p></blockquote><p>毕竟近50年的历史，是由程序员书写的，互联网、手机、电脑各种改变世界的产品，都是程序员缔造的。你会觉得，自己手中的键盘，就是打开下一个新世界的大门。</p><p>但是岁月是把杀猪刀，加班、跳槽、结婚、房贷等等压力铺面而来，像刚入职那样简简单单写写代码的日子已经一去不复返了。</p><blockquote><p>你有多久没有静下心来钻研代码了？</p></blockquote><p>我们可能看着加班没有尽头、升职没有希望，根本看不到未来的路在哪里，而在各种压力铺面而来的同时，最可怕的是逐渐稀疏的头发和那可怕的35岁。</p><p>也许这一次跳槽之后，就是30岁了，再也没有那样的精力和资本去通过跳槽升职加薪了。</p><p>那么，程序员的28-35岁这一段路该怎么走？</p><h2 id="不要焦虑"><a href="#不要焦虑" class="headerlink" title="不要焦虑"></a>不要焦虑</h2><p>焦虑是没有任何意义的，每个人都会老，每个人都会迎来中年危机。那么我们来看看中年危机是怎么来的：</p><h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p><strong>年龄渐长，身体和精力不如以前了</strong>。20-25浪的身体，在30岁的时候会统统还给你，出来混，早晚是要还的。以前天天通宵，第二天照常上班的日子已经不存在。</p><p>所以，开始养生吧：早睡早起，坚持锻炼，不要透支身体，改掉坏习惯。</p><p>自律，真的很重要。</p><h3 id="平庸"><a href="#平庸" class="headerlink" title="平庸"></a>平庸</h3><p><strong>没有特别厉害的闪光点。</strong> </p><p>在你30岁的时候，如果你还没有一个稳定的工作，可以说，你已经在被淘汰的边缘了。如果你家里有矿，那么对不起，我错了，我们还可以做朋友么。</p><p>如果你已经在一个公司渐渐稳定，那么，你一定要跳出公司，和同行比一比，自己的闪光点在哪里，千万不要说什么我和老板关系很好，除非你是因为这个才入职的。</p><blockquote><p>公司的人情是最靠不住的，创业伙伴都好多吵到分崩离析的，何况你一个员工。</p></blockquote><p>又或者，公司倒闭了，或者项目停了，离开了公司，可能你什么也不是。</p><p>什么算闪光点（核心竞争力）呢？</p><h4 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h4><p>程序员作为以及技术性职业，技术能力自然是第一位的。而很多人在一个岗位兢兢业业地写了5年的CURD，到了30岁，不被淘汰就算幸运了。</p><blockquote><p>目光放长远，格局拉大，不要在乎这一个项目的得失，更多地去专注自身能力的成长。</p></blockquote><p>比如，你在一家外包公司，老板只是让你速度出成果，不要在乎什么可读性，什么可维护性，能跑就行。你会妥协么？<strong>千万不能！！</strong></p><blockquote><p>一个人最可怕的不是老去，也不是没钱，而是变得平庸，变得得过且过。</p></blockquote><p>一旦你放低了对自己的要求，那么，你离平庸就不远了，这也是环境对一个人的影响，如果你的同事、老板都是这样一味图快，请远离他们，换一家公司吧。</p><p><strong>要用你能见到的最强者的标准要求自己，想想他会怎么做，这样你才能越来越强。</strong></p><p>多学、多看、多思考，不要忘记初心，不要得过且过。</p><h4 id="解决问题的能力"><a href="#解决问题的能力" class="headerlink" title="解决问题的能力"></a>解决问题的能力</h4><p>有很多人自己写代码很厉害，但是对于被人犯得错误不太能处理，有些脾气差一点的首先就开喷，这样你是带不好团队的。</p><p>带团队的第一能力就是能发现坑、填坑。你手下的人是必然没有你厉害的，不然你可能会被换掉了，那么他们犯得错误你首先要冷静分析，怎么弥补，然后该定规矩定规矩，该扣奖金扣奖金，不要手软，这时候手软害了你也害了他。</p><p>然后对于事前的提问，比如这个代码怎么写，这个业务怎么梳理等等，不要吝啬，程序员的技术是透明的，不存在教了徒弟害了师傅，你不告诉他谷歌、自学一样能解决，只是时间更久而已。</p><p><strong>但是你的经验、能力在这个时候得到体现，对于你的威望和领导力是很有帮助的，他们会觉得跟着你有前途，能学到东西。</strong></p><p>渐渐的，你会发现，逐渐成了团队的大牛，成了核心人员，大家习惯地请教你，而你也在这个过程中学到了很多。你觉得你离升职加薪还远么？</p><h4 id="带团队的能力"><a href="#带团队的能力" class="headerlink" title="带团队的能力"></a>带团队的能力</h4><p>刚才也说到了一点，主要是帮团队的人解决问题。</p><p>但带团队远没有这么简单。</p><ul><li>任务怎么分配，人员怎么调度，进度怎么跟踪？</li><li>怎么将老板或者产品的需求分解、协商？</li><li>怎么code review,避免上线出现问题？</li><li>线上问题怎么排查，有没有预案？需要哪些部分配合？怎么跟老板交代？</li><li>怎么提加薪，怎么安排手下的薪资？</li><li>手下的人有情绪了，不想加班了，不想干了怎么安抚？</li><li>下属吵起来了你怎么处理？</li><li>你怎么推行自己的主张，让上司同意，让下属心甘情愿？</li><li>自己最近浮躁了，焦虑了，不想干了，怎么对上对下表示？<br>。。。</li></ul><p>这个话题可能写一本都说不完，需要自己多体会，多学习。</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><ul><li><strong>家庭的压力。</strong> 30岁是一个坎，很多人到了这个时候，玩的心渐渐淡下去，开始感叹岁月蹉跎，很多人开始考虑成家的事情，甚至有很多已经有了小孩。事情逐渐多了起来，也有了很多的身不由己。</li></ul><p>坚强，可能是第一要素，你的肩膀已经渐渐成熟，该承担更多了。</p><p>合理地划分时间和精力也很重要，将工作和生活做取舍，多站在另一半的视角考虑。</p><p>可以说，你如果没有一个稳定的家庭，那么肯定不会拥有一个成功的事业。成功男人的背后一定有一个靠谱的女人。反之一样。</p><p>你要想想自己到底要什么，如果一定要成就一番事业，那么一定不要找一个小富即安的另一半。同理，如果你的另一半觉得你必须飞黄腾达，那么你也要考虑那是不是你要的生活。</p><blockquote><p>有得必有失，事业的成功必然是减少了对家人的陪伴。一定要协商好，不然一定会闹矛盾。</p></blockquote><h2 id="好的选择"><a href="#好的选择" class="headerlink" title="好的选择"></a>好的选择</h2><p>上面可以说是对自身的要求，但是有时候，好的选择往往比努力更重要。</p><ul><li>是去大城市还是小城市？</li><li>是去创业公司还是去大厂？</li></ul><p>大公司：</p><ul><li>牛人多，福利好，工资高，长见识。</li><li>加班多，管理严，压力大，只能当螺丝钉。</li></ul><p>小公司：</p><ul><li>什么都能接触到，更容易晋升，老板稀罕你，万一公司起飞了自己也就起飞了。</li><li>福利不全，工资一般，看老板颜色，人际关系复杂，什么都要学。</li></ul><p>大城市：</p><ul><li>工资高，汇聚了各种牛人，长见识的机会更多，岗位和机会更多。</li><li>房价也高，牛人多了你可能显得不起眼，两点一线，有孤独感。</li></ul><p>小城市：</p><ul><li>消费低，房价低，压力小。</li><li>工资低，岗位少，厉害的人也少。</li></ul><blockquote><p>不管怎么选，都不会一帆风顺，坚定自己的内心，不要选了A又想念B。</p></blockquote><h2 id="抬头看世界"><a href="#抬头看世界" class="headerlink" title="抬头看世界"></a>抬头看世界</h2><p>30岁，不怕你不拼，而怕你乱拼。如果你还是一心只钻研代码，你可能会处处碰壁。</p><ul><li><strong>开始关心并处理复杂的人际关系。</strong> 公司里面，表面上看起来风平浪静，但是底下一定是暗流涌动，有利益的地方就一定有纠纷，学会看人，少交心，有些话对家里人说，别在公司乱说。</li><li><strong>开始使用政治手段。</strong> 你已经不是涉世未深的小朋友了，不用觉得这个脏了手一样。该忍要忍，该骂要骂，打官腔，要学会表现自己，要学会波澜不惊，低调做人，高调做事等等。</li><li><strong>关心国事和经济。</strong> 你已经积累了一定的财富，怎么管理他们是一门学问，如果你的财富超过了你的管理能力，建议聘请理财助理，和租房找中介一样，花钱可以省很多事。</li><li><strong>提高情商。</strong> 99%的程序员都认为技术第一，都会觉得别人是SB，这就是傲。首先可以肯定你是厉害的，但是如果情商不够，你一定不是混的最好的。</li></ul><blockquote><p>平庸的人败于懒，厉害的人败于傲。虚心是情商最重要的一环。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>30岁以前，是磨剑期；30岁以后，是出鞘期。</p><p>如果你足够努力，30岁对你根本不是问题，如果你的剑还不够锋利，沉下心来，继续磨，姜子牙、齐白石，都是老来成名，不用担心年龄，坚持走下去就好。</p><blockquote><p><strong>最怕就是</strong>，明明自己很菜，还吊的不行。明明对手很强，他还比你更努力。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——12</title>
      <link href="/202108/46907/"/>
      <url>/202108/46907/</url>
      
        <content type="html"><![CDATA[<h2 id="陈独秀为避风头再返沪-南陈北李路上相约建党"><a href="#陈独秀为避风头再返沪-南陈北李路上相约建党" class="headerlink" title="陈独秀为避风头再返沪 南陈北李路上相约建党"></a>陈独秀为避风头再返沪 南陈北李路上相约建党</h2><p>121、胡适家里，陈独秀与新青年同人编辑饮酒惜别<br>　　陈独秀：酒是凉的，心是热的。来，各位兄弟，民国六年初，我到的北京，本来是想，帮蔡元培三个月的忙，没想到，这一干，就整整三年。这三年我从单打独斗，办新青年，到聚集了这么多的同人兄弟，开创了一个事业，树起了一杆大旗，我问心无愧，也非常知足。这杯酒，我敬各位兄弟，对我的厚爱。君曼，你也陪着。<br>　　钱玄同：仲甫兄，还记得几年前，你我在陶然亭离家相识吗？<br>　　陈独秀：<strong>那哪能忘啊？你在家，把酒热好了，怕凉，用棉被裹着，租一黄包车，送到陶然亭，大雪漫漫，冰天雪地，我们却喝着滚烫的花雕酒，这也算是前无古人，后无来者了。</strong><br>　　钱玄同：今天这酒，它有些凉。仲甫兄，我用手焐了一会儿，你换我这碗。<br>　　陈独秀：这样就好了，这样我胸膛里面就可以燃烧了一团火。有你，有雪，有花雕，这不跟那天一样吗？<br>　　钱玄同：一样，一样，有始有终。仲甫兄，你是我永远的朋友。<br>　　高一涵：仲甫兄，我真的，得好好的感谢你啊，能够让我成为《新青年》杂志的同人编辑，这是我收获最大、感觉最充实的一段时期。<br>　　陈独秀先：该说谢谢的应该是我，自从我们《新青年》实行同人编辑以来，一涵撰写了数量众多、分量极重的文章，你是科学与民主理念最积极的宣传者之一，也是我们《新青年》当之无愧的功臣。<br>　　鲁迅：说心里话，没有陈独秀逼周树人，就没有《狂人日记》和《孔乙己》，也没有这个，叫鲁迅的人。仲甫兄，我真的谢谢你。<br>　　陈独秀：豫才，我从来就认为，你是中国，思想最深刻的小说家。新文化的大旗，得你来扛，鲁迅，才是真正的旗手。　　</p><p>122、1920年2月，李大钊送陈独秀去天津路上，马车里二人推心置腹确立信仰<br>　　李大钊：仲甫兄，这趟去南方，你打算怎么做？我想知道。<br>　　陈独秀：我也正想问你这个问题呢。你说，你打算在北大，大张旗鼓地宣传马克思主义，还准备在长辛店搞工人运动，你到底怎么设想的，说给我听听。<br>　　李大钊：我打算，先开几门课，社会主义和社会运动、唯物史观、工人的国际运动、和社会主义的将来。另外我打算在北京大学，办一个马克思学说研究会，跟中夏也商量过了，想去长辛店办工人夜校，组织工人运动，筹办工人俱乐部。我觉得这次五四运动之所以能够胜利，很重要的一条，就是上海的工人阶级都起来了。<br>　　陈独秀：对，我说上海比北京的政治环境好，指的就是这个。<br>　　李大钊：依照马克思的理论，工人阶级是生产力的先进代表，应该是革命运动的领导阶级。<br>　　陈独秀：是，守常，你说的这些都是过程，你想过没有，我们的目标是什么？我们为什么要抛妇别雏、抛家舍业、东躲西藏，甚至会丢掉身家性命，我们到底在追求什么？<br>　　李大钊：其实最近几天，我一直在想你们家喝酒的时候，适之问我的那句话，他说咱们都已经是人中吕布、马中赤兔了，为什么要抛妻弃子？我们究竟想要什么？仲甫兄，我也想问你，这个问题，你搞清楚了吗？<br>　　陈独秀：我想，我已经想明白了。<br>　　李大钊：我觉得我也想明白了。咱们这个国家，曾经创造过人类历史上最灿烂的文明，可是鸦片战争之后呢？咱们这个国家迅速沉沦，速度之快、惨烈之巨，闻所未闻。不过八十年的时间，咱们这个国家就已经变成了世界上最贫穷、最没有尊严的国家。军阀混战、盗匪横行、百姓流离失所，过着水深火热的日子。我们呢？是这个国家为数不多的文化人，文化人就是文明人，文明人就应该为我们的国家和人民负责。我们有责任，带领人民进行抗争，我们要用马克思创立的科学社会主义原理。我们要建立，不被外国人欺负、不受统治者压迫、没有贪官污吏、人人能够当家做主、人人都能生活在幸福平等生活的美好社会。仲甫兄，我觉得这是历史，赋予我们的责任和担当，我们谁都不能把它辜负了。<br>　　陈独秀：守常，说得好！可是，我们到底要靠什么来完成这份责任和担当？<br>　　李大钊：组织！我们应该要有一个能够凝聚力量的组织和领导核心。仲甫兄，我觉得这件事应该提上议程了。<br>　　陈独秀：这件事情太重要了，你我要好好地筹划一下。　　</p><p>123、天津海河岸边 陈独秀目睹民不聊生之惨状痛哭流涕，与李大钊宣誓建党<br>　　难民甲：二位先生，看你们就是有学问的人，可怜可怜我这快要饿死的小孙女吧！<br>　　陈独秀：听您口音，像是从南边过来的？<br>　　难民甲：安徽凤阳的。<br>　　陈独秀：凤阳？凤阳是好地方啊，走千走万，不如淮河两岸。怎么今年，也闹灾荒？<br>　　难民甲：闹灾荒，闹瘟疫、闹土匪、闹兵乱，啥都闹，没法活了，就逃出来了。<br>　　李大钊：老爷子，这大冬天的，怎么不往南边去呀？<br>　　难民甲：本来我们一家人，想去济南投奔亲戚，可没想到，一路都在打仗，到处都是难民。亲戚没找着，这就顺着大溜来到了天津卫。<br>　　陈独秀：这难民，都是从安徽来的吗？<br>　　难民甲：哪儿的都有，河南、山东、山西、河北、安徽的，山东今年闹大灾，出来逃荒人最多。<br>　　李大钊：您拿着。<br>　　难民甲：你给我这也没有用啊，有吃的吗？<br>　　李大钊：您收着吧，能管用！<br>　　难民甲：好人呐。孩子，快给他们磕个头，这是恩人啊。好人哪！谢谢恩人！<br>　　李大钊：老爷子，您点这么多的灯啊？<br>　　难民乙：那边的朋友兄弟多，我不能让他们孤单啊。<br>　　李大钊：您这是祭奠朋友？<br>　　难民乙：都是当年闹义和团一起出生入死的弟兄，死了小二十年了，他们是为国家被洋人杀死的，死的时候，个个都是活蹦乱跳的小爷，媳妇没娶就走了，只剩我一个人，我不能不管哪。<br>　　李大钊：他们是为国捐躯而死的，死得值啊。<br>　　难民乙：<strong>值个屁！我今天来给他们送灯，就是给他们喊冤叫屈，为这样的国家去死，是冤大头！</strong>你看看这满河堤上，这么多年来，一年三百六十天，哪天不是满满当当的灾民哪？饿死的、冻死的、病死的、扔在路边没人埋。您二位是白面书生，我就问一句，这样的国家还有救吗？<br>　　陈独秀：政府难道不管吗？<br>　　难民乙：<strong>政府？哪见过这么浑蛋的政府？他们什么时候关心过老百姓的死活呀？</strong>八国联军杀进来的时候，这海河上到处漂的都是中国人的尸首，有的没了头、有的四肢不全、有的女子光着身子。可怜哪！老百姓命苦！这么多年，习惯了。<br>　　陈独秀：守常，我想了，我们得建党！我们得有一个坚强的领导核心。<br>　　李大钊：你想建一个什么样的党？<br>　　陈独秀：一个用马克思学说武装起来的先进政党，一个可以把中国引向光明、让中国人能够过上好日子的无产阶级的政党。<br>　　李大钊：你为什么要建这个政党？<br>　　陈独秀：不为什么，我为了他们……我为了他们……我为了他们，能够像人一样地活着，为了他们能够拥有人的权利、人的快乐、人的尊严。<br>　　李大钊：好，仲甫兄，让我们对着这些同胞宣誓吧！<br>　　陈独秀：来，让我们宣誓。</p><blockquote><p>​       李大钊：为了让你们不再流离失所。<br>　　陈独秀：为了让中国的老百姓过上富裕幸福的生活。<br>　　李大钊：为了让穷人不再受欺负，人人都能当家做主。<br>　　陈独秀：为了人人都受教育，少有所教，老有所依。<br>　　李大钊：为了中华，民富国强。<br>　　陈独秀：为了民族，再造复兴。<br>　　李大钊：我愿意，奋斗终生！<br>　　陈独秀：我愿意，奋斗终生！</p></blockquote><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144204.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144204.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144230.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144230.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="毛泽东北京再见李大钊深受启发-共产国际维经斯基抵华帮助建党"><a href="#毛泽东北京再见李大钊深受启发-共产国际维经斯基抵华帮助建党" class="headerlink" title="毛泽东北京再见李大钊深受启发 共产国际维经斯基抵华帮助建党"></a>毛泽东北京再见李大钊深受启发 共产国际维经斯基抵华帮助建党</h2><p>124、北京大学图书馆 毛泽东向李大钊请教湖南问题<br>　　李大钊：驱张运动之后，湖南将何去何从？你想过吗？<br>　　毛泽东：先生，这也正是我要请教你的问题。<br>　　李大钊：不，我其实是想听听你的意见。<br>　　毛泽东：这次驱张运动，我主要想的问题有两个：第一、<strong>只有依靠民众大联合才能实现救国救民的理想</strong>；第二、驱张运动后，努力争取实现湖南自治。<br>　　李大钊：好啊，润之，来焐焐手。这两个实际的问题都被你抓着了。好啊！<br>　　毛泽东：关于民众大联合的行动方式啊，有两个主张：第一、是马克思列宁的激烈派；第二，是克鲁泡特金的温和派。<br>　　李大钊：那么你毛润之现在是哪个派啊？<br>　　毛泽东：说实话，我现在很纠结。俄国十月革命的资料我看了不少，心向往之。但是从情感上讲，我对暴力革命还是心有顾忌，我可能更偏向于无政府主义的温和改良。<br>　　李大钊：那么润之，你打算怎么改良湖南呢？<br>　　毛泽东：现在是军阀混战，驱张之后，还会迎来新的督军。我知道，您和仲甫先生，都主张落实联省自治，所以我在想，我们湖南能不能带个头。驱张成功之后，首先摆脱北洋军阀的控制，建立以民为主的真政府。当然，这也只是我的想法，还没有理出头绪，所以，想听听您的意见。<br>　　李大钊：润之啊，两个问题啊：第一个问题，我还是建议你再多去了解一些俄国的十月革命，还有马克思主义的思想，我不妨明确地告诉你，我和仲甫先生，都已经确定了马克思主义的信仰。我们决心效仿俄国，走社会主义的道路，因为历史已经证明，<strong>中国走改良的道路根本就行不通，只有实现对于社会的根本改造，才可以挽救我们的国家</strong>；第二个问题，润之，我建议，把你的眼界放得更远一些，把改造湖南这个问题，放到改造整个中国社会的大方案当中去思考，这样你会少走很多的弯路的。<br>　　毛泽东：先生，其实，我非常崇拜马克思主义和社会主义，另外，我对俄国革命也是感兴趣的。我已经和新民学会的同志商量了，准备在长沙成立俄罗斯研究会。同时啊，我也去俄国留学或者勤工俭学，深刻地研究一下，中国到底适不适合走俄国人的道路，并且，迅速地找到答案。<br>　　李大钊：好啊，润之，我在北大成立了马克思学说研究会，而且在蔡先生的支持之下，我也搞了一个共产主义的书屋。我们那个书屋，有很多俄国革命还有马克思主义学说的书籍，而且经常开办推荐读书会，明天正好有一个讨论会，讨论的主题就是《共产党宣言》，你来参加吧。<br>　　毛泽东：太好了，我恨不得现在就看到那些书籍，先生，我一定去。<br>　　李大钊：润之，时不我待啊，我们不能总是在十字路口上徘徊了，到了该决断的时候了。　　</p><p>125、北京亢慕义斋  李大钊开办的共产主义书屋开展《共产党宣言》讨论会<br>　　李大钊：同学们，《共产党宣言》是卡尔.马克思和弗里德里希.恩格斯为共产主义同盟起草的纲领，由马克思执笔完成。那么这个宣言的基本原理，我觉得可以做如下的概括：任何一个历史时期，主要的生产方式和交换方式，和由此必然产生的社会结构，都是这个历史时期当中政治的、精神的历史，所赖以确立的基础，只有从这个基础出发，才能够解释历史。自从原始人类社会解体以来，人类的全部历史，都是阶级斗争的历史，这个历史包括了一系列的发展阶段。现在到了这么一个阶段，即无产阶级如果不能同时使整个社会，摆脱资产阶级的压迫、剥削、阶级划分、阶级斗争，那么它自己就不能从资产阶级的统治当中解放出来。消灭私有制、推翻资产阶级统治、由无产阶级夺取政权，然后一步一步地夺取资产阶级的全部资本，然后把生产工具集中在国家，即组织成为了统治阶级的无产阶级手中，然后尽可能快地增加生产力的总量，这是《共产党宣言》的基本观点。在这个革命当中，无产者失去的只是锁链，他们得到的将是整个世界，这是《共产党宣言》最后的，庄严宣告！　　</p><p>126、1920年1月29日至7月17日，青年周恩来在天津警察厅监狱里完成了思想的裂变，一种革命意识的萌芽从这个时候开始了。<br>　　周恩来：同学们，监狱也可以是我们的研究室，今天的演讲呢，由我来给大家讲一讲马克思的唯物史观。马克思的唯物史观有两个要点：其一是关于人类文明的经验的说明，其二是社会组织进化论。马克思认为，人类社会生产关系的总和，构成社会经济的构造，这是社会的基础构造，也就是生产力。生产力一有变化，社会组织必须随着它变化，社会组织即生产关系，他也和布帛菽粟一样，是人类依生产力产出的产物，守旧产出封建诸侯的社会、蒸气制粉机产出产业的资本家的社会。生产力决定生产关系，当生产关系不能满足生产力发展的要求的时候，就需要去打破这种旧的生产关系。旧社会组织对新生产力的束缚，产出新的适应生产力发展的生产关系，这就是社会革命。人类的社会，就是通过生产力不断地发展，不断地去打破旧的生产关系，产生出新的适应生产力发展的生产关系，来实现社会不断地从低级阶级向高级阶段发展，这就是马克思独特的唯物史观。　　</p><p>127、1920年4月，经共产国际批准派出的俄共党员小组维经斯基等人到达中国，先后会见了李大钊和陈独秀，对中国共产党的建党准备工作给予帮助。<br>　　陈独秀：跟他讲，按中国的习俗来。<br>　　维经斯基：那我们就握个手吧。<br>　　陈独秀：这个可以。<br>　　维经斯基：我听说，陈独秀先生不是特别喜欢中国的传统文化。<br>　　陈独秀：瞎说，那是讹传。我八岁随祖父熟读四书五经，十八岁中得院试秀才第一名，自信地说，中国的文化传统已经烂熟于心、挥之不去了。<br>　　维经斯基：想问一下，陈教授您是怎么看待马克思主义和俄国十月革命的？<br>　　陈独秀：我认为，马克思主义是当今世界上最科学的理论，俄国的十月革命的道路也是我们中国革命的榜样。<br>　　维经斯基：那太好了，那我们有很多共同点了。有样东西给您看一下。<br>　　陈独秀：欢迎你，维经斯基同志，坐！<br>　　维经斯基：我是俄共远东局的成员，这次受西伯利亚东方民族分部的派遣来到中国希望能接触中国信仰共产主义的同志，讨论建立党组织的可能性，我听说陈独秀先生是中国著名的思想家和群众运动的领袖，请您给我们提供帮助。<br>　　陈独秀：早在今年二月，我就和李大钊同志已经就在中国建党的问题达成了共识，之后 呢，又实质性地做了一些准备工作，比如北京大学的马克思学说研究会和即将在上海成立的马克思主义研究会，都是这一类组织。我们现在呢，正在抓紧建党，同时呢，也希望能够得到共产国际和俄共中央的支持和帮助。<br>　　维经斯基：太好了，我们拥抱一下吧！<br>　　陈独秀：很抱歉，维经斯基同志，拥抱，在中国的传统中是合体的意思。之后呢，要成立的中国党和俄国党，可以结盟，但不可以合体。中国有个传统，叫亲兄弟，明算账，你是你，我是我，什么时候都不能把自己弄没有了。所以，我们还是握手吧。　　</p><p>128、上海工人俱乐部夜校 《新青年》编辑 陈道望做演讲<br>　　工人同志们，世界上是些什么人，最有用、最贵重呢？必有一班糊涂的人说，皇帝最有用、最贵重，或者说做官的、读书的最有用、最贵重。我以为他们说错了。我以为，只有做工的人，最有用、最贵重。<br>　　我们吃的粮食，是那种田的人做的，不是皇帝、总统、做官的人做的；我们穿的衣服，是裁缝做的，也不是皇帝、总统、做官的人做的；我们住的房屋，是木匠、瓦匠、小工做的，更不是皇帝、总统、做官的人做的。</p><h2 id="陈独秀正式建立共产党-毛泽东周恩来坚定信仰"><a href="#陈独秀正式建立共产党-毛泽东周恩来坚定信仰" class="headerlink" title="陈独秀正式建立共产党 毛泽东周恩来坚定信仰"></a>陈独秀正式建立共产党 毛泽东周恩来坚定信仰</h2><p>　　我们做的各种车船，是木匠、铁匠、漆匠做的，还有许多机器匠、驾船工人、掌车工人、水手、搬运工人等等，有他们，才能够把我们的货物和我们自己送向远方，这些都不是皇帝、总统、做官的人的功劳。这个世界上，若是没种田的、裁缝、木匠、瓦匠、小工、漆匠、铁匠、机器匠、驾船工人、掌车工人、水手、搬运工人等，那我们便没有饭吃、没有衣穿、没有房屋住、没有车坐、没有船坐。如此可见，人类各项人中，只有做工的人是台柱子，因为有他们的力量，才能够把整个社会撑住。若是没有做工的人，那我们便没有了衣、食、住和交通，我们便不能生存。如此，人类的社会岂不是要倒塌吗？我所以说，只有做工的人，最有用、最贵重。<br>　　赵世炎：劳工万岁！劳工万岁！劳工万岁！　　</p><p>129、北京长辛店 李大钊给工人们讲五一国际劳动节的由来<br>　　好，那么我就给大家讲一讲，五一国际劳动节的由来，好不好？额，一八八六年的五月一号，美国两万个企业的三十五万名劳工，停工、罢工，他们都涌到了大街上，举行了声势浩大的示威活动。示威什么呢？他们向政府示威，要求改善他们生活和工作的条件，他们要求每天只工作八小时，而且他们唱着《八小时之歌》。哎呀这个歌词特别地有意思，我给大家说一说好不好？歌词大意是这样的：</p><blockquote><p>我们要改变这个世界，我们已经厌倦了，每天白白地辛苦，才只能挣到这么一点儿，糊口的工钱。<br>我们要每天工作八小时，因为我们没有时间思考了；<br>我们要实行八小时工作制，我们要闻闻花香，我们要晒晒太阳，因为我们相信，上帝只让我们工作八小时。<br>我们从船坞、车间、工厂，召集了我们的队伍，我们争取八小时工作、八小时休息，另外的八小时，留给我们自己。</p></blockquote><p>130、上海 毛泽东从曲阜回来探望陈独秀，寻求信仰<br>　　毛泽东：先生，我觉得老夫子是不是会见怪的，他呢，只是个画像，至于怎么贴，那是后人的事。<br>　　陈独秀：这话说得好。润之，你是少有的明白人。驱张运动进展如何，去年年底，我在《新青年》还发表了一篇《欢迎湖南人的精神》来声援你们。<br>　　毛泽东：是啊。我早就想来谢谢您了。在京合法抗争，和平地请愿了七八次，结果都失败了。眼下利用军阀纷争，有望结束张毒的戕害，但是把把张敬尧赶走之后，湖南自治之路怎么走？我这心里呀，很是困惑。<br>　　陈独秀：我告诉你，督军制度不除，就还是武人的天下，所谓的民主共和，竟是这类的军阀轮流坐庄，残民卖国。你跟他们上请愿书、讲改良、讲民生岂不是与虎谋皮？<br>　　毛泽东：先生说得极是。国事沉疴不起，唉，到底何为救国之良药，我都想试试，可是，颇费思量啊。陈独秀：我原来也一直想慢慢调理，启蒙教育，唤醒国人，渐次加以改良。但当今无时日，军阀、列强，内欺外压，如果行动慢了，中国必将瓜分豆剖，永远为人鱼肉。救国要义，我看，在于，立刻唤起行动。<br>　　毛泽东：先生，那依您看，何种信仰才是救国行动之指南呢？<br>　　陈独秀：走马克思、列宁指的路。你看，这是陈望道刚刚翻译出来的《共产党宣言》全本，这是救世的经典，我正在抓紧校阅，准备公开发表。<br>　　毛泽东：先生，这能不能先给给我看看。<br>　　陈独秀：当然，不仅可以给你看，润之啊，我还希望，你能跟我一样，能成为共产党的信徒。<br>　　毛泽东：我想我，一定会的。虽然之前看的都是节选，但是我的心哪，早就热血沸腾了。　　</p><p>131、上海 马克思主义研究会，陈独秀请赵世炎转述维经斯基对中国的看法，并开展讨论会<br>　　维经斯基认为，中国关于新思想的潮流虽然澎湃，但是，第一、太复杂。有无政府主义、有工团主义。有社会主义、有基尔特社会主义，五花八门，没有一个主流，这会使我们的思想，陷入混乱的局面；第二、没有组织。做文章、讲空话的人比比皆是，实际行动呢？却寥寥无几，这绝不利于我国进行革命。所以，他认为，中国的思想界和政治界最迫切的任务，就是尽快建立一个，坚定地、坚强地马克思主义政党。　　</p><p>132、上海法租界老渔阳里2号 毛泽东向陈独秀表明信仰<br>　　毛泽东：不过先生，我现在已经决定了，我以后啊再也不进学校了，我要走自主研究这条路。先生，《共产党宣言》我认认真真地反复读了几次，我现在确定，我要信仰马克思主义。<br>　　陈独秀：你真的确信？<br>　　毛泽东：先生，我的信仰一旦确立了，就不会支援，我要为了实现奋斗到底。<br>　　陈独秀：好，润之，就需要这样的决断，我真的太高兴了。你能加入我们，从此我们就是同志了。<br>　　毛泽东：先生，我们的党叫什么名字？<br>　　陈独秀：中国共产党<br>　　毛泽东：中国共产党，好，响亮的名字，<strong>昔者，共工怒而触不周之山，天柱折，地维绝。天倾西北，故日月星辰移焉。</strong><br>　　陈独秀：地不满东南，故水潦尘埃归焉。这是中国的上古神话，西方的神话里面也有不少英雄，我们就要做中国的普罗米修斯，不怕天罚，敢于盗火，为苦难的中国照亮前程。<br>　　毛泽东：我们也要准备，做共工这样的，万死不辞。勇于彻底粉碎旧社会的猛士。先生，过几天我准备回趟湖南，回去之后要干点什么，我想听听您的意见。<br>　　陈独秀：润之啊，你知道，我一直对你寄予厚望。你这次回去，要积极地宣传马克思主义，发动民众，为筹建在湖南的党组织，做好准备。<br>　　毛泽东：好，我听先生的。<br>　　陈独秀：我会多跟你联系，给你写信。<br>　　毛泽东：我也会给您写信的。　　</p><p>133、北京 觉悟社提出的会议<br>　　周恩来：我认为，我们集合在改造赤旗下的青年同志，认为当今的人类，必须基于相爱互助的精神，组织一个打破一切界限的联合。在这个联合里，各分子的生活必须是自由的、平等的、勤劳且幸福的。要想实现这样一个大同的世界、人类大联合的生活，不可不先由自由人民，按他们的职业，结合的小组织为基础，我们为渴望各种组织，一个个地实现，不能不奔走相告，高呼着到民间去。<br>　　邓颖超：守常先生，您再给我们来说说吧。<br>　　李大钊：同志们，刚才恩来同志的演讲大家都听到了，非常地精彩，现在全国各界，尤其是工人运动都已经搞起来了，那么各个先进组织，确实需要联合、需要改造，以壮大我们自身的力量。但是联合和改造，需要有一个前提，这个问题，大家应该要有一个正确的认识。我认为，各个先进组织，首先要有标明自己主义之必要，主义不明，便没有一个科学的指导思想。对内，既不足以齐一全体之心志；对外，尤不足以联合他人之行动。同志们，当今中国，已经到了我们这个组织，举起自己大旗的时候了。　　</p><p>134、1920年8月，上海法租界老渔阳里2号  中国共产党第一个早期组织在上海成立<br>　　陈独秀：同志们，今天在成立党组织之前，我想先宣读一下，我草拟的一个党的临时纲领，主要分为党的原则，和党的目的两部分，共产党原则有三条：一、没收一切资本，没收银行、矿山，废除个人压迫个人，经济上社会共有；二、领导工人阶级获得政权，打倒反动势力，过渡到消灭政权；三、消灭一切阶级。共产党的目的，也有三条：一、要进行阶级斗争，团结工人，由经济争斗发展到政治争斗，夺取政权；二、取得政权以后，发展阶级争斗；三、建设共产主义社会，以大规模生产为基础。大家要是没什么意见，请鼓掌通过。<br>　　俞秀松：同志们，根据中国共产党的组织原则，我们选举陈独秀同志为中国共产党执行局书记。<br>　　陈独秀：同志们，从现在起，我们几个就是共产党的第一批党员了。从今天起，中国的工人阶级，就有了自己的先锋队组织，我们的名字，叫中国共产党。现在，我们宣誓：陈独秀、李汉俊、俞秀松、施存统、陈公培。志愿加入中国共产党，决心为共产主义奋斗终生。中国共产党万岁！中国共产党万岁！　　</p><p>135、北京 中国共产党北京小组成立<br>　　李大钊：今天，中国共产党北京小组正式成立了，我们三人，有幸成为小组的第一批党员。接下来，我们宣誓：李大钊、张申府、张国焘，志愿加入中国共产党，决心为共产主义奋斗终生。<br>　　李大钊：同志们，让我们高呼，中国共产党万岁！　　</p><p>136、湖南 中国共产党长沙小组成立<br>　　何叔衡：润之，润之，你回来了，萍乡之行，有什么收获？<br>　　毛泽东：思想苦旅，洗心革面，凤凰涅槃，浴火重生呗。<br>　　彭璜：这么严肃，怪不得一大早把我们叫来，有什么要紧事？<br>　　毛泽东：我这心里呀，有一团火，想找你俩聊聊。<br>　　何叔衡：你有什么火？别憋着，说出来。<br>　　毛泽东：我这次去萍乡啊，主要是想了解煤矿和农村的情况。现在的中国呀，整个就像个大火炉，这老百姓水深火热、灾难深重，简直是活不下去了。<br>　　何叔衡：你跟我们说说你看到的情况。<br>　　毛泽东：就拿安源煤矿来说，那里有好多的挖煤工，他们都要在监工的皮鞭下工作。唉，这劳动的条件恶劣到了极致。每天都要工作十二到十六个小时，创造了这么大的财富，可他们的工资呢？却少得可怜。这矿工们都要住在窝棚里，这一到了冬天，简直冷得要命，这农村的情况，就更糟糕了。这逃荒要饭的、儿卖女的、到哪都是，这个国家已经烂透了。<br>　　彭璜：你怎么想的？<br>　　毛泽东：我已经想明白了，像陈独秀、李大钊先生说的那样，我们要走俄国的道路，要对整个社会，进行彻底的改造，才能可能，挽救中国。若想救中国，那出路只有一条——革命！<br>　　众人：天下者，我们的天下；国家者，我们的国家；社会者，我们的社会。我们不说，谁说？我们不干，谁干？<br>　　毛泽东：同志们，今天是一个特别值得纪念的日子，中国共产党长沙小组正式成立。中国共产党书记陈独秀同志，因为要到广东去，就任教育委员会委员长，就不能参加长沙小组的成立仪式了，他委托我来主持。鉴于目前的形势，这件事情还不能公开，我们要采取秘密的形式开展活动。现在，我们的主要工作有两项：第一，是改造新民学会，使之成为党的组织；第二，是创建湖南社会主义青年团，现在，让我们举起全拳头，轻轻地呼喊：中国共产党万岁！<br>　　旁白：从1920年下半年起，除上海、北京外，董必武、陈潭秋、包惠僧等在武汉；王尽美、邓恩铭在济南；谭平山、陈公博等在广州；毛泽东、何叔衡等在长沙；施存统、周佛海等在日本；张申府、周恩来、陈公培等在法国都先后成立了共产党小组。</p><h2 id="中国共产党正式成立-革命先烈誓死捍卫信仰"><a href="#中国共产党正式成立-革命先烈誓死捍卫信仰" class="headerlink" title="中国共产党正式成立 革命先烈誓死捍卫信仰"></a>中国共产党正式成立 革命先烈誓死捍卫信仰</h2><p>　　137、上海 陈独秀、汪大燮、吴稚晖送别蔡元培<br>　　陈独秀：孑民兄，你此次出国考察，若不是从上海出发，我也必定会想方设法去北京相送。先生在北大，有两项举措可谓功不可没：<strong>一、教育改革。改变了一代学子们的观念和德行，促进了新文化运动的发展；二是兼容并包。北大内有各种学说，随己所愿研究，是以毁誉不足计，而趋向之所宝贵者，则精神也。佩服！</strong><br>　　蔡元培：仲甫啊，你过誉了！伯棠兄啊，这些年我真应该好好感谢你，感谢伯棠兄这些年给我出了那么多馊主意。<br>　　汪大燮：孑民啊，你还真得感谢我，你在北大的这段时光啊，必会让你终生难忘啊。<br>　　蔡元培：仲甫啊，作为兄长，我有几句真心话想跟你说。<strong>人常说，道不同不相为谋，你我之间，道虽不同，亦可为谋。</strong>新文化运动是你和守常、适之还有鲁迅先生你们这几个人掀起来的，现在有些分歧，在所难免。但不要因为这个，而伤了彼此的和气。这次我来之前，我告诉适之，要他到上海来，与你好好谈一谈。<br>　　陈独秀：先生嘱咐的是，最近我已经打算，请守常和适之来上海一聚了。　　</p><p>138、胡适、李大钊来沪见陈独秀<br>　　陈独秀：人生不相见，动如参与商。要感谢你们拨冗来沪上一聚，了却我一桩心事啊。自古人才千载恨，至今甘醴二锅头。<br>　　胡适：仲甫兄，小弟我首先要恭祝你，荣任广东政府教育委员会委员长，这可是一个不小的官儿啊。<br>　　陈独秀：我决定去广州不是为了做官，是想，为中国落后的教育做点事情。就像当初，我们办《新青年》，不也是为了，启蒙人的思想，提高人的素质吗？<br>　　胡适：前两天我在北大红楼，听到几个同学在传唱一首歌谣：北大红楼两巨人，纷传北李与南陈。孤松独秀如椽笔，日月双星照古今。但这是他们的看法，而我对你们两个人的信仰，不敢苟同。<br>　　李大钊：适之啊，我跟仲甫兄飘洋过海去寻求真理，经过了那么多年的风风雨雨，经过了无数次的选择和探索，我们现在终于确定了一个方向：马克思主义是科学真理，十月革命是我们的榜样。你崇拜的那个西方的民主，在中国根本行不通。社会主义能够解救劳苦大众，为了这个美好理想，我愿意，献出我的一切。<br>　　陈独秀：适之，我相信，我们今天成立的中国共产党，并不仅仅是我和守常的选择，也是历史的选择，我相信，一定会有越来越多的中国人赞同、和加入这个选择。<br>　　胡适：好，好，今天我是少数派，我不和你们辩论。窃以为，既然是选择，朋友之间就应当允许人各有志，君子和而不同嘛。我们三个行至今日，信仰虽异，友情笃深，仅就此点，弥足珍贵。<br>　　陈独秀：好！好一个友情笃深，我同意。适之，守常，我们三个人，当永远坦诚相待，至于信仰的选择，孰是孰非，留给历史评判吧。我们今日这山野间一醉，明日别后已是山岳相隔，世事茫茫。<br>　　李大钊：渭北春天树，<br>　　胡适：江东日暮云。<br>　　陈独秀：何时一樽酒，<br>　　合：重与细论文。　　</p><p>139、北京 亢慕义斋 李大钊演讲<br>　　同志们，我也要给大家报告一个喜讯，中国共产党第一次全国代表大会正在南方进行，中国共产党正式成立了。这是开天辟地的一件大事。同志们，中国共产党的成立它不是偶然的，他是自鸦片战争以来，中国历史发展的必然产物；他是我们中国人民在救亡图存的斗争中，顽强探索的必然产物；他是我们中华民族在追求振兴的道路上，不断觉醒的必然产物。同志们，中国共产党的诞生，意味着我们中国革命从此以后有了坚强的领导核心，这为我们事业今后必须成功，打下了坚实的基础。同志们，《国际歌》的最后一句歌词，英特纳雄耐尔就一定要实现，这是我们共产党人，共同追求的最高目标，也是人类社会发展的最高阶段。同志们，三年前，我在中央公园有过一次演讲，里边有一句话，试看将来的环球，必是赤旗的世界。那么今天，我也郑重地跟大家说一说我最新的心得，那就是：中国只有走社会主义道路，他才能够实现，中华民族之振兴。而且我坚信，一百年以后的中国，他必会证明我今天的观点，社会主义，绝不会辜负中国。　　</p><p>旁白：<strong>其作始也简，其将毕也必巨。</strong>在中华民族内忧外患、社会危机空前深重的背景下，在马克思列宁主义同中国工人运动相结合的进程中，中国共产党诞生了。中国产生了共产党，这是开天辟地的大事变，这一开天辟地的大事变，深刻改变了近代以后，中华民族发展的方向和进程；深刻改变了中国人民和中华民族的前途和命运；深刻改变了世界发展的趋势和格局。中国共产党的诞生，是近代中国历史选择的必然结果，是中国人民选择的必然结果。自从有了中国共产党，灾难深重的中国人民，有了可以依赖的组织和领导者，开始了实现民族独立、人民解放和国家富强、人民幸福的伟大征程。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——11</title>
      <link href="/202108/46906/"/>
      <url>/202108/46906/</url>
      
        <content type="html"><![CDATA[<h2 id="陈独秀出狱-吴炳湘逼胡适撤销杂志社遭拒"><a href="#陈独秀出狱-吴炳湘逼胡适撤销杂志社遭拒" class="headerlink" title="陈独秀出狱 吴炳湘逼胡适撤销杂志社遭拒"></a>陈独秀出狱 吴炳湘逼胡适撤销杂志社遭拒</h2><p>　　李大钊：同学们，咱们大家都是五四运动的亲历者，五四运动是伟大的。那么我想问问同学们，五四运动究竟伟大在什么地方？<br>　　易群先：规模大、人数多、然后，各行各业都参加了。<br>　　李大钊：群先说得没错。但是我以为，五四运动最重要的一点，就是它是一场既反对封建主义，又反对帝国主义的、群众性的爱国自救运动。最近几天，我在韩文公祠里头面壁反思，我悟出了一个道理，中国要想求发展，恐怕要走俄国革命的道路，这是五四运动给我的启示。今天大伙都来了，正好，我提议，我们把红楼读书班再恢复起来，大家好好研究一下，未来的中国应该走哪条道路，好不好？<br>　　李大钊：同学们，我看了胡适先生的那篇《多研究些问题 少谈些主义》的文章，我觉得有几个重要的问题，我需要跟大家澄清一下，所以，我就作了这篇文章，取了这个题目。<br>　　易群先：守常先生，那为什么叫再论？<br>　　李大钊：因为有蓝公武在《国民公报》上发表了《问题与主义》一文，所以我的这一篇，就只能再论了。首先一点啊，我不同意胡适先生，少谈主义的观点，因为现在的中国，我们当务之急要做的事情，是寻找一条挽救国家沉沦的道路，没有主义和科学理论，就等于没有方向，寻找新路而没引路的旗帜，就可能走上一条歧路，甚至是一条死路。所以说主义是非常重要的。<br>　　邓中夏：先生，我看过胡适先生的文章，他说，他深深地感觉到了，主义的危险。<br>　　李大钊：胡适先生说到主义的危险，我觉得恐怕不是主义本身带来的。是什么带来的？是那些空谈它的人带来的。我记得仲甫先生曾经说过一句话，说，<strong>当今的中国，最需要的就是救国的理论</strong>，那么理论是什么，同学们？理论就是主义啊。所以，中国要想求发展，必须要找到一个先进的理论，就是主义。胡适先生说，社会主义有冒牌的，所以不能高谈，关于这一点，我也不敢苟同，诚然，当今的社会，的确游行着各种各样的社会主义。有我们宣传的科学社会主义、安福系的社会主义、各种形形色色冒牌的社会主义，的确败坏了科学社会主义的名声。但是，<strong>对我们寻求真理、寻求救国道路的人来说，怎么能因为有冒牌货就放弃了对科学真理的追求呢？</strong>对吧？我们不能因为安福系他们也讲社会主义，就停止对真理的追求。胡适先生主张少谈主义多解决问题，实际上是反对从根本上解决中国问题，并将这种根本解决说成是危险的过激主义。他主张多解决问题，实质是主张改良，不触动反动的根基，这是错误的，行不通的。大家知道，北洋政府的黑暗统治下，中国是一个没有生机的、枯萎的社会，他竟然敢把学校变成监狱，用来关押爱国的学生，在这样的社会里，你能解决什么实际问题呢？当你用什么工具都没有办法让它复活的时候，我们恐怕必须有一个根本解决的办法，才有把具体问题都解决了的希望。<br>　　陈延年：先生，我想知道有没有一种成功安全，是先谈主义，后解决实际问题的。<br>　　李大钊：有啊，就以俄国而论，实行生产资料归全体人民所有，这就是社会主义的原理，过去一切社会都不能解决的问题，现如今，全部解决了。依据马克思唯物史观，人类社会的基础是经济，法律问题、经济问题、家族问题等等精神构造都属于上层构造、表面构造，那么这些上层构造的下边有一个经济构造，经济构造是它们的基础，经济构造一旦发生变动，上边的构造也会跟着发生变动。那么换句话说，经济问题才是根本问题，所以经济问题一旦解决了，什么政治问题、法律问题、家族制度问题呀、女子解放问题呀、工人问题呀。通通都解决了。<br>　　邓中夏：先生，那个您能不能讲慢一点，我们有点记不下来了，我发现您最近对马克思主义又有了许多新的看法。<br>　　李大钊：我正在写《我的马克思主义观》的下篇，刚才那个题目，我们大家找个时间详细聊，但是今天我不想聊这个，我想跟大家谈谈布尔什维克主义。我公开宣称，我是很喜欢布尔什维克主义的。记得在协约国战胜的那一天，我作了一篇文章，叫《布尔什维克主义的胜利》登在了《新青年》上，可能是因为日本有人把布尔什维克主义翻译成过激主义的原因，就有人说它是一种凶暴残忍的主义，这是非常荒唐的。我有一种强烈的感觉，布尔什维克主义的游行是我们人类文化上的一大变动，我们应该介绍它，我们应该研究它，并把它昭布于人类社会，不可听信别人对它的谣言，就拿残暴的、粗暴的话对待它，抹杀它的一切。<br>　　陈延年：前一段时间有人说，十月革命之后，克鲁泡特金被人枪毙了，但是近期的欧美报导说，他在莫斯科附近安然无恙。<br>　　李大钊：对，这就让我们更加看清了，一个问题，布尔什维克主义是什么，那些主张不谈主义的，目的是反对布尔什维克主义，反对的是科学的真理，在这种情况下，我们怎么办？我们认为，宣称理想的主义与研究实际的问题是交相为用的，社会问题的解决，必须依靠社会上多数人的共同运动，而要有共同运动，就必须有共同的主义作为准则。所以，谈主义是必要的，不宣传主义，没有科学理论指导，社会问题永远没有解决的希望。让更多的人知道科学真理，并把这个主义当作材料，当作工具，去解决一个又一个的实际问题。至于那些阿猫啊、阿狗啊、鹦鹉啊、留声机啊，就任它们在旁边乱响；什么过激主义呀、洪水猛兽啊、异端邪说啊，我们就任他们给我们乱扣帽子，因为我们，根本就不在乎他们。　　</p><p>113、北京箭杆胡同9号 北大众师生为陈独秀举行出狱欢迎宴会<br>　　蔡元培：我很明白，你吃了很多苦。<br>　　陈独秀：只要能换取斗争的胜利，再多的苦，都甘之如饴呀！<br>　　蔡元培：说得好！我们欢迎英雄归来。<br>　　陈独秀：不敢当，不敢当，不敢当，无非是到世界文明的发源地，住了一下，哪里算什么英雄啊？<br>　　胡适：<strong>出了监狱，就入研究室；出了研究室，就入监狱，这才是人生最高尚、最优美的生活！</strong><br>　　陈延年、白兰、柳眉、刘海威、何孟雄、易群先、赵世炎、邓中夏：从这两处发生的文明，才是真文明，才是有生命、有价值的文明。<br>　　赵世炎、柳眉：女士们、先生们，大家好！<br>　　赵世炎：欢迎陈独秀先生光荣出狱欢迎宴会，现在开始！首先，请我们的蔡元培先生讲话。蔡元培：离开北大四个月了，今日见诸位，初始之心依在，初始之志未灭，倍感欣慰。现在我就说两句话：第一句话是，我们要感谢仲甫先生，是仲甫兄给我们点燃了科学民主的火炬，这把火炬的意义恐怕要在几十年之后才能显现出来，它给我们指引了方向，也照亮了前进的路；第二句话是，仲甫兄，我蔡元培对不起你。这是我的内心之言。<br>　　陈独秀：蔡公，我是真心感谢您，是您给了我一个舞台。<br>　　柳眉：下面的节目是献诗，仲甫先生入狱期间，很多先生都纷纷写了想念他的白话诗。首先，我们请适之先生献上他那首小诗。<br>　　胡适：此时，我想用《生查子》的曲牌，吟诵一首我的小诗，分享给在座的诸位朋友，也把这首诗献给我敬爱的朋友，仲甫兄：也想不相思，可免相思苦。几次细思量，情愿，情愿相思苦。<br>　　赵世炎：下面，请刘半农先生献诗，先生的诗，标题十分新潮，叫做《D！》<br>　　刘半农：仲甫出狱，我很激动，我快要出国了，我终于在出国之前，我又见到了他。我写了一首白话诗，我只念其中一小段：我已经八十多天看不见你，人家说，这是别离，是悲惨的别离。那何尝是，我们的友谊。若不是泛泛的仁兄、愚弟，那就凭他怎么着，你还照旧的天天见我，我也照旧的天天见你。威权幽禁了你，还没有幽禁了我，更幽禁不了无数的同志和无数的，后来兄弟。<br>　　陈独秀：半农，你是大才！<br>　　刘半农：仲甫，幸亏遇到你！<br>　　赵世炎：据说，守常先生昨晚一宿没睡，做了一首长诗，下面，我们一起来欣赏一下，先生的作品。<br>　　李大钊：这一趟呢，我跟仲甫兄，算是浴火重生、凤凰涅槃，虽然说我的这首诗有点长，但是我真心希望诸位，能允许我把它读完，以表，我对仲甫兄的，仰慕之情。可以吗？你今出狱了，我们很欢喜。他们的强权和威力，终究战不胜真理。什么监狱什么死，都不能屈服了你。因为你拥护真理，所以真理拥护了你。你今出狱了，我们很欢喜。有许多的好青年，已经实施了你的那句言语。出来研究室，便入监狱；出来监狱，便入研究室。他们都入了监狱，那么监狱就变成了研究室。你便住在这里，不须烦愁，寂寞没有伴侣。<br>　　鲁迅：这什么时候开席呀？口水都快流出来了！<br>　　高君曼：抱歉抱歉，来，真不好意思，我现在宣布，开席！<br>　　陈独秀：豫才啊，总是催着别人，你自己的席什么时候开啊？<br>　　鲁迅：我？我哪里有什么席呀？<br>　　陈独秀：哎？我可是等着你的小说盛宴开席呢。你不知道，在狱中很多时间，我是靠着读你的小说度过的。新文化运动，没有它可不行。<br>　　鲁迅：先生您看，吃人的嘴软，拿人的手短，这仲甫几天不见，催稿的本事可见长了！<br>　　陈乔年：各位先生，同学们，我还有些话想说。四年前，我还是个孩子，在汪孟邹经理为陈独秀先生举办的接风宴会上，我把那道黄牛蹄，换成了一只癞蛤蟆，本来我想戏弄我的父亲。但今天，我自己做了一份黄牛蹄，也不知道好不好吃，但我想把它献给我的父亲，献给从监狱，回到研究室的陈独秀先生！请您收下这份礼物，因为它代表了，我的歉意。<br>　　陈独秀：今天这道菜里，就算真有癞蛤蟆，我也要把它吃掉。各位，苟日新、日日新、又日新。今天的陈独秀，还是原来那个陈独秀；今天的陈独秀，又是一个全新的陈独秀。　　</p><p>114、天津草厂庵 天津学联办公室 觉悟社成立<br>　　同志们，今天，我们天津学生联合会和女界爱国同志会的男女各十名骨干，由于共同的使命、共同的觉悟走到了一起，正式成立觉悟社。我们的觉悟社，是天津学生爱国运动的领导机构，我们的目标是本着反省、实行、持久、奋斗、活泼、愉快、牺牲、创造、批评、互助的精神，做好学生方面的思想改造事业，带领大家共同走向自觉和自决。我们的决心，就是齐心努力向觉悟道，同时也盼着社会上所有的人，都能向觉悟道上走。同志们，由于斗争的需要，我们觉悟社社员的姓名，对外不公开，而用抽签的办法，以号取名，用以作为通信的代号和发表文章的笔名。现在桌子上有五十个纸条，每个纸条上写着一个编号，各位抽到的那个编号，就是你今后的通信代号和笔名，咱们现在开始抓阄。</p><h2 id="陈独秀辞职离开北大-陈延年兄弟将赴法国留学"><a href="#陈独秀辞职离开北大-陈延年兄弟将赴法国留学" class="headerlink" title="陈独秀辞职离开北大 陈延年兄弟将赴法国留学"></a>陈独秀辞职离开北大 陈延年兄弟将赴法国留学</h2><p>115、陈独秀出狱接风宴散会后，鲁迅答周作人为何提议陈独秀一人作主编的疑问<br>　　周作人：仲甫那么偏激，你怎么提议，让他一个人编《新青年》呢？适之虽然过于小心翼翼，但他心细，不至于出大纰漏。<br>　　鲁迅：那你的意思，是让适之一个人去编《新青年》啊？<br>　　周作人：我觉得他比仲甫合适。<br>　　鲁迅：大错！这两个人啊，我给你打个比方吧。假如将韬略比作一间仓库吧，独秀先生会在门前竖一杆大旗，大书八个字：内皆武器，来者小心。但门是打开的，里边有几杆枪、几把刀，一目了然，无须提防。但适之先生呢？仓库门是紧闭的，门上会有个小纸条，也贴八个字：内无武器，请勿疑虑。这自然可以是真的啊。但有些人，至少像我这样的人，我在推门之前，我总是会侧头地想一想。<br>　　周作人：你的意思，还是仲甫靠谱，是吗？<br>　　鲁迅：自己琢磨吧。　　</p><p>116、北大校园 北大教授给陈独秀送行<br>　　陈独秀：你们几个凑一堆，这是要去哪儿啊？<br>　　钱玄同：能去哪啊？你离开北大，我们来给你送行。<br>　　陈独秀：适之呢？<br>　　钱玄同：五大臣出国，适之张罗着欢送去了。<br>　　陈独秀：五大臣出国，什么意思？<br>　　钱玄同：适之用穆藕初的赞助，为罗家伦、段锡朋等五人，办成了赴美留学，北大人戏称五大臣出国。<br>　　陈独秀：最近出国留学的很多呀。<br>　　高一涵：可不是嘛，傅斯年没有挤进五大臣之中，适之就想办法给他搞了一个名额，现在人也去美国了，还有许德珩等人是去法国勤工俭学。<br>　　陈独秀：五四运动的先锋都走了，让人感觉有点秋风萧瑟的味道，但愿他们都能走上一条正路。<br>　　刘半农：我也要去英国了。<br>　　陈独秀：我知道，半农，我给你写了一幅字，本来想专程给你送过去，既然在这儿告别，那现在就给你喽。<br>　　刘半农：本有冲天志，飘摇湖海间。偶然憩城郭，犹自绝追攀。<br>　　陈独秀：寒影背人瘦，孤云共往还。道逢王子晋，早晚向三山。<br>　　刘半农：有点舍不得这里，舍不得你，舍不得咱们的《新青年》。<br>　　陈独秀：《新青年》还在，你现在就是《新青年》的海外同人编辑，我们还在一条战壕，希望你还能再给《新青年》写文章，特别是你的诗歌。现在可说，无人能及了。<br>　　刘半农：仲甫兄，谬奖了。我一定努力。<br>　　黄侃：仲甫，仲甫啊！你说你放着好好的教授不做，你偏偏要去编那个不伦不类的杂志。你这一跑，中国便是少了一部通史啊，这是多大的损失啊，你可曾想过这个问题？<br>　　陈独秀：季刚兄，你做你的学问，我搞我的不伦不类。至于是不是损失，历史自有公论。<br>　　黄侃：不可救药！别了，仲甫兄！<br>　　辜鸿铭：仲甫，君去也，还斗否？<br>　　陈独秀：一息尚存，战斗不止。<br>　　辜鸿铭：哈哈哈哈，贤弟保重，保重。<br>　　陈独秀：汤生兄，珍重！　　</p><p>117、陈独秀邀约李大钊游长城<br>　　陈独秀：眼下，正是深秋之际，骏马秋风塞北，霜林染醉，我们约上青年人，一同去逛逛长城，如何？<br>　　李大钊：城头无限今古，眼前万里关山，情境俱佳。天津的马骏还有周恩来成立了一个觉悟社，让我明天去给他们讲讲，我们周末如何？　　</p><p>118、长城 陈独秀、李大钊带领青年学生临别游长城<br>　　陈独秀：同学们，孩子们，延年、乔年刚到北京的时候，我就告诉他们两个，一定要来看看长城，登上长城，会有助你纵览古今，放眼寰宇。今天，他们将要辞亲别友、去国远行了，大家相携在此一游，可谓壮别。何处望神州，满眼风光看故楼。长城啊，长城，曾经是我们的先人，梦想抵御外敌的一道屏障，可是大家有没有想过，无论是清朝还是民国，多少志士仁人，舍身救国、血流漂杵，为什么我们这个国家空有这残垣万里，至今却依然是疮痍满目，在这个强盗的世界里，一败再败，任人欺侮，富国强兵，竟在何方？<br>　　邓中夏：仲甫先生，我们都认为，我们应该勇敢地站起来，把旧世界打个落花流水。<br>　　陈独秀：说得好，世界上的军国主义和金力主义现在是应该抛弃的了，<strong>我们理想的新社会，是诚实的、进步的、积极的、自由的、平等的、创造的、美的、善的、和平的、相爱互助的、劳动而愉悦的、全社会幸福的；希望那，虚伪的、保守的、消极的、束缚的、阶级的、因袭的、丑的、恶的、战争的、轧轹不安的、懒惰而烦闷的、少数幸福的现象，渐渐减少，至于消灭。</strong>我们对世界上各种民族都应该表示友爱的情谊，但对于侵略主义和占有主义的军阀和财阀，我们不得不以敌意相待。我们的主张是民众运动，是社会改造，要和过去以及现在各派政党绝对断绝关系。我们相信真正的民主政治，必会把政权分配给人民大众，不以财富有无为标准。我们反对一切拥护少数人私利、或一阶级利益，眼中没有全社会幸福的政党。<br>　　李大钊：同学们，自鸦片战争之后，我们中国人为了寻找救国的药方，已经有八十年了，可以说是尝遍了各种药方。但是今天，在这个古长城上，我和仲甫先生，在你们的身上，看到了这个曙光。同学们，你们是这个时代的先锋，我希望你们以青春的力量去实现社会主义的伟大理想，去重建我们这个民族的伟大辉煌。<br>　　陈独秀：别听我们两个在这演讲了啊！你们各自去感受长城。楚天千里清秋，水随天去秋无际。<br>　　高君曼：落日楼头，断鸿声里，江南游子。<br>　　众人齐声：把吴钩看了，栏杆拍遍，无人会，登临意。<br>　　陈独秀：虽然现在，我还没能十分肯定，但是大体上，已经有了一个初步的概念，那就是，也许只有马克思主义可以救中国，也许只有俄国十月革命的道路，才能救中国。<br>　　李大钊：哎呀，仲甫兄登临之意岂无人会？为霞满天哪。我真是想为你这个思想升华大声喝彩，我真是想冲这个长城大声呼喊，中国有救了。<br>　　陈独秀：所以我说，《新青年》复刊，要重点宣传和引进马克思主义，要宣传和研究俄国十月革命，要把办刊的重点由原来的思想启蒙转到探寻救国的道路，实现社会的根本改造上来。<br>　　李大钊：我已经正式提出申请了，下一个学期，我要开设唯物史观，和国际工人运动这两门课，同时，我还要建立马克思学说研究会，为将来提供一个政治性组织做好准备。<br>　　陈独秀：好，守常，还是你想得长远，五四运动这个事件之后，我们确实有些问题，需要想得深一点了。<br>　　李大钊：关键是，我们要重新再造一个国家，再造一个崭新的国家，而且要让国人生活在幸福的生活里。<br>　　陈独秀：说得好，这也是我们《新青年》复刊宣言的主旨。守常，我今天真的很高兴。<br>　　众学生：青年循蹈乎此，本其理性，加以努力，进前而勿顾后，背黑暗而向光明，为世界进文明，为人类造幸福，以青春之我，创建青春之家庭、青春之国家、青春之民族、青春之人类、青春之地球、青春之宇宙。资以乐其无涯之生，乘风破浪，迢迢乎远矣，复何无计留春，望尘莫及之忧哉。</p><h2 id="延年乔年赴法留学终是成为革命烈士-陈独秀去往南方其意在筹办西南大学"><a href="#延年乔年赴法留学终是成为革命烈士-陈独秀去往南方其意在筹办西南大学" class="headerlink" title="延年乔年赴法留学终是成为革命烈士 陈独秀去往南方其意在筹办西南大学"></a>延年乔年赴法留学终是成为革命烈士 陈独秀去往南方其意在筹办西南大学</h2><p>119、我们奋斗不过的精神，已渐渐在一班可爱的可敬的青年人身上复活了。我听了这类声音，欢喜极了，几乎落下泪来。——陈独秀为湖南人驱张行动做《欢迎湖南人底精神》　　</p><p>120、武汉文华大学礼堂 陈独秀做社会改造的演讲<br>　　各位同学，这半年多来，中国最大的变化莫过于民智大开、民气大盛。民众起来了，提出了改造社会的要求，我个人认为，这是五四运动最大的成果。社会改造要达到什么样的要求，大家都很关心这个问题。我呢，坐了九十天的大牢，对这个问题有了一些与以往不同的想，今天我说出来跟大家共同探讨。社会改造，一、要打破阶级的制度，实行平民社会主义，人人都不要有虚荣心；二、打破继承的制度，要实行共同劳动工作，不使无产的痛苦，有产的安享；三、要打破遗产的制度，不使土地私人传留享有，应归为社会的共产，不种田的人不应该享有田地的权利，这就是马克思说的，要消灭私有财产制。这样的社会改造要求我们，必须要建立起两个信仰：即平等的信仰和劳动的信仰。人人都要受教育，应该常劳动，心里总要有平等的劳动和劳动的革。，我们今天讲改造社会，是对社会根本的改造，而非改良。<strong>所谓根本的改造是指必要时，必须要采取流血革命的手段</strong>，当然，我们今天还没有到流血革命的时候，不过我们总要有研究革命的方法和信仰，到了那个可以革命的时机，我们非要与那恶魔奋斗不可。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——10</title>
      <link href="/202108/46904/"/>
      <url>/202108/46904/</url>
      
        <content type="html"><![CDATA[<h2 id="中国北洋政府拒签巴黎条约-陈独秀坐牢"><a href="#中国北洋政府拒签巴黎条约-陈独秀坐牢" class="headerlink" title="中国北洋政府拒签巴黎条约 陈独秀坐牢"></a>中国北洋政府拒签巴黎条约 陈独秀坐牢</h2><p>旁白：一九一九年六月二十八日，在全中国人民持续大规模抗争的巨大压力下，在全民族空前高涨的爱国、救国热情的感召下，中国代表团，最终，拒绝在屈辱的巴黎和约上签字，这是五四爱国运动的一个重要成果，是自鸦片战争以来，中国外交史上的一次胜利，这个胜利，是全国人民团结一致与帝国主义和北洋政府英勇斗争的结果，中华民族伟大觉醒的一个重要标志。至一九二二年二月，中日两国签订了《解决山东悬案的条约》及其附约，山东问题得到一定程度的解决，但日本在山东，仍继续保持相当大的势力。　　</p><p>105、湖南长沙 新民学会会员读《湘江评论》创刊号<br>　　毛泽东：时机到了，洞庭湖的闸门动了，且开了，浩浩荡荡的新思潮，业已奔腾，澎湃于湘江两岸了，顺它的生，逆它的死。如何承受它，如何传播它，如何研究它，如何施行它，这是我们全体湘人最切、最要的大问题，即是湘江出世最切、最要的大任务。——《湘江评论》的创刊号<br>　　何叔衡：润之啊，辛苦你了。这十几天，一个人写稿，一个人编辑，一个人排版，一个人印刷，硬把这创刊号赶了出来，不容易啊。<br>　　毛泽东：这算什么呀，仲甫先生啊，能够飞蛾扑火，宁愿用坐牢，也要让世人惊醒。我等青年，吃点苦又算什么呀？<br>　　何叔衡：你这一上来就印了六个不怕，写得好啊。<strong>世界什么问题最大？——吃饭问题最大；什么力量最强？——民众联合的力量最强；什么不要怕？——天不要怕、鬼不要怕、死人不要怕、官僚不要怕、军阀不要怕、资本家不要怕。</strong>漂亮！<br>　　彭璜：痛快！<br>　　毛泽东：大功告成，抓紧时间，把这个创刊号发给各个学校，然后分头去演讲。<br>　　旁白：一九一九年，青年毛泽东，在长沙度过了一个如火如荼的夏天，他担任《湘江评论》的主编和主要撰稿人，指导湖南学联发起湖南各界联合会，组织救国十人团，深入社会、街头发表演讲，广泛发动民众，掀起全社会的营救陈独秀活动。他指出，陈独秀先生是中国思想界的明星，他因为科学和民主得罪了反动当局，他的被捕不仅不能损及他的毫末，反而会留下一个大大的纪念，使他所倡导的新思潮越发的光辉远大。　　</p><p>106、北京京师警察厅监狱 吴炳湘诱劝陈独秀与北洋政府合作<br>　　吴炳湘：这份《湘江评论》创刊号，这个叫泽东的人哪，不仅把你捧为思想界的明星，甚至还高呼，我祝陈君至坚至高的精神万岁。这也太过了吧！<br>　　陈独秀：吴总监，也许就是像泽东这样的人，将来有一天，会冲垮你们的旧世界。<br>　　吴炳湘：是否能冲垮旧世界，结论为时尚早。我是想告诉陈教授，因为你的入狱，确实给政府带来了极大的麻烦，现在几乎整个中国都动起来了，可谓，前所未有。<br>　　陈独秀：意料中的事啊！<br>　　吴炳湘：可这对陈教授并非是好事啊。现在大家都知道，你是政府的头号政敌，许多人嚷嚷着，让我把你交出去，一旦你走出了警察厅，后果可想而知啊。<br>　　陈独秀：无非就是断头流血嘛，亦余心之所善兮，虽九死，其犹未悔。<br>　　吴炳湘：不过陈教授啊，你现在可是山穷水尽了。若能与我警察厅，有一些合作的话，或许，还可以柳暗花明。<br>　　陈独秀：打住，你要再说我可要骂人了，你觉得我陈独秀，是那种对自己的信仰可以做出妥协的人吗？<br>　　吴炳湘：哈哈哈哈哈，果然不出所料，陈教授果然是性情中人哪！好，你坚持你的信仰，我恪守我的职责，吃们走着看。<br>　　陈独秀：不送。莫听穿林打叶声，何妨吟啸且徐行，竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。　　</p><p>107、北京京师警察厅监狱  高君曼、陈延年、陈乔年、陈鹤年、陈子美、白兰、柳眉探望陈独秀<br>　　陈独秀：好，知我者，夫人也。这段日子我虽然身陷囹圄，心却更加自由放飞，有很多新想法，苦于远处倾泄，简直比拉不出屎来还难受。<br>　　高君曼：你说话注意点，孩子们都在呢。<br>　　陈子美：爸爸，你每天一个人，一定很无聊吧，就让英英陪陪您，说说话吧。<br>　　陈独秀：好，子美，哎呦，这个好，合情合景。我们两个都在笼子里，同病相怜，同室相依。<br>　　高君曼：仲甫，别说这么丧气的话，现在全中国的人都在营救你，你很快就会出狱的。<br>　　柳眉：就是啊，陈伯伯，我爸爸来信说，上海成立全国学联，有人提出口号，说陈独秀不出狱，决不复课。<br>　　陈独秀：嗯，我知道，我感觉现在整个运动中心已经从北京转移到上海了，工人阶级已经登上了历史的舞台，这可是一件，了不起的大事件。<br>　　陈延年：您这在牢记里面，消息也并不闭塞呀。<br>　　陈独秀：我整天两耳不闻窗外事，一心只是读书、学习、思考，当然不闭塞了。<br>　　白兰：先生，您都在思考些什么呀？<br>　　陈独秀：最集中的是两个问题：<strong>马克思主义和俄国革命。</strong><br>　　陈延年：那只是一个问题，都是社会主义。<br>　　陈独秀：不完全是一回事。<strong>一个是原生态，一个是最新成果；一个是理论，一个是实践，两者相得益彰。</strong>延年，我还是建议你和乔年，去读一读马克思的著作，尤其是四月六日那刊的《每周评论》，刊登了《共产党宣言》的第二章，可以帮助你们更多地了解马克思主义。<br>　　陈延年：您不说我差点忘了，这是适之先生让我带给您的《每周评论》最新的两期，大钊先生不是不在嘛，适之先生就直接接手了。<br>　　陈独秀：是《每周评论》吗？啊？这是我陈独秀创办的《每周评论》吗？这不是《每周评论》！这是杜威的研究专刊！这个胡适之，他不仅取消了我和守常特别重视的，反映政治斗争的战斗性文章和尖锐的评论，他还撤销了国内大事述评和国际大事述评，两个读者特别关注的专栏。你们看看，这两期全篇八个版面，十刊登的全是杜威研究录。去！把胡适之给我叫来，当面给我解释！　　</p><p>108、北京京师警察厅监狱 陈独秀在监狱大字报“诸恶莫做”背后写了幅字送吴炳湘<br>　　陈独秀：吴总监，我呢，专门为你写了一幅字，请笑纳，以感谢你对我的关照。<br>　　吴炳湘：春申浦上离歌急，扬子江头春色长。此去凭君珍重看，海中又见几株桑。<br>　　陈独秀：这是苏曼殊去日本之前，在安庆，我送给他的诗。没有什么特别的含义。按常规，应该有楹首、拦腰和压角，但是在这儿嘛，就按照你们的规矩办。啊！来！<br>　　吴炳湘：哈哈哈哈，哎呀，陈教授，你真是有个性啊，能把诗写在这个上面。<br>　　陈独秀：没有大张的纸了。<br>　　吴炳湘：<strong>诸恶莫做，众善奉行，凭君珍重。</strong>在下一定好好珍藏，此诗寓意颇深哪。胡教授，我今天算是沾了你的光了，能得如此墨宝。额，你们聊吧，我就不打扰了。　　</p><p>109、北京京师警察厅监狱 胡适向陈独秀请罪 陈独秀与其辩论，并写了幅字送他<br>　　陈独秀：《每周评论》不谈政治、不谈时事，算什么《每周评论》。<br>　　胡适：不是不谈时事、不谈政治，而是大谈时事，专谈政治。仲甫兄，难道你认为，杜威教授他来华不是时事吗？杜威教授他的专刊不是政治吗？杜威教授他的实验主义、民治思想也都是你赞成的。这就是政治呀！<br>　　陈独秀：你说得倒也不无道理，不过我认为，现在的当务之急，是要借五四运动的东风，大力宣传，鼓动民众起来，众根本上改造我们这个社会，寻找一条救国救民的科学道路。两个杂志——《新青年》主旨思想启蒙，《每周评论》引导群众运动，两个杂志相得益彰，都要起到这个作用才行啊。<br>　　胡适：寻路确实重要，关键还要讲究一些科学的方法，我以为现在的我们，必须要我研究一些问题，少谈一些主义。仲甫兄，清谈误国，这个道理一定要多讲啊。<br>　　陈独秀：适之，你这个观点值得商榷，没有好的科学主义指导，怎么能研究好问题？你这是舍本求末，你这种观点，一定会遭到守常的批判，对吗？<br>　　胡适：你说得没错，现在我也不知道为什么，守常和我在思想上的分歧，是越来越大了，他现在全心扑在了苏俄的暴力革命上面，动辄就是布尔什维克主义，这很危险。<br>　　陈独秀：适之，我们三个人，守常是俄国派，你是美国派，我之前是法国派。不过我现在，越来越倾向于守常的俄国派。你刚才提出的问题，我主张开始辩论。<br>　　胡适：好，我来挑这个头，不过，现在我和守常肯定是对立的，仲甫兄，您站哪一头？<br>　　陈独秀：我也给你写幅字。　　</p><p>110、河北昌黎五峰山 李大钊与农民田间种麦子<br>　　李大钊：老哥，等麦子下来了，就能吃上白面馒头了吧。<br>　　农民：哎呀，这又是捐又是税的，这麦子也剩不了几个了，平常的时候还舍不得吃，留着逢年过节再吃，平时家里吃的，还是红薯、棒子，这还不够吃呢。这不，多开点地，能种多些算多些吧。<br>　　李大钊：那不够吃怎么办啊？<br>　　农妇：平常少吃点，农忙时候吃干的，平时吃稀的，实在不够吃，就出去借点，借不到的时候，就去要饭吃呗。<br>　　李大钊：老哥，你们想过没有？吃收成这么好，日子过得还这么苦，还得出去要饭去，这，是个什么道理？<br>　　农民：命呗，当牛做马的命啊。哎呀，没办法，比不了你们这些识文断字的教书先生。<br>　　李大钊：当年做马不是咱的命。命啊，得咱自己个儿定啊。　　</p><p>111、河北昌黎五峰山韩文公祠 陈延年投奔李大钊寻救陈独秀之法<br>　　李大钊：哎呀！其实你父亲的事儿啊，你完全不用担心，他是虽有远虑，但是并无近忧。<br>　　陈延年：什么意思啊？<br>　　李大钊：什么意思啊，你父亲的案子对于他们上面来说，其实是挺棘手的。现在，应该有两种意见：第一种意见，就是以曹汝霖、王怀庆为首的安福系那些被免职了的将领，他们必欲置仲甫兄于死地而后快；另外一种意见，就是新任总理龚心湛，他主张释放你父亲，以安民心；那么总统徐世昌的如意算盘呢？是想把你父亲当作一颗棋子，好和南方政府谈判，明白了吧？三方势力，牵扯甚广。如果你父亲在外头，那么多半会被卷入到政治斗争之中，我估计不死也得扒层皮。但是巧了，他现在在里头，反而避开了这次灾难。<br>　　陈延年：那也就是说，现在什么都不做，反倒是最明智的？<br>　　李大钊：不是什么都不做，而是不能明着做。其实学联，一直都在暗中引导舆论的走向，只要民众的情绪到达一个临界点，一切问题就都解决了。<br>　　陈延年：那您这么说我就明白了。　　</p><p>112、河北昌黎五峰山韩文公祠 李大钊同给陈延年、陈乔年、邓中夏、赵世炎、何孟雄、易群先、柳眉讲儒学、五四运动的启发、胡适的《问题与主义》<br>　　李大钊：一封朝奏九重天，夕贬潮阳路八千。谷为圣明除弊事，肯将衰朽惜残年。云横秦岭家何在，雪拥蓝关马不前。这是韩愈先生上书言政被贬潮州在出京中上写下的著名诗篇。国内呢，纪念韩愈先生的祠堂总共有三处，一处在是河南的孟州，那是韩愈先生的家乡，第二处，是在广东潮州，韩愈先生曾经在那儿做了几年的官，第三处，就是我们河北昌黎了，其实河北昌黎和韩愈先生没有什么太大关系，只不过是和他的出生地同名，所以在明朝的时候，先后有人建了两座韩文公祠，一座在昌黎县城，还有一座就是在这儿。<br>　　何孟雄：守常先生，大家都说你是批儒大师，您怎么会住在这个尊儒文人的祠堂里？<br>　　李大钊：谁说我是批儒大师？这不太荒唐了吗？<br>　　何孟雄：您和陈独秀先生、胡适先生，不都是批孔的吗？<br>　　李大钊：批孔批的是政治尊孔，我和仲甫兄是非常尊重儒学文化的，仲甫先生对于儒学的传统有很深的研究，我之所以住在这儿，也是为了表达，我对于古代文学大家，韩愈先生的尊敬。最近，我又重读了韩愈先生几篇文章，受益匪浅啊。韩愈先生一生坎坷，为诗为文，直指时弊，发言直率，慷慨陈词，其文章之思想、可以说是光耀千古。同学们，我们今日之抗争，不也是为了给中国铲除弊政吗？所以大家一定要认识清楚了这一点。<br>　　柳眉：守常先生，前些时候，陈伯伯在编辑《新青年》文稿时，就这个内容啊，给章士钊先生写过一封信，谈的就是您这个观点。我记得当时他还念给我们听呢，说要在下一期 《新青年》上发表。<br>　　李大钊：这封信现在还在吗？<br>　　陈延年：警察抄家的时候给搜走了。<br>　　李大钊：提醒你爸爸，到时候把它要回来。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——09</title>
      <link href="/202108/46905/"/>
      <url>/202108/46905/</url>
      
        <content type="html"><![CDATA[<h2 id="陈独秀与儿子讨论新旧思想之争"><a href="#陈独秀与儿子讨论新旧思想之争" class="headerlink" title="陈独秀与儿子讨论新旧思想之争"></a>陈独秀与儿子讨论新旧思想之争</h2><p>91、《新青年》编辑部 陈独秀与陈延年讨论新旧思想之争<br>　　陈独秀：我在编辑下一期的《新青年》，总觉得缺点什么。我想写封信，主要是想澄清，两个大家都比较关心的问题：一、是在新文化运动中，革新派和保守派的争论，是个什么性质的问题；二、是我们革新派对中国旧学究竟是什么态度。<br>　　陈延年：这两个问题我也感兴趣，您跟我说说。<br>　　陈独秀：感兴趣？那好，你听我好好跟你说说。<strong>第一，我提出革新派和保守派的争论，是一种学术的进步现象，是学术之争，不是敌我之分。</strong>比如北大陈独秀、李大钊、胡适、鲁迅、钱玄同跟辜鸿铭、刘师培、黄侃之间的争论它就是这种性质。<br>　　陈延年：黄侃可不是这么想的，他那语言太恶毒了。<br>　　陈独秀：争论问题，各抒己见、慷慨激昂，甚至双方会骂几句，这属于正常的。纵观世界各国的历史，新文化的发展，都有这个过程。<strong>革新派和保守派是相对的，今日的保守派从前可能也是革新派，今日的革新派将来也许会变成保守派，世界进化的大流倘若没有止境，那么革新派和保守派的抗争也便没有止期，</strong>即使再过一百万年，道高一尺、魔高一丈，世界终究是革新和保守的抗争之世界。你今天看，我们是革新派，辜鸿铭他们是保守的，明天环境变了，也许就会颠倒过来，这是<strong>辩证的历史观</strong>。<br>　　陈延年：那您的意思是，也许有一天，辜鸿铭的观点也可能是正确的。<br>　　陈独秀：首先，你要承认，辜鸿铭、刘师培、黄侃、林纾，他们都是有专门学问的人；其次，即便是今天，他们说的一些观点也有一定的合理性；再次，我们和他们的争斗，<strong>说到底是社会变革的需要</strong>，到了一定时候，生活条件变了，人们对新旧之争的认识也会发生变化，甚至会逆转。你听明白了吗？<br>　　陈延年：那您这么说，我听明白了。那您第二个问题是什么？<br>　　陈独秀：第二个问题，我们革新派对中国旧学究竟是什么态度？今天我说的话你要记住，因为将来可能会有一些人在这个问题上扯皮，我总的看法是，中国旧学，是世界学术中的一部分；儒家孔学，是中国旧学中的一部分；孔教三纲，是孔学中的一部分，甚至是很小的一部分。对于孔学本分之内的价值存在，我们并不反对。<br>　　陈延年：等会儿，您说得太绕，我有点糊涂了。那您究竟反对的是什么呢？<br>　　陈独秀：你这个问题问得好，绕是吧？那我直接说，我们反对将一部分中的一部分的一部分的孔教三纲尊为道统，我们也反对将全体的全体的全体的中国旧学都一起踩在脚下，说得分文不值。革新派为什么要攻击孔教三纲？除了它不适合现在社会生活之外，这也是很重要的一点。<br>　　陈延年：哦，原来您是这样想的。但是吴虞先生跟易白沙先生那种激烈的态度给人不是你说那种印象。<br>　　陈独秀：刚才我不是说了吗，争论当中有过激行为，矫枉过正，这在所难免。我这封信我打算在下一期《新青年》中刊登，如果登不出来你要给我做证啊。我陈独秀在新文化运动中究竟是什么态度。<br>　　陈延年：这个我恕难从命。我认为，后人怎么看我们并不重要，重要的是，我们自己是不是问心无愧。<br>　　陈独秀：说得好，我同意。你这话像我老子说的。陈延年你记住，关于新文化运动，革新派和保守派的争论，我今天只跟你说一次，只此一次。<br>　　陈延年：您看您这说着说着又急眼了？<br>　　陈独秀：我没急呀。行了，走吧走吧走吧，该说的我都说完了。　　</p><p>92、苏武留胡节不辱，雪地又冰天，穷愁十九年。渴饮雪，饥吞毡，牧羊北海边。心存汉社稷，旅落犹未还。历尽难中难，心如铁石坚。夜坐塞上时听笳声，入耳心痛酸。</p><p>——北大三院 为解决被关押的学生上厕所问题，易群先让男女同学各围成一个圈背向而立，唱起《苏武牧羊》</p><h2 id="李大钊为学校心痛"><a href="#李大钊为学校心痛" class="headerlink" title="李大钊为学校心痛"></a>李大钊为学校心痛</h2><p>93、长辛店 李大钊分析当前形势，动员工人们要行动起来，坚持将运动进行到底<br>　　广大的工人朋友们，上海的工人们可不仅仅是上街啊，人家发布了罢工宣言，而且人家还准备要成立一个工人组织，要领导这次社会运动，工人朋友们，大家想一想，工人阶级站在中国的政治舞台上，这可是开天辟地的大事情啊，所以我呼吁大家，也要赶快行动起来，我们也要站到这次运动的最前列，好吗？<br>　　广大的工人朋友们，眼下是最危难的时刻，谁咬牙坚持到最后，谁就能取得最后的胜利。刚才大家也都听见了，我们被捕了一千多名学生，损失惨重。但是正因为这一千多名学生被捕了，让全中国的人民都看到了，北洋政府的反动。在国家被出卖的关键时刻，这些学生挺身而出，不惜牺牲个人利益和前途，用青春的热血抨击了政府的卖国行径和反动本质，也用他们的爱国壮举把所有的人民都给唤醒了。我坚信，只要我们再坚持一下，形势一定会有变化，当然在这个过程当中大家也要照顾好自己，不能莽撞、不能做无谓的牺牲，要谨防反动派狗急跳墙。虽然眼下是这么一个黑暗的时期，我依然相信，只要我们团结一致、努力奋斗，最后的胜利，一定属于我们！　　</p><p>94、北大红楼走廊 为寻找离家未归的陈独秀，李大钊、胡适就五四运动展开激烈争论<br>　　李大钊：适之啊，咱们去倡导新文化运动，是为了启发民智，那么国民觉悟了之后呢？势必会有所行动。光有思想，没有行动，是救不了国家的。<br>　　胡适：我不是说我们完全不去行动，我是说你们一定不能再走极端。<br>　　李大钊：极不极端应该有一个客观的标准。如果一个国家，强权压倒了公理；如果一个国家，涉及到核心利益，而人民的意愿不能表达的时候，那么这个国家的公民就可以行使民主的权利。我们拿日本举一个例子，中日甲午战争，中国战败了，我们割地、赔款，甚至把台湾都让给了日本人了，没办法，我们没脾气。可现在，我们是战胜国呀，适之，凭什么德国把我们的青岛让给日本呢？这还有公理吗？如果我们放任那些卖国贼，肆意妄为践踏民意的话，那我们这个国家，还能叫一个民主共和国吗？我们还配叫国家的公民吗？所以为了国家利益，我们现在需要一个彻底的革命，把思想觉悟和行动觉悟结合起来。我李大钊愿意当这个急先锋，九死而不悔，虽千万人，吾往矣！　　</p><p>95、目睹了学生被抓、五四运动遭到强烈镇压的陈独秀黯然神伤回到家中，向家人辞行（安排后事）<br>　　陈独秀：君曼，我要跟你说声对不起，因为，我不是一个合格的丈夫。延年、乔年、鹤年、子美，还有白兰，还有远在老家的玉莹和松年，我都要对你们也说对不起，因为我不是一个合格的父亲。我在家里憋了三天，今天出去转了一圈，你们应该能够想象得到，我看到了什么。我是一个年轻时候，就立志救国的革命者，但我不是一个好的老师，因为我看着那些学生，因为爱国家而深陷囹圄。所以，我必须要走出这一步，你们的父亲，必须要先让自己置之死地而后生。孩子们，我们家刚刚过上了几天安定的日子，可是今后，可能你们又将要面临不同的处境，因为我不能眼睁睁地看着我的学生们流血、流泪而无动于衷，我必须要跟他们在一起去战斗。因为我爱这个国家，这个国家不仅是我的，更是你们的，我要为这个国家去做点什么。今后，可能因为我，你们还会受连累；今后可能因为我，你们还会吃苦受罪，所以，我必须要跟你们说对不起，这杯酒是向你们赔罪的。<br>　　陈延年：虽然我有六不许，不能饮酒，但是今天我也要敬赔罪酒，因为我也是立志要为国家献身的，作为长子，我可能不能为父母尽孝，不能为弟弟妹妹尽责，今天就以这杯酒谢罪了。<br>　　陈乔年：我也是，这杯酒，我自己喝。<br>　　陈延年：爸，我给您斟满。</p><h2 id="学生们成功逼政府罢免卖国官员-陈独秀写独立宣言引胡适批评"><a href="#学生们成功逼政府罢免卖国官员-陈独秀写独立宣言引胡适批评" class="headerlink" title="学生们成功逼政府罢免卖国官员 陈独秀写独立宣言引胡适批评"></a>学生们成功逼政府罢免卖国官员 陈独秀写独立宣言引胡适批评</h2><p>96、《研究室与监狱》<strong>世界文明的发源地有二：一是科学研究室；一是监狱。</strong>我们青年立志，出了研究室就要入监狱，出了监狱就入研究室，这才是人生最高尚、优美的生活。从这两处发生的文明才是真文明，才是有生命、有价值的文明。</p><p>——陈延年偷读陈独秀通宵完成睡倒在地的文章　　</p><p>97、同胞们，现在全国民众都已经起来了。就在昨天，上海和天津已经全面实行了学生罢课、工人罢工、商人罢市。上海的很多商号也贴出了揭贴，挥泪停业，冀救被捕学生，不惩国贼，誓不开市。就在现在，北京学联组织的请愿团，已经到达了总统府，我们提出的要求有三点：第一点、惩办卖国贼；第二点、青岛不签字；第三点，绝不承认胡仁源为北大校长。而且立场，非允后不散。</p><p>——李大钊街头演讲　　</p><p>98、北大红楼 新青年同人编辑久别重聚，陈独秀已决心牺牲自己，为五四运动添柴加薪<br>　　刘半农：诸位，原来我以为北大要完蛋了，但是，没想到，它又活过来了。所以说，任何事情，都需要你经过坚持、再坚持的一番努力才行。<br>　　钱玄同：我没有你这么乐观，现在只是阶段性胜利，蔡公还没有回来，后边啊少不了更大的折腾。<br>　　鲁迅：并且，巴黎和约还待字闺中，这件事情不解决，永远都不能消停。好在，已经有希望了。<br>　　高一涵：鲁迅先生，您又有什么思想的火花，说出来听听？<br>　　鲁迅：这一个月，我看到了什么？——中国的脊梁，仲甫兄，新文化运动的启蒙效应已经显现了，东亚雄狮正在觉醒。那么接下来该干什么？要打掉国民性中逆来顺受的奴性，让他脱胎换骨。<br>　　高一涵：那我们乘胜追击，敦促政府，拒签巴黎和约，不达目的，誓不罢休。<br>　　胡适：各位，我有点不同的观点。现代社会都讲究各司其职，咱们是学校，是中国最高学府北京大学，我们得干一点我们北京大学应该干的事情。好不容易我们渡过了这个关口，我们现在应该把注意力放在如何尽快地恢复我们学校的秩序上面来，第一要务就是赶紧上课。<br>　　刘半农：适之先生，请问爱国和上课，哪一个才是北京大学的当务之急？<br>　　胡适：爱国和上课它不相矛盾啊，那你不上课，就能救国了吗？我们是学校，爱国和救国是长久之计，上课是日常事务，轻重缓急，不辩自明了。<br>　　陈独秀：危局之中，难得一聚，来说说我们《新青年》和《每周评论》下一步的计划吧。我有一个想法，我们《新青年》创办三年有余，一直是，在启蒙民众的思想，现在呢？民众已经开始觉悟了，那觉悟之后，干什么？不知大家，可曾想过这个问题？<br>　　钱玄同：现在最现实的是，抵制巴黎和约，把青岛给要回来，这个目的达不到，就不能算胜利。<br>　　高一涵：对<br>　　李大钊：德潜，抵制了巴黎和约之后呢？如果一个国家的根本问题没有解决的话，类似的问题还会一个又一个地冒出来，强国，富民也是一句空话。现在出问题的，是这个腐朽的政权，那么我的观点很明确，抗争，就要抗争到底。<br>　　胡适：我还是老生常谈啊，我不主张暴力革命，我也不主张成天把主义挂在嘴边，要讲究实际。说到向外国学习，我的看法还是要学习美国。各位同人别忘了，我们新文化运动，我们的旗帜就是科学与民主。所以中国要发展，必须全面学习美国。<br>　　陈独秀：哎，德潜，前些天，你不是还跟我说，说适之有些崇洋媚外，怎么不发言？所谓民主，就是各抒己见，不要掖着藏着。<br>　　钱玄同：我是想发表来着，但是，我确实还没有组织好。适之。<br>　　胡适：崇洋我有，决不献媚。<br>　　刘半农：决不献媚？那请问胡大博士，这些日子里，你天天夹个包，跟在杜威教授屁股后边，像个跟班似的，那不是献媚吗？适之，我觉得你特别像一个人。<br>　　胡适：谁呀？<br>　　刘半农：辜鸿铭身边的老辫子——刘二，是不是？<br>　　陈独秀：半农，我之所以这么说，是想我们大家可以各抒己见，但是各抒己见，是为了寻找方向。至于观点各异、孰是孰非，那是因国情和时代不同而定的，君子和而不同，这个和，就是我们现在的共同点，这个共同点是什么？我觉得那就是：无论如何，我们要对现行的社会进行改造，是改造，不再是改良，是一场革命。，这是因为，我看到了北洋政府种种的倒行逆施之后，得出的一个结论。而且我还要告诉大家，既然，我们发起了这样一场运动，那么到了这个关键时刻，我们就应该勇敢地站出来，直接行动，这也是我们这些觉醒者，在当下的责任和担当。<br>　　李大钊：岂曰无衣，与子同袍，我和你共进退。<br>　　高一涵：我也算一个　　</p><p>99、北大校园 陈独秀与李大钊边走边谈，安排身后事<br>　　陈独秀：守常，我有一个担心。担心我们《新青年》分裂，我们现在，几乎一见面就要争吵。<br>　　李大钊：我知道你的意思。适之吧太迷信美国，太迷信杜威那套实验主义了，其实也不想想，中国几千年的封建制度，怎么可能说说写写就改变了呢？要是不发生一次大的革命，中国不可能追上世界的潮流。<br>　　陈独秀：以前我觉得，你们两个你太激进，适之呢，又太中庸了。我在你们两之间，选其中。可是现在我想，我有了更多的倾向，这样势必会让适之，觉得更孤立。守常，我提醒你，适之很要面子，有些场合你别太难为他，有些事情我说说他，他勉强过得去，你说多了，他的面子过不去呀。<br>　　李大钊：你放心吧，我就，没把他当外人，你刚才说的倾向是什么意思？<br>　　陈独秀：关于马克思主义 。前一阵子，我在编《新青年》下一期的稿子，我把你写的长文《我的马克思主义观》又仔细读了一遍。同时，我又把四月六日《每周评论》发表的《共产党宣言》第二章《无产者和共产党人》也仔细读了一遍，很受感触，感概颇多。你在编者按中说，《共产党宣言》是马克思和恩格斯最先、最重大的意见，这对我有很大的启发。守常，我觉得，你现在是，中国宣传和信仰马克思主义的第一人，所以有些事情我需要请教你。<br>　　李大钊：请教不敢当。其实在日本的时候，我就已经关注马克思主义学说了，我现在正在写《我的马克思主义观》的下半部。但是我很想知道，你对于上半部分的看法和意见。<br>　　陈独秀：至少我现在觉得，马克思主义比无政府主义更要有理，比杜威的实验主义也要有理，但至于它是不是，当今时代最先进的理论体系，这个还不好说，因为我没有看到全部的马克思主义著作。<br>　　李大钊：其实对于马克思主义理论，我已经关注了很多年。之前我在日本的时候我就发现了，在日本很多人都在研究，马克思的社会主义学说，翻译了很多资料。原先我只是读它的原理，比如说历史唯物主义、辩证唯物主义、社会主义从空想到科学，但是最近，我把它结合到中国的实际来读，越读越觉得开窍。仲甫兄我有一个想法，中国要想求发展，必须依靠马克思主义理论，来做我们的指导思想，除此之外，很难找到第二条路。<br>　　陈独秀：你就这么肯定，你定的这个结论？<br>　　李大钊：这个还只是我的初步想法，但是五四运动之后，我的这个法相是越来越强烈，当然，也需要经过论证和思考。<br>　　陈独秀：那你是怎么看待俄国的十月革命的？<br>　　李大钊：这个问题，我在之前发表的《法俄革命之比较观》中就有所阐述。总的来说，俄国的十月革命与英法革命是截然不同的，我认为它是最先进的革命。<br>　　陈独秀：此话怎讲？<br>　　李大钊：以往的英法革命，归根到底，它还是资产阶级的革命，但是俄国的十月革命则不同，它是无产阶级领导的社会主义革命。依据马克思主义的理论，<strong>社会主义革命是资本主义发展的必然结果，</strong>从这个意义上来讲，它一定是最进步的革命。<br>　　陈独秀：马克思的书我读得不多，但是我知道社会主义学说一个基本的观点，就是<strong>社会主义革命只能在资本主义充分发展了之后才能爆发</strong>，可是现在俄国并不是发达的资本主义国家呀。<br>　　李大钊：这一点我原先也不了解，但是后来我看了列宁的书之后，我才知道，列宁有一个观点：<strong>社会主义革命可以在帝国主义的薄弱环节当中爆发，并且取得成功。</strong>你看，俄国的十月革命到现在，已经快两年了，苏维埃政权在帝国主义的层层包围之下已经站稳了脚跟，这个足以说明列宁的观点，是正确的。<br>　　陈独秀：那这么说，像中国这样积贫积弱的国家，也能搞社会主义革命了？<br>　　李大晚上：这一点我还在研究，不过俄国的十月革命已经为咱们做出了榜样。<br>　　陈独秀：好，守常，你今天给我上了一课。　　</p><p>100、北京箭杆胡同9号 陈独秀家里，陈独秀已抱定必死决心，请李大钊、胡适喝离别酒，陈延年坐陪<br>　　陈延年：《北京市民宣言》中国民族乃酷爱和平之民族，今虽备受内外不可忍受之压迫，仍本斯旨。对于政府提出最后最低之要求：一、对日外交，不抛弃山东省经济上之权利，并取消民国四年、七年两次密约；二、免徐树铮、曹汝霖、陆宗舆、章宗祥、段芝贵、王怀庆等六人官职，并驱逐出京；三、取消步军统领及警备司令两机关；四、北京保安队改由市民组织；五、市民须有绝对集会言论自由权，我市民仍希望和平方法达此目的，倘政府不愿和平，不完全听从市民之希望，我等学生、商人、劳工、军人等惟有直接行动，以图根本之改造。特此宣告，敬求内外人士谅解斯旨！<br>　　胡适：仲甫兄，这是何意啊？<br>　　陈独秀：这就是我说的，我们应该勇敢地站出来的意思。我有三点说明啊：第一，我完全同意，守常的意见，把学生运动拓展为，社会运动和群众运动；二、明确提出我们下一步的要求；第三、公开宣称，如果政府不尊重民意，我们将直接采取行动，以图，实现，对社会的根本之改造。今天呢，我就是想征求，三位的意见，并且也想让适之把它翻译成英文。<br>　　李大钊：仲甫兄，太好了！发动民众，广泛印发，延年，你们多印一些，印完之后给我，我亲自去散发。<br>　　陈延年：好<br>　　胡适：守常兄，你一个堂堂的北大教授青年导师，亲自上街撒传单，成何提统啊？<br>　　李大钊：不是适之，我从来没把我李大钊看得比别人高一等。你看啊，为了国家利益，群众能上街，工人能上街、妇女能上街，我有什么不能上街？你不是天天给人家讲平等、自由吗？怎么到我这儿就不行了？适之啊，我看你呀，<strong>是表面上新文化，内心里旧道德，表里不一啊。</strong><br>　　胡适：守常，我一直敬重你是文化人中的铁汉子，可是我真的不明白，你，还有仲甫兄，咱们都是文化人，咱们要讲的是什么呢？文化人就是士，士讲究的就是修身齐家治国平天下，要有家国情怀，修齐治平。现在修身，我们一直在做；齐家，我们的家齐了吗？二位好不容易才从穷困潦倒走到现在，如今呢，也算是人中吕布，马中赤兔了。可是为什么非要自毁前程？甚至不惜连累妻儿老小，我真的不明白你们在干什么。<br>　　李大钊：适之，其实你这个问题问得好。那现在我来回答你。我觉得，<strong>人，不能为了自己而活着</strong>。你到长辛店去看看那些破败不堪的工棚，你去津浦线去看看那些饿殍千里的难民，你再去前门大街去看看那些沿街乞讨的乞丐，我们难道不该为他们干点什么吗？你难道要求我们，像你一样，光鲜亮丽地活着吗？<br>　　陈延年：大钊先生，你觉得您说得太好了。国家到了这个份上，就应该豁出去，舍小家，才能顾大家，鱼和熊掌不能兼得。<br>　　陈独秀：延年，这有你说话的份吗？<br>　　胡适：仲甫兄，没事，延年可以发表他的意见。<br>　　陈延年：对不住，胡叔叔。<br>　　李大钊：适之啊，我刚才话有点言重了啊，对不住。<br>　　胡适：不碍事，真的不碍事，我知道你是个坦荡之人。<br>　　陈独秀：二位，坐下，你们都知道，我喜欢争论，争论才能出真理嘛，啊！来，举杯。<br>　　李大钊：适之啊，适之，不是你这个人就是这样，你，你不用藏着掖着，你有什么想法你就说。<br>　　胡适：我没有藏着掖着呀，我认为，仲甫兄要搞的这个市民宣言，是多此一举。况且现在杜威先生，来到中国，刚刚进入北京，所以每天，我要忙着给他张罗一些演讲的事情，这些事情我都需要去和教育部还有一些政府部门打交道，请他们出面亲自来安排，我不想把这些关系弄得太僵硬了。发动市民，争民主，我同意。所提这五条我也同意，特别是这第五条，但是这上面所说的，我等学生、商人、劳工、军人等唯有直接行动，过于强硬，没有必要吧！<br>　　李大钊：适之，这怎么叫没有必要呢？这句话最重要，它不能没有啊。<br>　　陈独秀：适之，你听我解释啊。从新文化运动到五四运动，这是个因果关系，前者是思想启蒙，后者是付诸行动，不管你乐不乐意，这些都是你我这些年，直接推动的结果。现在，国民觉悟，付诸行动了，这是一次飞跃，我们作为首倡者，不能阻拦，你也阻拦不了。孙中山先生说，<strong>世界潮流浩浩荡荡，顺之则昌，逆之则亡。</strong>我们要做促进派，不能做投降派，要想救中国，只有让民众直接面对，别无他途。我是考虑到，像有你这种想法的人有很多，所以我措辞还比较缓和，希望你能理解。<br>　　胡适：这点我注意到了。<br>　　陈独秀：适之，五四运动到今天，已经有一个多月了，民众已经付出很多了，我们不能撤火，我们只能添柴，不加把劲，北洋政府很可能冒天下之大不韪，一意孤行地在那个巴黎和约上签字，到那个时候，我们不但前功尽弃，国家也难保了。日本人的狼子野心，是个人就看得明白，在国家危亡之际、在国家利益面前，我们不能离心离德。<br>　　胡适：仲甫兄，你放心，我不会拖你们的后腿的。尽管现在，我们在思想上有些出入，但是爱国救国、争民主求发展，在大方向上我们一定是一致的。我同意你起草的这个宣言，我也愿意把它翻译成英文，不过你们两位堂堂的北大教授，出去撒传单我坚决不同意。<br>　　陈独秀：至于上街撒传单再说，啊，那相当于肉身投馁虎，来，我们三个干一杯。今天我们要把这两坛子老酒都喝光。<br>　　陈独秀：适之，前路坎坷，小心脚下。<br>　　胡适：仲甫、守常，前路坎坷，咱们，小心脚下。<br>　　李大钊：仲甫兄，那东西，不宜在红楼印，太招摇。<br>　　陈独秀：我知道，明天我去大沟头印。<br>　　李大钊：这事交给我吧。印、发都由我来，你不方便出面。<br>　　陈独秀：守常，我是下了决心了。这样，你去印，明日中午，我们大沟头碰面，咱俩一人一半，晚上去撒。<br>　　李大钊：这样吧，这事儿明天咱俩见面的时候再说，你先把稿子给我。<br>　　陈独秀：明天撒传单的事，别让延年知道，也别牵扯上延年，我不想让他掺和进来。</p><h2 id="陈独秀被捕-胡适暂时负责杂志编写"><a href="#陈独秀被捕-胡适暂时负责杂志编写" class="headerlink" title="陈独秀被捕 胡适暂时负责杂志编写"></a>陈独秀被捕 胡适暂时负责杂志编写</h2><p>101、女娃为精卫，衔石堙东海。东海水未堙，女娃心已改。夸父走虞渊，白日终相待。奈何金石心，坐视生吝悔。这首诗是1910年我在杭州精神最苦闷时写下的二十首诗中的其中一首，主要是想表达，要想成为革命者，就要不怕失败，要有不屈不挠的精神。今日送给你们这些青年人，就算是一种希望吧。</p><p>——陈独秀赠易群先手写诗</p><p>102、各位老师，各位同学，就在昨天，远在上海的孙中山先生会见了徐世昌，段祺瑞的和谈代表，他在会议上郑重地向他们提出，关于陈独秀先生被捕的事情，孙中山先生是这样说的：我和我的同伴们都十分地震惊，你们干的好事，足以使所有国民都相信，我反对你们是没错的。不过我看，你们也不敢把他杀死，因为杀死了一个人，就会出现五十个、一百个，所以你们尽管干吧。同学们，我再次呼吁大家团结起来，抗议政府无故抓人，立即释放陈独秀先生。</p><p>——北大校园 邓中夏号召同学们团结起来营救陈独秀</p><p>103、依他们的主张，我们小百姓痛苦，依你的主张，他们痛苦。他们不愿意痛苦，所以你痛苦，你痛苦，是替我们痛苦。</p><p>——北大校园 赵世炎读《每周评论》发表的短诗《怀陈独秀》</p><p>104、北洋政府总统府 钱能训总理向徐世昌大总统递辞呈<br>　　钱能训：菊人兄，原谅我，实在不能奉陪了。<br>　　徐世昌：我……你看你那点出息，一个陈独秀，就把你吓成这样了？啊？<br>　　钱能训：菊人兄，这陈独秀、李大钊，和他们领导的学生运动，简直是洪水猛兽。他们代表了一股潮流，你和我根本阻挡不了啊。<br>　　徐世昌：唉！这世道吧，真是要大变喽。你说，中国几千年了，能让统治者害怕的，能够改朝换代的，也就是农民起义了。可现在好了，农民没起义，秀才造反了。搅得天翻地覆的，而且软硬不吃，拿他没脾气。<br>　　钱能训：<strong>农民起义不可怕，农民起义改朝不改道啊。但现在这帮人，他们不光要改朝，还要改道、改制、改脑袋。</strong><br>　　徐世昌：改脑袋？什么意思？<br>　　钱能训：思想、理论，他们要用外国的理论来改造中国。<br>　　徐世昌：理论？什么理论这是，你说说？<br>　　钱能训：我也说不清楚，我只知道，我已经落伍了。<strong>急流勇退，尚可保一丝颜面；死杠到底，只能遗臭万年。</strong>菊人兄，你就饶了我吧。<br>　　徐世昌：好好好，走吧，走吧，急流勇退，保你的脸面去吧，走吧。我已走不了了，我只能遗臭万年了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——08</title>
      <link href="/202108/46902/"/>
      <url>/202108/46902/</url>
      
        <content type="html"><![CDATA[<h2 id="蔡元培欲辞职换取被捕学生自由-政府同意释放北大学生"><a href="#蔡元培欲辞职换取被捕学生自由-政府同意释放北大学生" class="headerlink" title="蔡元培欲辞职换取被捕学生自由 政府同意释放北大学生"></a>蔡元培欲辞职换取被捕学生自由 政府同意释放北大学生</h2><p>79、蔡元培：我想告诉大家，越是遇到现在这个情况，我们越需要冷静，我们都是读书人，我们是明事理的，我们是理智的，我们绝不会做那种乌合之众的事情。同学们的爱国行动，我蔡元培是支持的，但是出现了这个情况，出乎我的预料，我非常痛心，非常痛心。为此我这个当校长的，要引咎辞职，但是现在当务之急的，是要想尽一切办法，去营救被捕的三十二名同学，我要让他们安全地出来。我刚刚得到消息说，我们的被捕的同学已经转移到京师警察厅了，是忧是喜，我不清楚，但是我下定决心，我要亲自到京师警察厅去找警察总监吴炳湘，我要向他要人，我要把我的同学平安地带回学校来。我请同学们在学校耐下心来，不要出去，听我的消息，大家能做到吗？——北大红楼 蔡元培语重心长地劝慰想要拼死救出被捕学生的学生们　　</p><p>80、二位，我蔡元培是个教书人，如今我的学生遇了难，我理应相救，理应来关爱，所以，我恳请二位长官能给予我蔡元培帮助，难道二位长官就没有孩子上学堂念过书吗？李统领说学生们是犯人，我想请问，学生们的行动是为了他们自己吗？他们是爱国呀，他们是为了那个不平等的巴黎和约，这个不平等的巴黎和约激起了每一个中国人的愤怒。你们二位都是在民国政府里面的公职人员，在你们的眼里，爱国的学生竟然成了犯人？</p><p>——京师警察厅 面对李统领不放人的无理说辞蔡元培慷慨陈词　　</p><p>81、五四运动学生被抓，陈独秀、李大钊雨夜泥泞路上论道<br>　　陈独秀：创办新青年的时候，我提出过一个目标：要为中国寻找一个真理，一条道路。我想问你，今天，你找到了吗？<br>　　李大钊：我觉得我找到了，真理就是马克思主义，道路就是俄国十月革命。<br>　　陈独秀：你确定吗？<br>　　李大钊：正在确定的过程当中。仲甫兄，我最近写了一篇《我的马克思主义观》，想在《新青年》上发表，你没意见吧？<br>　　陈独秀：当然，我从去年下半年就十分关注马克思的著作，今年上半年，《新青年》每期都刊登和介绍马克思主义的文章，特别是上个月的每周评论，刊登了马克思的《共产党宣言》第二章，很有反响，我的思想也触动很大。<br>　　李大钊：《共产党宣言》是马克思和恩格斯的经典著作，非常精彩深刻，很多段落我都能背。<br>　　陈独秀：老实说，我虽然没有像你那样的确认，但是我对马克思主义的兴趣越来越浓烈了。至于说俄国的十月革命，我也有同感。我研究得不多，但是我觉得，跟英、法、美比起来，可能俄国的方式更适合中国。守常，我非常想，有机会、有时间，我们两个仔细地、好好地讨论一下这个问题。<br>　　李大钊：我也有很多的想法和问题想跟你讨论。<br>　　陈独秀：今天一天事情发生下来，对我刺激很大，我在想，可能从今天起，我们，要一起走上一条，和反动政府直接对抗的道路。守常，你想，这条路应该怎么走？<br>　　李大钊：其实我想了很久，我觉得你说的是对的，我们必须要让民众直接出来解决问题，光靠我们学生不行，我们必须要发动群众，进行斗争。<br>　　陈独秀：对，今天，只是一个导火索，我们的任务，是要用它引爆整个中国，让全国各行各业都要行动起来，让他们直接参与到改造整个社会的斗争中来，唯此，中国才有危房。<br>　　李大钊：过去咱们的新青年，只是关注思想启蒙，现在我们要明确提出从根本上改造社会的任务，这就是我们的责任。<br>　　陈独秀：好，那我们的《每周评论》和《新青年》两个刊物，要都做这方面的文章，今天晚上我们就开始，争取明天出刊。<br>　　李大钊：仲甫兄，你又让我想起了那句话——<br>　　李大钊、陈独秀：让暴风雨来得更猛烈些吧！　　</p><p>82、<strong>你们可真是，不是一般地自大啊！你们以为，唤醒一个被封建思想禁锢了几千年的民族，是那么容易的吗？你们以为，要扫除我们这个民族血液里面的麻木、冷漠、惰性思维是一日之功吗？那是要经过几代人，努力奋斗的大事业。我告诉你们，你们现在没有权利去死，我们这个灾难深重的国家需要你们去活着，需要你们去奋斗。</strong></p><p>——陈独秀振臂力劝想把牢底坐穿的学生出狱</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821145002.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821145002.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img">　　</p><p>83、北大红楼 陈独秀、李大钊论唤醒国人之道<br>　　李大钊：原来你是这样给他们带回来的，倒是你的风格，不过，有的时候，你实在是有点霸道！<br>　　陈独秀：我霸道吗？不是我霸道，是他们太糊涂，革命者怎能做自绝于革命的事情？<br>　　李大钊：那你这个闹钟，也得尊重一下炸弹的决绝吧？<br>　　陈独秀：什么意思？<br>　　李大钊：打个比方啊，<strong>一片大地上，躺着一群沉睡的人，远处就是火山，马上就要爆发了，你就像个闹钟，面对这些沉睡的人，你想把他们叫醒。你持续不断的响着，有的睡的浅的人，被你叫醒了，跟你一块去叫醒众人，但是人数太多了，你们的声音太微弱了，叫醒的人毕竟有限，而且保不齐有的人嫌烦，时不时还踢坏两个。那么有的闹钟，怕来不及，就拿自己的生命当做原料，化成了炸弹，一下就炸醒了一大片人。</strong><br>　　陈独秀：那照你这么说，炸弹比闹钟厉害多了，那么多来几个炸弹不就行了吗？还要闹钟何用啊？<br>　　李大钊：非也呀！仲甫兄你想想，<strong>要是没有闹钟，夜以继日、呕心沥血地啼鸣，便不会有炸弹的诞生，炸弹的威力虽大，但是它终究战胜不了人之惰性，只有需要闹钟，持续不断地提醒着、坚持着，才能最终将所有人唤醒啊。</strong></p><h2 id="郭心纲逝世-蔡元培辞职离开北大"><a href="#郭心纲逝世-蔡元培辞职离开北大" class="headerlink" title="郭心纲逝世 蔡元培辞职离开北大"></a>郭心纲逝世 蔡元培辞职离开北大</h2><p>84、陈独秀、李大钊、白兰、赵世炎、刘海威、邓中夏、高君曼病房送别郭心刚<br>　　郭心刚：我要和你们永别了，心刚此生最大的荣幸就是认识了二位先生。可惜国家濒危，当局却以狮子搏兔之力弹压我等爱国之心，让我感觉到在自己的国家和在日本一样的受欺负，这样的国家还有什么希望啊？二位先生，你们要救救这个国家，救救这个民族。<br>　　陈独秀：心刚，你是国家的英雄，你是这个国家青年的榜样。　　</p><p>85、辜鸿铭与刘师培、黄侃谈“天要下雨、娘要嫁人”<br>　　辜鸿铭：申叔兄，想向你请教一个问题啊，你说这“天要下雨娘要嫁人”，这个“娘”说的是谁呀？我以为呀，要嫁的这个“娘”，她绝不是孩子的娘，应该是未出阁的黄花的大姑娘。最近我看了清人王有光的《吴下谚联》关于“天要落雨，娘要嫁人”，他是这么解释的。他说，天纯阳无阴，要下雨则阳之求阴也；娘呢？是孤阴无阳，若要嫁人则阴之求阳也。如矢赴的，如浆点腐，其理如是，其势如是。你看，这王有光啊，他说的这个嫁人的“娘”，是未婚的女子，如果是已婚的女子，那就不可能是孤阴无阳。所谓的男大当婚，女大当嫁，女儿大了不中留，留来留去留成仇，就是娘要嫁人，这是人道；天要下雨呢，是天道，天道人道这两者是不可抗逆的。<br>　　刘师培：辜汤生，您跟我们显摆这些，是什么意思呀？<br>　　辜鸿铭：我说是想啊告诉你们，要走的它一定要走，该留的它一定会留。这是不以人的意志为转移的。　　</p><p>86、蔡元培北大宣传栏留纸条辞职，辜鸿铭、刘师培、黄侃为学生们解读<br>　　蔡元培字条：我倦矣，杀君马者道旁儿，民亦劳止，迄可小休，我欲小休矣。北京大学校长之职已正式辞去，其他向有关系之各学校、各集会自五月九日起，一切脱离关系，特此声明，惟知我者谅之。<br>　　辜鸿铭：同学们，你们听我讲，啊！你们看，蔡先生这个字条的开头就上了两个典故，我们要想了解蔡先生的心思，首先就要知道这两个典故。你看，这一个典故是：杀君马者道旁儿。它出自于汉代应勋所撰的《风俗通义》，它的原文是“长吏马肥，观者快马这走骤也，乘者喜其言，驱驰不已，至于疾死。”这个典故的意思就是：有一个官吏，它的马养得很肥，跑得也很快，受到了路人的称赞，这个骑马者呢，就开始扬扬得意，开始策马扬鞭，奔跑不停，就把这个马给累死了。这还有第二个典故：民亦劳止，汔可小休。它出自于《诗经.大雅》之《民劳》，它的第二句开始就是民亦劳止，汔可小休，惠此中国，以为民逑。<br>　　黄侃：汤公啊，你这说来说去说跑题了，人家学生的意思，是问您，蔡先生，这个字条到底为何意？这位同学，我来告你知，这杀君马者道旁尔，这个“君”指的是政府，这个“马”呀，指的是曹汝霖和章宗祥，这个“道旁儿”说的便是你们这些学生。蔡元培之意为，你们这些学生闯了祸，害得他不得不跑了。<br>　　辜鸿铭：非也！你这是对蔡公的诬蔑！同学们，我以为，“君者”指的就是你们同学们，“马也”指的就是蔡公他自己，至于“道旁儿”，说的就是那该死的巴黎和约，还有卖国贼典故曹、章、陆。蔡公之所以出走，它完全是被奸人所害，他这样做，可能是出于迫不得已，也可能是缓兵之计，但是我辜鸿铭相信，蔡公，一定不会舍弃北大的。<br>　　刘师培：天要下雨，娘要嫁人，随它去吧。　　</p><p>87、郭心刚追悼会前准备工作<br>　　君去矣，甘将热血红青岛。吾来也，不许狂奴撼泰山。——陈独秀为郭心刚题挽联<br>　　陈独秀：救国与做学问，孰重孰轻？孰大孰小？不辩自明，个人和国家的命运是分不开的。我现在体会这场运动，除了让人民直接行动，直接解决问题之外，还要再加两个字——牺牲！<strong>牺牲，没有牺牲，不可能胜利！</strong><br>　　李大钊：各位老师，各位同学，郭心刚，因为爱这个国家，献出了他宝贵的生命，他是我们北京大学北京学界乃至全中国的光荣和骄傲。我们永远不会忘记他，我们要用郭心刚的死，唤醒民众，继承其志，完成其未竟之事业。所以我们决定，五月十八号下午，在这儿，举行郭心刚烈士的追悼大会，同时我宣布，北京中等以上学校、学生联合会、北京各校教职工联合会会议的决议：为了抵制北洋政府的倒行逆施，决定，自五月十九号起，北京各校全体，总罢课。</p><h2 id="陈独秀写罢课文章-胡适提议搬迁北大"><a href="#陈独秀写罢课文章-胡适提议搬迁北大" class="headerlink" title="陈独秀写罢课文章 胡适提议搬迁北大"></a>陈独秀写罢课文章 胡适提议搬迁北大</h2><p>88、北大红楼长廊 陈独秀怒怼胡适贸然将北大搬到上海的提议<br>　　北大是中国的北大，全中国的一流大学，凭什么它北洋政府说解散就解散？北大解散，你问问中国的民众答不答应？北大的老师、北大的学生们答不答应？适之，你什么时候变成了一只被北洋政府驯服的绵羊了？<br>　　我要的不是北大的生机盎然，我要的是中国的生机盎然，不辩、不争，不可以。<strong>生机盎然不是等来的，适之，是要斗争来的，不破不立！</strong>此时的中国需要勇士和斗士，凭什么我们中国人要眼睁睁地看着签订巴黎和约？凭什么我们要眼睁睁地看着青岛拱手让给日本人？我们中国人，就应该像畜生一样等死吗？就应该像畜生一样任人宰割吗？<br>　　<strong>你这是妥协！是投降！中国之所以这么窝囊，就是因为郭心刚太少，胡适之太多了。</strong></p><h3 id="陈延年受伤住院-胡适反对陈独秀激进对抗政府"><a href="#陈延年受伤住院-胡适反对陈独秀激进对抗政府" class="headerlink" title="陈延年受伤住院 胡适反对陈独秀激进对抗政府"></a>陈延年受伤住院 胡适反对陈独秀激进对抗政府</h3><p>89、现在，中日两国的军阀，不都是公理的仇敌吗？两国的平民，若不用强力将它们打倒，任凭你怎样天天把公理挂在嘴上喊叫。我们不可主张用强力蔑弃公理，却不可不主张用强力拥护公理；我们不主张用强力压人，却不可不主张用强力抵抗被人所压。一个人、一民族，若没有自卫的强力，单指望公理昌明，仰仗人家饶恕和帮助的恩惠才能生存，这是何等卑弱无耻、不能自立的奴才！</p><p>——法国医院 陈独秀给轻微脑振荡的陈延年读了一小段自己的文章《山东问题和国民觉悟》　　</p><p>90、北大红楼图书馆 李大钊针对北洋政府颁布的放假考试的通知，召开学生干事和教授团应对会议<br>　　刘海威读陈独秀的《山东问题和国民觉悟》：我们国民为山东问题，应该有两种彻底的觉悟<strong>：一、不能单纯地依赖公理的觉悟，二、不能让少数人垄断政权的觉悟。</strong>由这彻底的觉悟，就应当抱定两大宗旨，就是：强力拥护公理、平民征服政府。<br>　　李大钊：说得好，现在这种情况就需要这么一记——棒喝！<br>　　胡适：我的守常兄啊，你怎么会像有的学生一样的莽撞呢？你是青年导师，你现在做的应该是沉静下来，而不是火上浇油啊！<br>　　陈独秀：适之，你错了！现在就应该火上浇油，我们现在做的就应该是火上浇油，同学们的爱国热情都已经燃烧起来了，我们要再添一把火，让它把整个社会照亮！让全中国的爱国热情都燃烧起来！这样，才能救我们这个国家。<br>　　李大钊：说得好！（掌声）<br>　　胡适：你们作为北京大学的学生，青红皂白你们都不分了吗？守常兄，你要为你的收好声付出代价的，火上浇油？你是想让你自己，还有整个北大都被烧死吗？<br>　　陈独秀：适之，你有意见、有情绪你冲我来，你这给大家泼冷水吗？不是我们走极端，是北洋政府在走极端！警察打伤了孩子，抓走了学生，你没看见吗？你是一名老师，你可以无动于衷吗？<br>　　邓中夏：同学们，刚刚我们收到了来自巴黎的电报，电报上面说，巴黎的专使正在苦苦地坚持，巴黎的华侨们也都在游行、抵抗，请诸位万万不要放弃，一定要坚持下去！所以，北京学生联合会临时代表大会一致决定，所属的三十六所学校继续罢课，坚持斗争，进行到底，不达目的，决不罢休！同时，学联还决定，为了减少不必要的牺牲，北京各校十人团，取消游行和示威的活动，可以用别的方式代替，以卖国货的方式，动员市民们来抵制日货，抵制巴黎和约。所以，请北大各科各班的同学们，抓紧时间，准备国货，明天上街。<br>　　陈独秀：适之，我知道，刚才我言重了，当着你学生的面，没给你留面子，你一定心里有情绪。你说假话，我们之间不需要说假话，不管你有什么样的情绪，我都要再跟你说一句：现在的形势，在这个裉节上，你觉得我们这个国家，还可以再后退吗？如果再退，我们还有脸做这个国家的国民吗？如果你还消化不了，改天我请你喝酒！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——07</title>
      <link href="/202108/46903/"/>
      <url>/202108/46903/</url>
      
        <content type="html"><![CDATA[<h2 id="蔡元培在国会上洗清冤屈-日本霸权引中国各界不满"><a href="#蔡元培在国会上洗清冤屈-日本霸权引中国各界不满" class="headerlink" title="蔡元培在国会上洗清冤屈  日本霸权引中国各界不满"></a>蔡元培在国会上洗清冤屈  日本霸权引中国各界不满</h2><p>67、宣武门国会小议事厅 张长礼弹劾蔡元培、陈独秀失败，落荒而逃后，陈独秀即兴把议会当成了记者招待会<br>　　陈独秀：你们诋毁够了，也闹腾够了，应该，我们，说几句了吧！啊？各位记者朋友，别误会，这里是国会参议院，不是自由市场，想必你们也不想白来一趟，一无所获是吧？今天我站在这儿了，有什么问题尽管问。<br>　　日本记者：陈独秀学长，请问北京大学和《新青年》到底是什么关系？<br>　　陈独秀：额《新青年》，确实，是由北京大学一些教授实行同人编辑的，但是，《新青年》是一份经营独立的杂志，它与北京大学没有隶属关系。新青年的一切行为均由他的编辑部负责，与其他任何单位无涉。<br>　　某国记者：请问陈独秀先生，最近我看到许多不利于《新青年》杂志的文章和报道，我想知道你怎么看待这些非难？以及《新青年》这三年究竟做了些什么？<br>　　陈独秀：这三年来，本志被某些人称之为破坏性杂志，说我们破坏孔教、破坏礼法、破坏国粹、破坏贞节、破坏旧伦理、破坏旧艺术、破坏旧宗教、破坏旧文学、破坏旧政治，对于这些，我们本志同人当然直认不讳。我们为什么要破坏这些东西？只因为我们拥护德莫克拉西和赛因斯两位先生，你要拥护德先生和赛先生，你就不得不反对旧的思想、旧的文学。要说本志这三年到底做了些什么，无非就是这些。<br>　　某国记者：在我看来，在当下的中国推行民主和科学，是很困难甚至是很危险的事情，陈先生，你会坚持吗？<br>　　陈独秀：OK！西洋人因为拥护德赛两位先生，闹了多少事儿，流了多少血，德先生和赛先生才渐渐地把他们从黑暗中救出，引到光明世界，我们现在认定，只有德赛两位先生可以救治中国在政治上、道德上、学术上、思想上的一切黑暗。若因为拥护两位先生，一切反动政府的迫害，社会的攻击和谩骂，我们都不推辞。<br>　　日本记者：我想请问李大钊先生一个问题，最近我读了不了您写的文章，感到您对马克思主义很感兴趣，对俄国十月革命多有赞美之词，我想请教李先生，您是马克思主义的信徒吗？<br>　　李大钊：作为一个追求真理的读书者，我丝毫不会隐瞒自己的观点。虽然我对马克思主义的认识还很肤浅，但是我认为，马克思主义是世界上最科学的理论，俄国十月革命依据马克思主义创建的社会制度，也是迄今为止，人类社会制度的最高制度，对此，我心驰神往。<br>　　某国记者：陈先生，我知道您在倡导新文化运动，我很想知道，你希望新文化运动对中国社会的发展，会产生什么样的影响？<br>　　陈独秀：大概听懂了！新文化运动对中国的影响力，当然绝不仅仅局限于文化方面。新文化运动，影响到产业上，应该令劳动者，觉悟他们自己的地位；<strong>令让资本家，把劳动者当成他们同类人看待，而不要当成机器、牛马、奴隶来看待；新文化运动影响到政治上，是要创造新的政治思想，不要被现实的政治羁绊。</strong>什么是现实的政治？譬如当下的现实政治，那就是一班没有饭吃的无聊看客，在那造谣生事，与人民的生活和政治理想，都毫无关系，不过是各派的政客拥有了各派的军队在争权夺利，如同狗争骨头一般而已。他们的争夺，是狗的运动；新文化运动，是人的运动。我们只应该拿人的运动，去轰散狗的运动；而不应该抛弃我们人的运动，来加入他们狗的运动。<br>　　旁白：1919年，战胜国在巴黎召开和会，在这次由英法美意四巨头掌控的和会上，世界秩序被重新划定，而原本德国在战前取得中国山东胶州湾的权益，也成为中日争执的焦点。日本代表团提出，日本应当继承德国权益，中国代表顾维钧据理力争，逐条批驳日本的要求，他指出，无论从山东的历史、地理、文化方面，还是从中国对于德国处于战胜国的地位而言，胶州租借地、胶州铁路及其他一切权利，应直接交还中国，但北洋政府亲日派曹汝霖等在日本压力下却说此举纯属擅自行动。顾维钧的发言引起了日本政府极大不满，遂命驻华公债小幡酉吉向北洋政府施压。　　</p><p>68、同学们，在巴黎召开的和会，是我们中国第一次以战胜国的身份参加的国际大会。那么既然是国际大会，各国在会上维护自己国家的利益，提出自己正确的主张，乃是各国独立应存之大义，他国，绝无干涉的道理。可是，就是因为我们的顾维钧顾专使代表了我们全体中国，在巴黎和会上申诉，要收回我们自己山东的权益，日本人竟然要求要撤换他。同学们，你们说，我们四万万中国同胞，能够答应吗？（学生们答：不能！）在这个提倡世界公平的大会上，我们提出了自己国家的正确主张，日本人竟然冲进了我们的外交部，进行恫吓，威逼我们屈服。同学们，你们说，我们四万万中国同胞能被吓倒吗？—（学生们答：不能！）日本号称有陆军百万，随时准备应战，以威逼我们放弃山东的权益，同学们，你们说，我们能够因此而屈服，因此而惧怕吗？（学生们答：不能！不能！不能！）</p><p>——李大钊在北大学生集会上发表誓死抵制日本保卫山东的演说　　</p><p>69、北大课堂上，胡适教授哲学课<br>　　胡适：墨家学说在先秦与儒家并称显学，墨家学说以兼爱为核心，以节用、尚贤为支点，共有十大主张，请看：兼爱、非攻、尚贤、尚同、尊天、事鬼、非乐、非命、节用、节葬。兼爱，是墨家学说的核心，所谓兼爱，它包含了平等和博爱的意思。墨家要求君臣、父子、兄弟之间，都要在平等的基础上相互友爱，爱人若爱其身，并且认为，在社会上如果出现了强执弱、富侮贫、贵傲贱的现象，是因为天下人不相爱所致。<br>　　郭心刚：先生，学生有一事不明，东洋人西洋人都霸着我山东不还，这是典型的强执弱行为，难道这也是先生所讲的，天下人不爱所为吗？<br>　　胡适：同学们，郭心刚同学今天在课堂上提出了问题，这是好事。证明郭心刚同学已经开始思考了，但是郭同学，你今天的问题跑题了。今天我们讲的是中国古代哲学，是学界讨论的问题，你刚才说的是政治问题，是政界讨论的问题。作为学生关心山东问题，这是好事，但是山东究竟能不能返回中国，这是巴黎和会政治家们讨论和研究决定的问题，而不是今天我们在课堂上能够决定的问题。<br>　　郭心刚：可学生认为，<strong>学术和政治是不可能完全分离的，所谓，覆巢之下，焉有完卵，如果一个国家连主权都保护不了，还有什么学术可言？</strong><br>　　胡适：郭心刚同学，今天你在课堂上喋喋不休的讨论山东问题，你觉得有用吗？山东问题的决定权在威尔逊，而不在你一个学生。学生的任务就是学习，学习最好的状态就是心静如水，而不是心怀小鹿。<br>　　郭心刚：先生 ，<strong>中国的大学生并不多，如果连我们都不关心山东的问题，他威尔逊一个外国人凭什么要关心我们的山东。把山东的主权问题拴在一个外国人嘴上，学生认为是靠不住的。学生对不起，我做不到心静如水。</strong></p><h2 id="毛泽东回湖南老家-互助社解散"><a href="#毛泽东回湖南老家-互助社解散" class="headerlink" title="毛泽东回湖南老家 互助社解散"></a>毛泽东回湖南老家 互助社解散</h2><p>70、毛泽东北大与陈延年、陈乔年辞行<br>　　毛泽东：欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复沉舟梦日边。行路难，行路难，多歧路，今安在！延年，乔年，我觉得，路虽漫漫，但是北京自有一股王气在，仲甫先生、守常先生，他们的主张，就是振聋发聩，荡涤乾坤的王气。而且呢，他们又是我们新青年的精神领袖和导师，而我们当代的新青年，就是要把这种王气和地气给接起来，在现实中，上下求索，为天下找到一条新的出路。<br>　　陈延年：江山代有才人出，各领风骚数百年。润之兄，为了救国救民，我愿与你同行，一起努力，一起加油！<br>　　毛泽东：长风破浪，会有时，直挂云帆，济沧海。共勉！　　</p><p>71、互助社失败，陈独秀和两个儿子谈心<br>　　陈独秀：延年，互助社试验失败了，我想问你，你还那么坚信，无政府主义的理论吗？<br>　　陈延年：如果我说坚信，您会生气吗？<br>　　陈独秀：不会。<br>　　陈延年：真话？<br>　　陈独秀：真话！<br>　　陈延年：为什么？<br>　　陈独秀：因为我看见了你的反思，<strong>有反思就不会盲目</strong>。我相信，你一定会找到一条正确的路。我愿意给你时间，我也愿意跟你们一起去寻找。<br>　　陈延年：谢谢！<br>　　陈乔年：爸，我还以为您又要逼着我们学习俄国十月革命呢！<br>　　陈独秀：不是逼着你们，只是建议！<br>　　陈延年：您放心，虽然我们坚守互助论，但是我们一定会多方面的涉猎学习。<br>　　陈独秀：好！在北京这段时间，我亲眼看见了你们的成长，说实话，作为一个父亲，我很欣慰。<br>　　陈延年：我们对您也有新的认识，您的思想也让我跟乔年受益匪浅，但就有一点……<br>　　陈独秀：什么？<br>　　陈乔年：没什么……<br>　　陈延年：我们希望，您把您那种大家长的作风和习惯改一改，特别是在您对待您自己同人的时候，那样对他们伤害太大。</p><h2 id="巴黎会议英美法欺压中国代表团-陆征祥见三国总统碰壁"><a href="#巴黎会议英美法欺压中国代表团-陆征祥见三国总统碰壁" class="headerlink" title="巴黎会议英美法欺压中国代表团 陆征祥见三国总统碰壁"></a>巴黎会议英美法欺压中国代表团 陆征祥见三国总统碰壁</h2><p>72、苟利国家生死以，岂因祸福避趋之。</p><p>——顾维钧在巴黎和会期间决定捍卫主权</p><h2 id="北京各所学校师生游行抗议-郭心刚一夜白头"><a href="#北京各所学校师生游行抗议-郭心刚一夜白头" class="headerlink" title="北京各所学校师生游行抗议 郭心刚一夜白头"></a>北京各所学校师生游行抗议 郭心刚一夜白头</h2><p>73、事情已经出了，在这个时间，难过、悲观都没有什么用处，帝国主义的政府是靠不住的，中国的封建政府也靠不住，什么靠得住呢？我们自己！这个时候，我们只能，而且应该站出来，用我们自己的力量，拯救我们自己的国家。——李大钊劝一夜白头的郭心刚　　</p><p>74、我记得仲甫先生，曾经说过一句话，他说，要二十年不谈政治，他要专心地去搞思想启蒙，当然现在他也认识到，当初说这句话有失偏颇了。因为科学和民主本身就离不开政治，民主本身就是政治，我们要谈科学和民主，政治就会来找上你，躲都躲不掉。</p><p>大家想一想，我们北京大学这三年来所有事，哪一件事离得了政治？我想问问大伙，民主是什么？</p><p>（郭心刚：民主，民主就是人民当家做主。）</p><p>心刚说得对，中国是人民的国家，所以“家”，就应该人民来当，“主”，就应该人来来做，这是国家应有之义。可是民国已经八年了，我想问问大家，有哪一件事是我们人民当家做主的？——没有！对吧？段祺瑞去年和日本人签订密约，他问过人民的意见了吗？——没有，甚至连中国的专使都不知道有这么一个密约存在。挂羊头卖狗肉，欺世盗名，愚弄民众。以我说，这趟巴黎和会，不光是个坏事，也是一件好事，为什么这么说？因为这个巴黎和会惊醒了我们全体中国人。中国要想发展，中国要想发展，不能光反封建主义，倡导新文化，还要反对帝国主义，捍卫我们自己的主权。要做到这两点，就必须要唤醒民众，民众觉醒了，中国才有希望。所以，同学们，我们的平民教育讲演团，要尽快深入到基层去，深入到工厂去，深入到田间地头去，我们的各个社团要深入到社会的各个角落，去唤醒民众。大家觉得怎么样？　　</p><p>75、得知北洋政府电令巴黎专使同意在巴黎和会上签字的汪大燮，求助于蔡元培<br>　　蔡元培：我乃一介书生，我能做什么？<br>　　汪大燮：<strong>你能！你蔡孑民有北大，北大后面有个中国，四万万中国人只要一条心，中国就不会亡。</strong><br>　　蔡元培：感谢伯棠兄的指点，元培，自有定夺。　　</p><p>76、蔡元培召集新青年编辑商量对策<br>　　蔡元培：我们都清楚，爱国是我们北大的宗旨，在国家民族出现大难的时候，我们绝不可能袖手旁观。刚才我跟汪大燮说，国难当头，我蔡元培不下地狱，谁下地狱？<br>　　李大钊：蔡先生，我跟您一起下地狱。<br>　　刘半农：<strong>天下兴亡，匹夫有责</strong>，国家有难，我跟着您一同下地狱去！<br>　　陈独秀：下地狱无济于事！这个问题我想了很久，是守常的一篇文章启发了我，他说，俄国的十月革命是庶民的胜利，俄国的庶民用的是暴力，那我们中国的庶民，用民主行不行？我看可以试一试，我们的国家是人民的国家，人民的国家，得人民说了算。现在北洋政府违背民意，出卖了我们国家的主权，怎么办？我说别无他法，只有让人民站起来，直接解决吧？<br>　　蔡元培：怎么个站起来直接解决？<br>　　陈独秀：变坐而议，为起而行，我们北大要做先锋，唤醒广大民众做天下的主人。<br>　　李大钊：咱们也来他一个庶民的胜利。蔡先生，邓中夏他们正在组织北京学联，我催促他们赶快行动起来，而且这次行动不应该只有学生，工人、商人、军人、各个阶层都要行动起来，全社会的各个阶层都行动起来，这才是庶民的行动，才能迫使反动政府让步！<br>　　鲁迅：我同意仲甫和守常的意见，如果我们北大先带个头，把全国的民众都调动起来，那必将是一个全新的历史的开端！<br>　　蔡元培：对，你们在青年人中间是很有影响力和号召力的，刚才仲甫说，让人民直接站起来行动，这句话我认为应该成为口号，把这个口号喊 出去，把人民调动起来。你们二位，曾经说要直接议论政治，当初我还有疑问和保留，现在看来，你们深谋远虑，但是仓促行动，容易顾此失彼啊。　　</p><p>77、请老师和同学们坐下。今天把各位老师和学生代表紧集地召集起来，实在是有迫不得已的事情啊。巴黎和会现在已经通过了一项不平等的条约，条约的内容是把战前战败国德国在中国的所有权益，全部移交给日本。大家都知道，中国是作为战胜国的身份参加这个巴黎和会，在这个和会上，作为战败国德国，他理应把霸占中国山东的土地和权益全部、无条件地归还给中国。然而，在这个和会上，他们无视我中国，堂而皇之地通过了这么一个不平等的巴黎和约。我们现在的政府，已经致电在巴黎的中国代表团，要求他们在这个耻辱的条约上签字，大家知道，只要这个字一签，那么山东，就变成日本的了。同学们，但凡是个中国人，我们能答应吗？（同学们：——不能！）三年前，我来到北大，我心存着一个梦想要把北大办成一个优秀的教育学堂，优秀的教育学堂的背后，就准确无误地写上两个字：爱——国。按我的想法，<strong>爱国今后就是我们北京大学的灵魂和传统，我北大的学子不是要自己做官，而是要为国家出力，要做国家的栋梁之材。</strong>如今，国家已经到了存亡绝续的危急时刻，我们每一个北大学子都应该挺身而出，为挽救国家的危亡，做先锋。我们要唤醒民众，敦促政府，拒签这个不平等的巴黎和约，捍卫我们的主权。我的同学们、老师们，我问你们，你们有没有这个勇气，和力量？（同学们老师们：——有！捍卫主权，拒签和约！）——蔡元掊在北大礼堂做拒签条约的演讲　　</p><p>78、旁白：一九一九年的五月四日，北京大学、北京高等师范学校等十三所大中专学校的三千多名学生到天安门集会，他们打出“外争主权、内惩国贼、废除二十一条”等口号，强烈要求拒签巴黎和约，惩办北洋政府的三个亲日派官员，曹汝霖、章宗祥和陆宗舆。游行队伍在东交民巷使馆区抗议受阻后，转奔位于赵家楼胡同的曹汝霖住宅，痛打卖国官僚章宗祥，火烧曹宅。北洋政府逮捕了许德珩等三十二名学生。五月五日，北京各大中专学校宣布实行罢课，并通电各方面请求支援。北京学生的爱国运动，迅速蔓延到全国各地。五四运动是一场以先进青年知识分子为先锋，广大人民群众参加的，彻底反帝、反封建的伟大爱国革命运动；是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动；是一场传播新思想、新文化、新知识的伟大思想启蒙运动和新文化运动，以磅礴之力鼓动了中国人民和中华民族实现民族复兴的志向和信心。五四运动，以彻底反帝、反封建的革命性，追求救国、强国真理的进步性，各族、各界群众积极参与的广泛性，推动了中国社会的进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上、干部上的准备，为新的革命力量、革命文化、革命斗争登上历史舞台创造了条件，是中国旧民主主义革命走向新民主主义革命的转折点。在近代以来，中华民族追求民族独立和发展进步的历史进程中具有里程碑意义。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——06</title>
      <link href="/202108/46901/"/>
      <url>/202108/46901/</url>
      
        <content type="html"><![CDATA[<h2 id="德国战败-毛泽东听课发表观点获邵飘萍赏识"><a href="#德国战败-毛泽东听课发表观点获邵飘萍赏识" class="headerlink" title="德国战败   毛泽东听课发表观点获邵飘萍赏识"></a>德国战败   毛泽东听课发表观点获邵飘萍赏识</h2><p>56、北大新闻研究会邀请《京报》社长 邵飘萍做《新闻工作理论与实践》的演讲<br>　　邵飘萍：各位同学，蔡蒋长建立的这个研究会，叫新闻研究会，那什么叫新闻学？这个研究会，研究的具体内容是什么？我想，这是在座的每一位会员，必须了然于胸的基本常识。我认为，主要分为以下几点：新闻的根本知识、新闻的选题、新闻之采集、新闻之编辑、新闻之通讯法、等等等等。总而言之，是非常完整的新闻学体系。我知道，在座的诸位，有志于成为一名记者，那我要请教了，当今社会，要成为一名合格的记者需要哪些基本素质？请畅所欲言，我洗耳恭听啊！<br>　　毛泽东：先生好！我不赞同这位同学的观点，至少他的观点不够全面。我认为，当今时代，要做好一名新闻记者，知识、博学固然重要，但并不是唯一的，甚至并不是最重要的基本要素。而且呀，这知识，不一定完全来自于学校的教育，社会也是一个大学嘛。</p><blockquote><p>所以我认为，要做一名出色的记者，比知识更重要的就是人的思想、立场还有职业操守。<br>我觉得，作为一名新闻记者，不能人云亦云，要对自己获取的信息，分析、论证、去伪存真、由表及里，做出自己的判断与结论。<br>当然，这里面立场是到关重要的，我们只有站在大众的立场上，站在历史潮流的前面，维护大多数人的利益和要求，我们的文章才有助于这个社会的进步。<br>当然啦，要想做一名记者，首先要严格地遵守职业操守，遵循新闻的客观性、真实性，努力地坚持真理，坚持实事求是，自觉地拒绝利益的诱惑和污染。我们现在身处乱世，操守、品行才至关重要。</p></blockquote><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-3b870cacf67ddb6db20f9744d8f17f4e_720w.jpg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-3b870cacf67ddb6db20f9744d8f17f4e_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>　　旁白：多年后，毛泽东对美国记者埃德加.斯诺说，邵飘萍对我帮助很大，他是新闻学会的讲师，一个自由主义者，一个具有热情、理想和优良品质的人。<br>　　一九一八年，第一次世界大战以协约国战胜同盟国而宣告结束，中国成为战胜国。消息传来，举国若狂，沉浸在公理战胜强权喜悦中的人们，将象征耻辱的克林德碑改名为公理战胜碑。李大钊在此期间发表了《布尔什维主义的胜利》、《新纪元》等文章，并在中央公园发表题为《庶民的胜利》的演说，指出取得这次战争胜利的不是协约国的武力，而是人类世界的新精神，是全世界的庶民。《庶民的胜利》等文章是李大钊宣传马克思主义和俄国十月革命的重要文献，表明他已经形成了马克思主义的立场和观点，促进了马克思主义在中国的传播。　　</p><p>57、北大教授中央公园演讲<br>　　陈独秀：同胞们，自从德国打了败仗，公理战胜强权这句话几乎成了人人的口头禅。那诸位，晓得什么是公理，什么是强权吗？简单地说，<strong>凡合乎平等、自由的就是公理；依仗自身强力，侵害他人平等自由的，就是强权。</strong>德国，倚仗它的学问好、兵力强，专门侵害各国的平等自由。如今，他打得大败，这就是公理战胜强权。这公理战胜强权的结果，世界各国的人都应该明白，无论对内、对外，强权是靠不住的，公理是万万不能不讲的了。<br>　　蔡元培：同胞们！同学们！灾难深重的世界大战结束了，协约国获得了胜利，这个胜利来之不易啊。我们要乘着这个东风，把世界上不平等的黑暗主义消灭掉，用光明主义，取代它！我希望，国内持强权论的、崇拜武断主义的、好弄阴谋、执着偏见，都要赶快放弃这种黑暗主义，为中国的光明，做出努力。<br>　　李大钊：同胞们，最近几天我们在庆祝战胜，很是热闹啊。但是我想问一个问题，我们战胜的，究竟是哪一个？我们庆祝的，究竟又是为了哪一个而庆祝呢？我老老实实地讲一句公道话：<strong>这次战胜的，绝不是联合国家的武力，而是全世界人类的新精神；这次战胜的，也不是哪一个国家、军阀或者资本家的政治，而是世界的庶民！我们庆祝的，也不是为了哪一个国家，或者哪一个国家的一部分人而庆祝，是为了全世界的庶民而庆祝；我们不是为了战胜德国而庆祝，而是为了打败了世界的军国主义，而庆祝！</strong>同胞们，同学们，今天在你们当中，来了很多长辛店的劳工兄弟们。我要跟大家讲一句话，须知今后的世界，要变成劳工的世界。我们应当用此潮流，使一切人人，都变成工人的机会；不应该用此潮流，使一切人人，都变成强盗的机会。凡是不做工、吃干饭的，都是强盗，强盗和强盗谋取不正的财产，那也是强盗，没有什么分别。所以，我要说，劳工，万岁！</p><h2 id="陈延年成立互助社-李大钊陈独秀培养工人群体"><a href="#陈延年成立互助社-李大钊陈独秀培养工人群体" class="headerlink" title="陈延年成立互助社   李大钊陈独秀培养工人群体"></a>陈延年成立互助社   李大钊陈独秀培养工人群体</h2><p>58、北大长廊 李大钊参与读书会讨论 关于陈延年成立互助社的倡议<br>　　延年，你刚才问我，觉得你那个倡议怎么样，我想给你，还有世炎鼓鼓掌。同学们，我为什么要给这二位同学鼓掌？因为这二位同学，都不约而同地看到了一个问题，那就是理论，和实际要结合起来。这个就像我们在庆祝欧战胜利大会上讲的那样，新文化运动，现在已经到了一个转折点，那这个转折点就是新文化运动，要走向大众。<br>　　仲澥，你给蔡先生的信儿有回音了，蔡先生全力支持，而且督促我们大家，要尽快走出去。<br>　　刚才听了诸位同学的发言，我是既兴奋，又钦佩，兴奋地是我看到了大家的真知灼见，钦佩的是我看到了大家的开拓精神。你们选择要走出去，那就意味着要放弃很多，意味着你们选择了一条困难之路，而放弃了一条舒适之路；意味着你们选择了一条开拓之路，而放弃了一条守成之路；意味着你们选择了一条迎着困难而上的拼搏之路，而放弃了坐而论道的安逸之路。<br>　　<strong>同学们，我们马上要走出书斋，走向基层了，我知道这条路很难、很苦，但是我坚信，再难再苦的路，也难不倒诸位，因为我看到了大家的勇气。</strong><br>　　<strong>同学们，我真心希望大家能够双脚踩在泥土里，一步一步地、踏踏实实地，走好每一步路。而且我相信胜利一定会属于我们。因为，我们已经在路上了。</strong>　　</p><p>59、陈延年与部分读书会会员商议工读互助社简章<br>　　陈延年：工读互助社简单一共是三条，我给大家念一下啊：第一、社员每日、每人必须工作四个小时；第二、社员必须之衣、食、住由团体供给，社员所需之教育费、书籍费由团体供给，惟书籍归团体公有；第三、工作所得归团体公有。各位还有什么需要补充的吗？<br>　　郭心刚：我认为啊，我们应该在简章中旗帜鲜明地宣布，工读互助社是根据互助论理论实行的，没有任何约束的共产主义理论。<br>　　陈延年：嗯，老郭这条提得好，我同意啊！<br>　　刘海威：稍微等一下啊，既然互助社实行共产主义，那么我认为，所有的社员都应当明确地脱离家庭关系和婚姻关系。<br>　　白兰：那你认为社员之间是什么关系？难道什么都可以互通有无吗？<br>　　刘海威：不，白兰你误会了。我是说，社员之间应该是同志的关系，是思想上和财产上完全通融的关系，这种同志关系呢不应该受家庭、学校和婚姻的羁绊。<br>　　柳眉：你这话什么意思啊？难道要跟家里脱离关系吗？这——太不通情达理了，有这个必要吗？<br>　　陈延年：有这个必要。<strong>不劳动者不得食</strong>，这是共产主义一个最基本的原则，我们就是要靠自己的双手养活自己，创造世界，而不是要依靠父母和家庭。<br>　　柳眉：你要跟父母断绝关系吗？<br>　　陈延年：不是要跟父母断绝关系，而是要跟家庭断绝经济关系。入社以后，不要让家里再给你寄钱了。能做到吗？<br>　　柳眉：我能做到，我这两天就给家里写封信吧。<br>　　陈乔年：哥，那咱们是不是也不能回家吃饭了？<br>　　陈延年：哦，这个问题我说一下，我们大家不仅不能回家吃饭，也不能在学校吃饭。我们要办自己的食堂，吃大锅饭，穿大家衣。　　</p><p>60、陈延年兄弟回家声明脱离关系，陈独秀好言相劝，延年油盐不进，反唇相讥。<br>　　陈独秀：怎么回来这么晚啊？<br>　　陈延年：哟！您在家啊！难得啊！<br>　　陈独秀：我不在家，我去哪啊？<br>　　陈乔年：我们这次来也是跟你们脱离关系的。爸，姨妈，我跟你们读一下我们的声明：陈延年、陈乔年自愿组织并加入工读互助社，践行互助论，实行共产主义。从即日起，与家庭脱离一切经济关系，以及所连带的责任和义务。特此声明！<br>　　高君曼：搞了半天，你们就为了搞这个互助社，就要跟父亲、姨妈、还有弟弟妹妹们断了关系啊？这哪是什么互助社嘛？这叫六亲不认社好吗？<br>　　陈延年：姨妈，您误会了！我们不是要脱离血亲关系，我们是要撇清经济连带关系。从今天开始，我和乔年就不能花家里的钱了，也不能回家吃饭，我们要自己养活自己。<br>　　陈乔年：因为我们共产了！<br>　　高君曼：共产？这不是小孩子过家家吗？仲甫，是不是你撺掇他们弄的呀？<br>　　陈独秀：带小孩子去睡觉！延年，乔年，你们过来，我们聊聊。我之所以要跟你们郑重地谈一下，是因为你们现在要做的事儿不是小事儿，你们不是一时心血来潮，你们在做一种实验，但是，你们要做好失败的心理准备。<br>　　陈延年：我可没这准备，我们不会失败的。<br>　　陈独秀：自信是优点，但不能盲目自信。<br>　　陈延年：我没盲目啊。我在用最先进的理论做指导。<br>　　陈独秀：现在欧洲流行很多种理论，你凭什么说无政府主义就是先进的理论。<br>　　陈延年：这我就闹不明白了，你不是也说过无政府主义是好主义吗？<br>　　陈独秀：我认为无政府主义有好的东西，但主张多实验，要在实验中检验它。我是想提醒你，这种实验，可能你会付出巨大的代价，因为他未必符合我们的国情。<br>　　陈延年：我对无政府主义跟踪研究好几年了，我相信我自己的判断力，无政府主义的互助论，是能够救中国的先进的科学理论。<br>　　陈独秀：什么理论最先进，什么理论最适合中国，这要比较和实验，不能妄下结论。我支持你，因为你在做。可是有一些人，是空谈主义，不要盲目听信。<br>　　陈延年：你指谁呀？<br>　　陈独秀：比如——吴稚晖。<br>　　陈延年：你说我就说我，你凭白扯上别人干什么呀？<br>　　陈独秀：我为什么不能说他？我今天就要说他，他整天唱高调，把自己打扮成良德的圣人，欺骗年轻人做他的信徒，一旦你不信他了，这种人说翻脸就翻脸。你不能跟他接触得太近，你要留点心眼才行。<br>　　陈延年：您也没少翻脸呀，我是不是也该对您留个心眼呀。哦，对，您也不算翻脸，因为您直接就戴了个假脸。您嘴上说支持，心里却不认同，口是心非为假；因为你个人的言行给家里带来这么大的麻烦，却若无其事也是假。像你这样的人你有什么资格站在道德的高度上说别人？<br>　　陈独秀：我在用我的人生经验与你共勉，你为什么要这么抗拒呢？我在跟你说正经事儿，你为什么要说这些混蛋话？<br>　　陈延年：我也在说正经事儿，可我没干混蛋事。</p><h2 id="互助社早点摊成立-张丰载关注早点摊动向"><a href="#互助社早点摊成立-张丰载关注早点摊动向" class="headerlink" title="互助社早点摊成立 张丰载关注早点摊动向"></a>互助社早点摊成立 张丰载关注早点摊动向</h2><p>61、光阴似流水，不一会课毕放学归。我们仔细想一会，今天功课明白未，老师讲的话可曾有违背。父母望儿归，我们一路莫徘徊，将来治国平天下，全靠吾辈。大家努力呀，同学们，明天再会。</p><p>——互助社俭洁食堂成立，成员们欢快地唱起了《夕歌》　　</p><p>62、宁流额上汗，毋染手中血。</p><p>——俭洁食堂门口对联（鲁迅题）</p><h2 id="张丰载写新闻抹黑互助社-陈独秀一行人决定反击林琴南"><a href="#张丰载写新闻抹黑互助社-陈独秀一行人决定反击林琴南" class="headerlink" title="张丰载写新闻抹黑互助社 陈独秀一行人决定反击林琴南"></a>张丰载写新闻抹黑互助社 陈独秀一行人决定反击林琴南</h2><p>63、鸦片流毒实非浅，到我中华已百年。英雄埋没知多少，耗费金钱真可怜。烟禁虽严如儿戏，如今公卖将出现。贻笑外人尚小事，害我同胞何堪言。——易群先等工读互助社成员在冰心的帮助下卖票宣传　　</p><p>64、《新青年》杂志社 蔡元培和众编辑商量对付林琴南等守旧派势力的舆论攻击<br>　　鲁迅：南北夹击，万箭齐发，来势汹汹，是可忍，孰不可忍！<br>　　陈独秀：哼！我看到了股杀气！<br>　　鲁迅：冰冻三尺，非一日之寒。我觉着新旧文化到了决战的时刻了。孰是孰非，该做个了断。<br>　　钱玄同：反击！忍无可忍，无须再忍！<br>　　蔡元培：大家都知道我蔡元培这个人，一向认为凡事要循序渐进，不要激烈，我也一直认为新旧文化之争，那是学术之争，应该百家争鸣。旧派也好，新派也好，大家都是在做学问，都是在思考这个国家发展的出路，不应该剑拔弩张，不应该走到你死我活的地步。于是，我给林琴南先生写了封信，请他，给明代刘应秋的作品题词，这个中的含义就是说，私底下我们还是朋友嘛。<br>　　钱玄同：蔡公，您就是太厚道、太宽容了！<br>　　陈独秀：德潜，你坐下。宽容和厚道是蔡公一向的风格。<br>　　蔡元培：非也！非也！<strong>宽容和厚道是我们读书人从小的习养。</strong>但是，宽容和厚道它不是没有限度的呀！鲁迅先生说得对：决战的时刻到了！<br>　　鲁迅：我的新小说《孔乙己》马上就完稿了，先生，我会再写一部小说，我就要跟这个林琴南较个高低！<br>　　陈独秀：好！既然大家都同意反击，虽千万人，吾往矣。我陈独秀是去是留无所谓，但我绝不能容忍他们把把我们一手培育的新文化运动扼杀在摇篮里。明天开始，我们四个杂志一起上阵，我负责《新青年》，守常负责《每周评论》和《国民》，适之你负责《新潮》，大家都要写文章，各显神通。不光是我们的杂志，还要发动学生，广泛地给各大报纸、刊物投稿，来他个铺天盖地。适之、守常，你们在学生中有号召力，把你们的门生发动起来，让讲演团到街上去。人家都打到门上来了，我们还能做缩头乌龟吗？<br>　　李大钊：新文化运动，万岁！<br>　　蔡元培、陈独秀、胡适、李大钊、鲁迅、钱玄同、刘半农、高一涵：新文化运动，万岁！</p><h2 id="易群先躲避警察搜查-柳眉假装脱离互助社获得张丰载信任"><a href="#易群先躲避警察搜查-柳眉假装脱离互助社获得张丰载信任" class="headerlink" title="易群先躲避警察搜查 柳眉假装脱离互助社获得张丰载信任"></a>易群先躲避警察搜查 柳眉假装脱离互助社获得张丰载信任</h2><p>65、北大校长室 蔡元培、陈独秀、李大钊、刘半农、鲁迅就蔡元培被匿名信举报一事准备反击<br>　　蔡元培：树欲静而风不止啊！我已经是退避三舍、一忍再忍，然斯人却步步紧逼，不依不饶。黑云压城城欲摧，甲光向日金鳞开。那就让我这个所谓的蔡大龟，只好披坚执锐、上阵厮杀吧！<br>　　陈独秀：好！蔡公，虽然我是个臭不可闻的臭大粪，但岂能，摧眉折腰，我必当，和您一起，笔扫千军，一鼓而荡之！<br>　　李大钊：俄国作家高尔基在《海燕》上有这么一句话：让暴风雨来得更猛烈些吧！　　</p><p>66、鲁迅、李大钊、毛泽东反击林纾《妖梦》、捍卫新文化运动发表演讲<br>　　鲁迅：近来，自称是清室举人的林纾大发议论，号称是要维护中华民国的名教纲常。当然，这本可由他自语，与我无涉。但是，看他那个气闹哄哄的样子吧，我又觉得很可怜，我就忍不住想劝他几句，想跟你们商量商量我怎么劝？您老既然不是敝国的人，那就少管敝国的事吧，少操闲心、少淘闲气。近来，公理战胜，您老可好？一个清室之人，跑来民国，让一个叫郑思康的人，梦游到阴曹地府，看见一群魑魅魍魉在白话学堂里，高挂毙孔堂，高唱白话诗，高谈废除古文。结果，把阴曹地府的阿修罗惹怒了以后，把他们通通吃掉，化成了臭不可闻的粪便。所以我就觉着啊，任何人，你都不能去试图阻挡历史前进的车轮，你非要挡呢？那结果只有一个，什么呢？被碾着腿嘛！（北大礼堂）<br>　　李大钊：我正告那些顽固、鬼祟、抱着腐败思想的人们，你们应该守望着你们那些道理，光明磊落地站出来，和我们这些新派的思想辩论、讨论。如果你们想隐藏在别人的身后，抱着你们那位伟丈夫的大腿，用残暴的势力欺压反对你们的人，为你们出出气，或者写一篇鬼话连篇的小说，快快口，造一段谣言宽宽心，那么这是极其无聊之举动。须知当今之中国，如果有真正觉醒之青年，那是断不怕你们的伟丈夫的摧残的，你们这些伟丈夫，也断不能摧残这些青年们的精神。当日暴虐之俄国，不知道用了多少残暴的心性，杀戮了多少有志的青年，哪知道，这些青年的鲜血，反倒成为了培养革命自由之花的土壤；那些暗沉的监狱，也反倒成为了有志青年的奔波劳碌之后的休息场所。暴虐政府的欺压，反倒为了我们这次革命，提供了一些些许的趣味，像今日这样滔滔滚滚的长流，一发而不可遏呀！新文化运动万岁！万岁！万岁！（北京街头）<br>　　毛泽东：同胞们，我们倡导新文化，就是要谋求各个方面的解放，思想的解放、政治的解放、政治的解放、男女的解放、还有教育的解放，都要从九重冤狱，求见青天。<strong>我们中华民族，原有最伟大的能力，就是压迫越深，反抗就越大，蓄之既久，其发必速。</strong>我敢说一句话，他日，中华民族的改革，将会比任何民族都彻底；中华民族的社会，将比任何的民族都光明。同胞们，我们要努力，拼命地向前，我们黄金的世界，我们光华灿烂的世界，就在眼前！新文化运动万岁！新文化运动万岁！新文化运动万岁！（北京街头）</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821145038.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821145038.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——05</title>
      <link href="/202108/5938/"/>
      <url>/202108/5938/</url>
      
        <content type="html"><![CDATA[<h2 id="周树人创作《狂人日记》获追捧-毛泽东成立新民会"><a href="#周树人创作《狂人日记》获追捧-毛泽东成立新民会" class="headerlink" title="周树人创作《狂人日记》获追捧 毛泽东成立新民会"></a>周树人创作《狂人日记》获追捧 毛泽东成立新民会</h2><p>47、我们的读书会不应该仅仅停留在理论层面上，传播真理、开发民智，进而改变整个社会，这个才是我们的最高目的。而且这个需要我们几代人全心全意地付出，可能要延续上百年，才能完成的事业，在这个事业面前，我觉得一切形式都没那么重要。因为什么？因为只有通过我们自己不懈地努力，才能够搭建通往胜利的道路。所以，我认为，我们的读书会，应该是朴素的、平实的。我不知道，我的这个想法，大家同意吗？我是真心希望大家能够把心静下来，踏踏实实地走好每一步路，不光要把我们的读书会常态化，还要把我们的读书会推广至大众化，不知道大家有没有这个信心。</p><p>——看到两个同学为读书会做了个条幅，李大钊用一番苦口婆心的话教育了两个注重形式主义的学生　　</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144120.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144120.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>48、《狂人日记》横空出世后，北大新青年杂志编辑部群雄激昂<br>　　旁白：1918年4月，鲁迅完成了白话文日记体小说《狂人日记》，这也是中国第一部现代白话文小说，它是新文化运动投向封建礼教的一颗重磅炸弹，极大地拓展了文学革命的影响，在中国现代文学史和中国现代文化史上具有跨时代的意义。<br>　　李大钊：吃人的是我哥哥，我是吃人的人的兄弟，我自己被人吃了，可仍然是吃人的人的兄弟。<br>　　胡适：妹子是被大哥吃了，母亲知道没有？我可不得而知，我未必无意之中不吃了我妹子的几片肉，现在也轮到我自己，有了四千年吃人履历的人，当初虽然不知道，现在明折，难见真的人。字字戳心！<br>　　蔡元培：读了豫才这部小说呀，我就感觉到有人用拳头朝我这胸口上猛地一击，尤其是最后这一段，他说没吃过人的孩子或许还有，他在问谁？他紧接着又说：“救救孩子!”忧愤而深广啊！<br>　　钱玄同：蔡先生，就这段，深刻！过瘾哪！<br>　　陈独秀：来来，我告诉你们我喜欢哪一段。我翻开历史一查，这历史没有年代，歪歪斜斜地，每页上都写着仁义道德几个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是：吃人！《狂人日记》鲁迅，豫才，豫才是大才，我早就说过，不应该只是敲桌子，应该把豫才叫过来，我要当面亲吻他！我跟你们说，我现在的心情就好像是当初看到了适之写的那篇文学改良刍议，我心里面又被点燃了一团火！<br>　　蔡元培：豫才呀，豫才他看问题非常尖锐，他这部小说呀，对国民性的批判，和封建礼教的揭露呀，可谓是入木三分！<br>　　胡适：蔡先生，好是好，会不会有点激烈了一些？<br>　　李大钊：激烈就对了！对这个腐朽的社会，现在就需要这么一剂猛料！<br>　　陈独秀：适之，你可别怕它抢了你这个倡导白话文的头功哦！　　</p><p>49、（旁白）1918年4月，毛泽东、蔡和森、何叔衡在长沙成立新民学会，这是新文化运动在长沙最先成立的以青年学生为主体的革命团体，青年毛泽东由此走上了寻求救国真理的革命道路。<br>　　各位会员，我们的新民学会，是从新文化运动中产生的，它的特点也就是它的灵魂，只有一个那就是——新。所以，要用新思想、新文化、新伦理来武装我们会员的头脑，改良我们会员的品行，进步我们会员的学问，这也是我们新民学会的初衷和使命，所以，我认为新民学会的宗旨就是革新学术砥砺品行，改良人心和风俗，因此啊，学会规定，每一个会员都必须要做到，<strong>第一不虚伪，第二不懒惰，第三不浪费，第四不赌博，第五不狎妓</strong>。</p><p>——湖南长沙 毛泽东宣读新民学会会章，随后当选新民学会干事　　</p><p>50、北大礼堂 陈独秀、钱玄同做《文学革命论》演讲<br>　　陈独秀：在这个文学革新的时代，凡属<strong>贵族文学、古典文学、山林文学</strong>均在排斥之列。为什么呢？盖因此三种文学，与我们现在的阿谀、夸张、虚伪、迂阔之国民性是互为因果的。所以，今天我们要革新政治，就不得不首先革新盘踞于运用此政治者精神的文学。<br>　　各位，近代欧洲文明从何而来？——源于文艺复兴。将来，我文化兴盛从何而来？我斗胆预言，必源于今日之文学革命。<br>　　林纾：狂妄至极！<br>　　钱玄同：各位先生、各位同学，我非常赞同仲甫先生的发言。下面我想说几句心里话，我的观点很明确：中国想要发展，必须废除汉字。<br>　　张少礼：狂妄！<br>　　钱玄同：各位，少安勿躁，听我给大家讲讲道理。世界上各文明、各民族的文字，大多经历过一个从表形文字、到表意文字、再到表音文字的进化过程。表音文字如罗马字，代表的是一个文字进化的高级阶段。汉字不是表音文字，而是表形和表意的文字，因此，必须废除。<br>　　某教授：你这是胡说八道！<br>　　刘海威：钱先生，废了汉字，那我们用什么呀？<br>　　钱玄同：问得好！文字者，不过语言事物的记号而已，我们应该采用一种方法简赅、发音整齐、语根精良的文字，Esperanto，这就是世界语！<br>　　章士钊：钱教授，我觉得你的观点实在是荒谬！若要按照钱教授的说法，我的理解就应该是，让我们全中国的人，从头去学外国的文字。<br>　　钱玄同：这又有何不可呢？<br>　　章士钊：我觉得他不是在搞新文化，他是在毁灭文化，更是要灭我族类呀！<br>　　钱玄同：行严兄，不下点猛药，中国还怎么前进？<br>　　林纾：数典忘祖！<br>　　钱玄同：我必须坚持我自己的观点，我就是这么想的！你们在座的哪一个不是中国人？我也是中国人，我爱我的国家。我认为，推行新文化，就要从废除汉字开始。<br>　　黄侃：钱玄同！我泱泱中华，上下五千年的历史，老祖宗留下的文字，岂可废除？你这是数典忘祖，乱国坏俗！陈仲甫，钱玄同是你《新青年》的同人编辑，废除汉字，便是你新文化所要的结果吗？你必须给个说法！<br>　　陈独秀：我非常能理解，钱教授要废除汉字言论背后，对中国文化的担忧之心。但是，对于废除汉字这一举措，我并不赞同，所以，我保留意见。<br>　　黄侃：其心可诛！<br>　　众人：胡说八道！　　</p><p>51、北大礼堂 胡适做《白话文与白话诗》演讲<br>　　胡适：女士们，先生们，春天好！今天我讲座的题目是《白话文与白话诗》。有很多朋友问我，为什么你胡适非要提倡白话文，而弃用传统的文言文？我的回答是，第一、当日的文言文，乃是一种半死的文字，老百姓看不懂，更听不懂；第二、今天我们倡导的白话文，乃是一种活的文字，并不鄙俗；第三、白话不但不鄙俗，它还非常优美、实用，因为白话文它是一种最能达意的语言。我们知道，达意是言语文字的主要功能，不能达意的语言是不美的。For example：鲁迅先生的白话文小说，里面有这样一段文字：赵老头回过身来，趴在街上，扑通扑通磕了三个响头，这段白描生动、优美、形象，文言文难以企及。我这样说，不知道在座的各位赞同吗？<br>　　众同学：赞同！<br>　　黄侃：胡教授之观点，恕黄某不敢苟同！我记得胡适教授适才言道：白话文对比文言文可删繁就简，更加便捷有效。此，非是事实！</p><h2 id="胡适推崇白话文-李大钊带领学生表演话剧"><a href="#胡适推崇白话文-李大钊带领学生表演话剧" class="headerlink" title="胡适推崇白话文 李大钊带领学生表演话剧"></a>胡适推崇白话文 李大钊带领学生表演话剧</h2><p>（接上集）黄侃对怒胡适：我来举个例子，比如说你之太太亡故，其家人用白话给你打电报必云：你的太太死了，快点回来呀。长达十一个字，若用文言，则仅需，妻丧速归，四字即可，电报费便可省三分之二。敢问胡教授，是你提倡的白话文精练呢？还是我们老祖宗发明的文言文精练呢？<br>　　张丰载：好！说得好！<br>　　胡适：各位，刚才这位黄先生说，用白话文发电报用字多、花钱多，我不赞成，那是因为黄先生他不懂得，如何正确使用白话文。我们现在就可以做一个实验，For example：前两天，我教育部的一位朋友，给我发了一份电文，邀我去做行政秘书，我不愿从政，决定不去。那就此事，我想请黄侃先生，用文言文帮我写一份拒绝的电文，而我则用白话文写一份电文，两相比较，看哪一个更精练、省钱。大家说怎么样？<br>　　邓中夏、张国焘、郭心刚：好！<br>　　黄侃：好啊！我的电文共十二个字：才疏学浅、恐难胜任、不堪从命。<br>　　张丰载：言简意赅，准确，相当准确！<br>　　胡适：黄教授刚才用了十二个字，的确非常简练，在座的各位还有没有比十二个字更少的？如果没有的话，那我就公布我用白话文写的电文：干不了，谢谢，finish！<br>　　张国焘：漂亮！<br>　　黄侃：精鄙！粗鄙不堪！你之电文既无文采，又没礼貌，根本表达不了我那个电文之含义，简直是有辱斯文！<br>　　胡适：我看未必吧！“干不了”，其中就包含了才疏学浅、恐难胜任之意；而我用的“谢谢”又表达了我对友人费心推荐我的感谢，其中也暗示了拒绝之意。像这样既省钱、又省字、又能达意的电文大家何乐而不用呢？由此看出，语言它是否精练，不在于白话文与文言文的差别，在于的是，是否能够恰如其分地选择字词。女士们、先生们，大家赞同我的观点吗？<br>　　众学生：同意！干不了，谢谢！　　</p><p>52、你想想看，从古到今，不管是演戏的还是看戏的，多数都是男性，女性永远都是被排斥在主流语境之外的，而我们新文化运动倡导的是什么？是民主和自由，是所有的民众的觉醒，这民众不单单包括男性，更有千千万万的女性，所以你来演这个角色，本身就是对王敬轩之流一个巨大的讽刺。——北大红楼读书会 陈延年解释为什么要让柳眉一个女性来演王敬轩角色　　</p><p>53、李大钊操办的活报剧《红楼钟声》露天上演<br>　　主持人报幕：（白兰）像一根火柴在黑暗中燃烧，黑暗的夜空出现了光明。（男同学）像一声嘹亮的号角，吹开了人的思想自由翱翔的空间。（白兰）《新青年》的呐喊，就是躁动于母腹之中新生婴儿自由的歌唱。（男同学）红楼的曙光，就是点燃了天空中万朵红霞的那根火柴。（白兰）这声呐喊，招来了多少卫道士横眉冷对的目光。（男同学）这束曙光，引导着多少斗士勇敢地走向了战场。（合）请欣赏活报剧——红楼钟声<br>　　新青年杂志记者（陈延年饰）：可笑！先生将上下五千年、纵横九万里的一切罪恶，完全归到本志所倡导的新文化上，实在是荒谬！我倒要问问，辛亥国变以前，扶持大教、昌明圣道那套老曲子，已经唱了两千多年了，为什么会闹到朝政不纲、强邻虎视、国土沦丧的地步？<br>　　本志记者并非西教信徒，本志所信仰和倡导的是陈独秀先生竖起的科学和民主两面大旗，用科学和民主的精神，提升我们的国民性，这难道就不是抵御外辱、振兴中华的根本之道吗？<br>　　<strong>孔教三纲统治中国两千多年了，受害最甚者莫过于是妇女，三从四德、男尊女卑、夫为妻纲、饿死事小、失节事大、女子无才便是德等等这样的封建教条，像一张张血盆大口无情地吞噬了妇女的尊严、情趣、自由、甚至是生命，造成了多少灭绝人寰的人间悲剧。请问，这样罪恶的封建礼教难道就不应该被废除吗？</strong><br>　　先生号称是贤德之士，却把这吃人的礼教奉若神明。请问，你的老母妻女答应吗？台下在座的这些女学子们能够答应吗？<br>　　先生听到这台下的呼声了吗？听到这终于爆发的呐喊了吗？先生不愿舍弃旧学本是先生的自由，记者无权干涉。但记者要奉劝先生一句，新学先生不喜，旧学先生不精，若先生再下十年的功夫，待《新青年》发行到第二十四卷之时，再与记者谈。望记者能刮目相看！否则，记者就将“不学无术、顽固胡闹”八个字赠予先生，生为考语，死作——墓铭。</p><h2 id="陈延年几人被捕-毛泽东到北大图书馆就职"><a href="#陈延年几人被捕-毛泽东到北大图书馆就职" class="headerlink" title="陈延年几人被捕 毛泽东到北大图书馆就职"></a>陈延年几人被捕 毛泽东到北大图书馆就职</h2><p>54、哎！满街走，顺口溜，大姑娘扮成了小老头。也不知啊动了谁的心头肉，不由分说都抓走。呸！别看你梗脖子瞪着眼威风抖，不过是主人放出的一条狗。</p><p>——北京前门大街 警察抓陈延年等4个北大学演活报剧的学生 说书人即兴说书</p><h2 id="蔡元培创办进德会-张丰载唆使学生们抵触陈独秀"><a href="#蔡元培创办进德会-张丰载唆使学生们抵触陈独秀" class="headerlink" title="蔡元培创办进德会 张丰载唆使学生们抵触陈独秀"></a>蔡元培创办进德会 张丰载唆使学生们抵触陈独秀</h2><p>55、北大红楼图书馆 李大钊与毛泽东深夜谈书论道<br>　　李大钊：这个《共产党宣言》可是一个大文章，不过非常可惜，没有翻译成中文，我也没有看过全文。<br>　　毛泽东：虽然只是《共产党宣言》的几个段落，但是我已经看得非常地兴奋了。您说得很对，我们呀，就是应该多接触些新思想，有比较才会有鉴别。<br>　　李大钊：怎么样啊最近？对于那无政府主义有什么新的认识？<br>　　毛泽东：新的认识倒也谈不上，只是，在我们长沙呢，很难呀，接触这些新思想。相比而言呢，无政府主义影响会更大一些。可这段时间，接触了很多国外的新思想，对我地触动非常地大。我就想呢，抓紧机会，好好地去吸收，至于以后啊，再去慢慢地消化它。<br>　　李大钊：咱们北大有青年读书会啊，经常讨论一些社会问题还有理论，你可以来参加啊！<br>　　毛泽东：我也想去，但我不知道自己有没有这个资格。<br>　　李大钊：你当然有这个资格了！你要去参加，而且你还要敢于发言，敢于辩论，你这样才能有提高啊。<br>　　毛泽东：好，我参加！先生，这段时间，在北大工作，我接触了这么多的新鲜事物，我真是大开眼界啊。<br>　　李大钊：都见着什么新鲜事物了，你说来我听听。<br>　　毛泽东：最近，他们热议的那个话题——进德会。<br>　　李大钊：对于这个进德会，你有什么看法吗？<br>　　毛泽东：先生，我觉得，这修身养性自古皆有，这是士的显著特征。但是，北大重提道德建设，我觉得是有特殊的意思。先生，现在的中国，正在大转型的时代，旧的道德土崩瓦解，新的风尚尚未形成，人们很容易无所适从，人心浮躁，道德失落呢，就在所难免了。他律如果没有法度的支持，自律就显得格外地重要。这个时候，蔡先生，提倡进德会，具有特殊的意义。<strong>在这个浮躁的时代，只有自律的人，才有可能脱颖而出，成就大事。</strong><br>　　李大钊：好你个毛润之啊，你了不起，你竟然可以看到这一层。哎呀，我在你这个年龄，可没有你这样的见 识，从这一点上说，我确实是自愧不如。怪不得，仲甫兄说你，将来必成大事！<br>　　毛泽东：这段时间，我在北大，我有一个突出的感觉，就是我能感觉到处处都在革新，让我感到生机勃勃，但是反对的人也很多，道德，就变成了反对创新的一个武器。所以啊，这段时间，我一直在思考一个问题，讲道德和求真理，这两个之间到底有什么样的区别？<br>　　李大钊：我跟你说说我的看法吧：<strong>道德是变化的，真理是永恒的，这是两者之间的一个区别。道德有新旧之分。</strong>我们如果拿旧的道德，来衡量新时代的行为，这个叫什么？这个叫逆历史潮流而上的卫道者。所以，守旧，就是失德。</p><blockquote><p>道德是用来律己的，不是用来责人的；道德是用来躬行实践的，不是在嘴头空喊的。</p></blockquote><p>道德的要义是修身，修身的最高境界是追求真理，追求好比炼狱啊。就像玄奘法师取经，要经历九九八十一难一样。我们之所以创办《新青年》，就是为了要一大批，像玄奘法师那样的取经者，来为我们这个病入膏肓的中国，寻找剂药方。我认为这个才叫讲道德，讲大德。<br>　　毛泽东：先生，那您，找到那个药方了吗？<br>　　李大钊：还没有，不过，我们已经在路上了。</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144805.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144805.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144846.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144846.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——04</title>
      <link href="/202108/54668/"/>
      <url>/202108/54668/</url>
      
        <content type="html"><![CDATA[<h2 id="英国反对北大解聘英国外教-北大红楼建成"><a href="#英国反对北大解聘英国外教-北大红楼建成" class="headerlink" title="英国反对北大解聘英国外教 北大红楼建成"></a>英国反对北大解聘英国外教 北大红楼建成</h2><p>39、新青年编辑部办公室，同人编辑会议会，陈独秀留李大钊和胡适讨论新青年使命<br>　　胡适：我的想法很简单，《新青年》办刊宗旨，是思想启蒙，以改造国民性为救国的根本思路，在文化思想上替中国的政治，建筑了一个革新的基础，而不是直接地去解决政治问题。<br>　　李大钊：一厢情愿了，适之！我们身处这么一个波澜壮阔的大时代，讨论思想启蒙，怎么可能避开关系到国家生死根本的政治问题。<br>　　胡适：政治问题，政治是权术、是交易，是一种肮脏的游戏，跟做学问风马牛不相及。<br>　　李大钊：这是偷换概！<strong>政治是政治，权术是权术啊，两码事！我们如果启蒙思想，脱离于评论时事的话，那是什么？那是空谈！空谈是什么？空谈误国，向来如此。</strong><br>　　胡适：什么是时事？北洋政府和南方政府对立，它是不是时事？按你这么说的话，咱们《新青年》也应该去议论一下，两个政府是该和呢还是该打？要搅和进去的话，你说你还是不是做学问？<br>　　李大钊：大政治，我说的是大政治，这个国家的方向和道路，应该往哪个方向走，这个总需要讨论吧？<br>　　胡适：那你说中国应该走什么样的方向？<br>　　李大钊：最近我看了中国和日本关于俄国十月革命的报道，我看完以后深受启发，布尔什维克政党通过暴力革命夺取了政权，在俄国掀起了一场新的革命。<br>　　胡适：什么新的革命啊？刚才你也说了，他们是通过暴力夺取了政权，还是换汤不换药。<br>　　李大晚上：你太武断了吧，适之。他们的纲领你看了吗？我看了，我觉得对于解决中国实际问题很有帮助，我最近就想研究它。<br>　　陈独秀：我对俄国十月革命也很感兴趣，我们一起研究吧。<br>　　胡适：要论到发展模式，我还是建议你们应该全面地向美国学习。<br>　　陈独秀：你看，这说着说着就说到一个话题上了，我过去说二十年不谈政治，是不想再像以前那样，直接搞政治斗争啊，想一心一意地致力于思想启蒙，但是思想启蒙也属于政治范畴啊。《新青年》现在的主题是新文化，是要把国民从复辟复古的旧思想中解放出来，两位急先锋，我这么说同意吗？<br>　　胡适：同意<br>　　李大钊：同意　　</p><p>40、强盗逻辑！欺人太甚！置之不理！我行我素！怎么化？公告都贴出去了，泼出去的水还能收回吗？商量什么？难道要我们北大丧权辱国，向洋人低头吗？蔡公，这件事情马虎不得。好，既然是外交事件，那么现在我们北大和克德莱就是两个国家利益的代表。我们北大，一手托着国格，一手托着公理，失掉了哪一个，都是对这个国家的犯罪！</p><p>——陈独秀看了蔡元培带回来的外交照会的副本后怒不可遏，三拍桌子，对于外交部、教育部下达的“顾全大局、大事化小、小事化”了的十二字处理方法进行了愤怒抗议　　</p><p>41、北大校评议委员会会议上讨论如何处理解聘英藉克莱德教授纠纷一事<br>　　陈独秀：我听了蔡先生的介绍，我感到非常地愤怒，这一下子让我想起了七十多年前的鸦片战争，西方列强是怎么欺负我们中国、掠夺我们中国的。那个时候，英国政府，他们就以保护在华侨民的利益为借口，动用坚船利炮，打开了中国的大门，我们中华民族也由此开始沦落。今天，他们又来这一套，又以保护在华英人利益为借口，竟然干涉我们北京大学的内部事务，这是什么？——赤裸裸的强盗行径！是可忍孰不可忍！我的意见很明确，北大绝不能妥协，妥协了我们就是历史的罪人！<br>　　胡适：各位先生，我不远万里从美国回到我的祖国，我为的就是要做一个堂堂正正的中国人。英国人的做法太荒唐了，如果就连这样无耻的要求都要我们屈从的话，我们还谈什么主权和国格？就连我们最基本的人格都没有了。　　</p><p>42、陈独秀、李大钊、胡适旁听北大教授辜鸿铭的英文诗课<br>　　To be, or not to be- that is the question：<br>　　Whether ‘tis nobler in the mind to suffer<br>　　The slings and arrows of outrageous fortune<br>　　Or to take arms against a sea of troubles,<br>　　And by opposing end them. To die- to sleep-<br>　　No more; and by a sleep to say we end<br>　　The heartache, and the thousand natural shocks<br>　　生存还是毁灭，这是一个值得考虑的问题，是默默忍受命运的暴虐的毒箭，还是挺身反抗人世的无涯的苦难，在奋斗中清扫那一切，这两种行为，哪一种更高贵。这是英国伟大的剧作家，莎士比亚在《哈姆雷特》当中一段最著名的独白，也是丹麦王子哈姆雷特人生和命运的思考。我想问一下在座的同学，你们有谁做过这样的思考？你们应该认真地思考这个问题，因为它的答案就是你们的人生观。<strong>有了正确的人生观，你们的人生就有了方向，你们的命运就有了光明。</strong>我们学好英文诗，学好英文，就是把我们中国人做人的道理，把我们温情敦厚的诗教，寓教于四夷之邦。</p><p>——辜鸿铭</p><h2 id="陈独秀一行人与英大使团谈判-英大使团接受北大解聘克德莱"><a href="#陈独秀一行人与英大使团谈判-英大使团接受北大解聘克德莱" class="headerlink" title="陈独秀一行人与英大使团谈判 英大使团接受北大解聘克德莱"></a>陈独秀一行人与英大使团谈判 英大使团接受北大解聘克德莱</h2><p>43、北京东兴楼 陈独秀、李大钊、胡适诚邀辜鸿铭参加北大教授团与英国使团就克德莱解聘案进行谈判<br>　　荷尽已无擎无盖，菊残犹有傲霜枝。——张勋生日，辜鸿铭借苏轼诗《赠刘景文》中前两句送张勋<br>　　辜鸿铭：我老辜啊，十岁就去了英国，十四岁留学欧洲，我对洋人的这个脑子，他们的秉性习惯，我是非常熟悉。我给你们先讲几条：第一，冷漠、滑头，特别害怕承担责任，而且是能逃避就逃避；第二，虚伪、虚荣，很看重利益，但是又羞于启齿，爱做表面文章；第三呢，exclusiveness（排他），孤僻、孤傲、固执、木讷，很不容易与外族人交融，典型的岛国心理；第四呢，conservatives，就是保守，特别不容易接受新生事物。这件事情你就交给我了，只要吾一出马，彼必定害怕；吾一开口，彼必定望风而逃。<br>　　桐花万里丹山路，雏凤清于老凤声。也罢，那我辜鸿铭就舍了这张老脸，给你这个白话娃娃当一回军师吧。</p><p>——听说胡适是主谈，辜鸿铭仰天长笑　　</p><p>44、Mr. Minister（公使先生），Are you threatening me?（你是在威胁我吗？）Are you threatening us?（你是在威胁我们吗？）我们如果可以放弃原则，屈从权势，那今天我们就不来谈判了。</p><p>——英国驻华使馆 陈独秀不畏英国公使的傲慢恐吓，适时挺身而出，不卑不亢地表明我方坚定立场　　</p><p>45、北京绍兴会馆补树书屋 陈独秀、李大钊、钱玄同拜访鲁迅兄弟，诚邀其为《新青年》执笔<br>　　陈独秀：豫才，这建筑看上去有些年头了！<br>　　钱玄同：这绍兴会馆啊，建于道光六年，原名山阴会稽两邑会馆，主要是招待山阴和会稽两县进京赶考的举人，算起来也近一百年了吧。<br>　　陈独秀：历经沧桑啊，比这房子更沧桑的是这些古碑文，让人发思古之幽情啊！<br>　　钱玄同：钻研佛经，抄写古碑，是豫才现在的常态呀。<br>　　陈独秀：我听说这屋子还吊死过一个女人……<br>　　周作人：没有，那是门外。所以，这屋子没人敢住，只有我兄长敢。<br>　　陈独秀：那豫才兄，你住在这儿不压抑吗？<br>　　鲁迅：呵！压抑的，又岂止我这一间补树书屋呢？书屋之外，那些腐臭之息更是不堪！这些年，我见了辛亥革命，见过了二次革命，见过袁世凯称帝、张勋复辟，看来看去，就觉得这社会啊——烂透了，根本无药可救！<br>　　李大钊：豫才兄，小弟以为，上天既然创造了人，就应该给他们一条活路。药还是有的，只不过需要有人去找才行。<br>　　鲁迅：药在何处？寻药之人又是谁？<br>　　陈独秀：我——我们！这药呢，就是豫才兄你的大作呀！<br>　　鲁迅：《新青年》……我看了，温暾水——不够劲！<br>　　陈独秀：请豫才兄赐教！<br>　　鲁迅：<strong>其一，你们倡导白话文，自己却用文言文和半文言文写作——犹抱琵琶半遮面；其二，提倡和普及白话文，根本是要有大众喜闻乐见的作品</strong>……我以为，用白话文写小说，是普及白话文最好的形式，而恰恰你们没有这方面的作品；<strong>其三，也是最重要的，你们口口声声要讨伐孔教三纲，但讲的全是些大道理，认识也不深刻，没有形象思维的作品，是根本不可能触及到人们的灵魂！</strong><br>　　陈独秀：豫才，受教！刚刚一番话，入木三分，句句切中《新青年》的要害！先生，既然已经查明了病因，那就赶紧动手术吧！啊？莫再作壁上观了！莫再犹抱琵琶半遮面了！大刀阔斧吧，豫才！<br>　　鲁迅：——我试试！<br>　　钱玄同：好！就等你这句话！豫才，你只要一出手，绝对是一面旗帜！<br>　　李大钊：豫才兄——相见恨晚！<br>　　陈独秀：豫才，不虚此行，静候佳音，那我们走了！唉？我等你的药哦！<br>　　周作人：来也匆匆，去也匆匆，秋风扫落叶嘛这是！<br>　　鲁迅：我倒是已经领教过一次了，但是，也由此可见，这个人极具人格魅力，将来定能招揽有志之士为其做事。德潜不用说了，那个守常，我也很喜欢，为人稳重、谦和，我相信将来他也一定能做大事。</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144602.jpg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144602.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="v2-223dba85fa638a577aa468ff15505d1c_720w"></p><h2 id="陈延年兄弟带柳眉赴北京求学-李大钊倾囊接济百姓"><a href="#陈延年兄弟带柳眉赴北京求学-李大钊倾囊接济百姓" class="headerlink" title="陈延年兄弟带柳眉赴北京求学 李大钊倾囊接济百姓"></a>陈延年兄弟带柳眉赴北京求学 李大钊倾囊接济百姓</h2><p>46、北京长辛店工棚，李大钊与工人一起过春节<br>　　葛树贵：大年三十雪花飘，家里头来了贵人李大钊，李大钊，这猪肉白菜包水饺，欢欢喜喜热热闹闹！<br>　　李大钊：银装那个素裹呀，喜迎除夕。高朋那个满座啊，我们来把家常叙。要问大伙怎么这么热闹，乡里乡亲呐，都是那好邻居哪！<br>　　葛树贵：这年啊，富人叫过年，穷人——过关。<br>　　李大钊：其实我觉得吧，咱们这帮工人，过好日子也不是没可能！<br>　　葛树贵：哟，大钊先生，您的意思，是不是以后，我们想吃饺子都能吃上啊？<br>　　李大钊：对啊！唉？大伙知道有一个人叫马克思吗？德国人，大胡子，听说过吗？<br>　　工人甲：有你胡子大吗？<br>　　李大钊：那——比我胡子大。我跟大伙说说啊，马克思有一个观点，他认为：工人阶级是人类社会的领头羊，只有是我们工人阶级领导的社会，才是世界上最先进的社会。<br>　　工人乙：这马大爷说，工人阶级做领头羊，不可能吧？咱们工人做领头羊？<br>　　李大钊：怎么不可能？俄国有个人叫列宁，就是根据这种观点和理论，人家把资产阶级政府给推翻了。沙皇倒台后，列宁又领导人民，通过武装起义，推翻了资产阶级临时政府。而后，建立了人类历史上，第一个，工人阶级领导的国家，就叫社会主义国家，也叫苏维埃。<br>　　赵世炎：苏维埃就是代表会议，苏维埃政权就是工人、农民、士兵的代表会议。<br>　　李大钊：对了，世炎说得对，把这个政权建立之后呢，人家干了两件事，颁布了两条法令，第一条，就是宣布不参加世界大战了。<br>　　小姑娘：不跟他们玩了。<br>　　李大钊：唉，你怎么知道？就是不跟他们玩了，不跟这群帝国主义的人玩了！第二条，大家肯定感兴趣，这第二条就是，土地归您了，土地归您了，土地归您了，都归我们大家了。大家想想，土地都归我们自己了，那我们过个好日子它还是难事吗？<br>　　工人甲：可以当家做主了，是吧，以后我们就可以当家做主了！<br>　　葛树贵：大钊先生，<strong>您刚才说的那个社会主义国家，那是不是人不再剥削人，没有人欺负我们穷人了？</strong><br>　　李大钊：没错，就这个意思！<br>　　葛树贵：那您刚才说的那个大胡子，还有列宁那样的人，咱中国有没有？有？咱找他去！<br>　　李大钊：大伙别着急，现在有一群人正在寻找他的路上。<br>　　小姑娘：你就是那个大胡子！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——03</title>
      <link href="/202108/47949/"/>
      <url>/202108/47949/</url>
      
        <content type="html"><![CDATA[<h2 id="胡适回国到北大任职-柳父劝说陈独秀送俩儿子出国留学遭拒"><a href="#胡适回国到北大任职-柳父劝说陈独秀送俩儿子出国留学遭拒" class="headerlink" title="胡适回国到北大任职 柳父劝说陈独秀送俩儿子出国留学遭拒"></a>胡适回国到北大任职 柳父劝说陈独秀送俩儿子出国留学遭拒</h2><p>　　旁白：张勋复辟当日，李大钊被迫逃离北京，他在江南流亡数月，广泛深入社会底层，考察国情，清理思想，苦苦追寻新的救国之路。张勋复辟，宣告了在中国建立资产阶级共和国的方案彻底流产，惨痛的教训促使人们对资产阶级革命进行反思与批判，先进的中国人开始认识到，仅仅靠通过移植西方政治制度的方法难以救中国，要从根本上改造中国，除了文化觉醒和思想启蒙，还要倾听大众的呼声，找到符合中国实际的革新之路。　　</p><p>34、上海亚东图书馆 陈独秀和两个儿子聊天<br>　　陈独秀：这次来既然见到你们了，就跟你们聊聊，聊的问题有两个，第一，你们哥俩小小年纪就出来闯荡世界，自食其力，我很欣慰。你们想去法国勤工俭学，这个我也很支持。但是现在是世界大战，留法的事情还遥遥无期，国内也很混乱，你们总不能呆在这个法文补习班吧。人无远虑，必有近忧，我很想知道你们到底怎么想的。<br>　　陈延年：我们哥俩自己的路自己走，既不依靠别人，也不依靠家庭，勤工俭学对我们来说是最合适的路。我们俩准备到法国去留学，现在已经有了很好的基础，肯定不能半途而废，所以我们决定留在上海上学。现在亚东图书馆的生意不错，我们勤工俭学没有问题，关键是，这儿有我们读不完的书，我们也舍不得走。<br>　　陈独秀：行，既然你们已经想清楚了，那我尊重你们的意愿。第二个问题，你能跟我说说，你跟柳眉到底是怎么回事吗？<br>　　陈延年：什么怎么回事啊？<br>　　陈独秀：你不认为大家都很关注这个问题吗？<br>　　陈延年：大家关注这个问题我不意外，我没想到你也会关注这种问题呀！<br>　　陈独秀：为什么？<br>　　陈延年：因为我觉得你不是这么世俗的人。<br>　　陈独秀：我关注你和柳眉的事情就世俗了？<br>　　陈延年：既然你跟大家一样都这么世俗，那我可以明确地告诉你：我，柳眉，还有乔年，我们是一种纯洁、高尚的互助合作关系。<br>　　陈独秀：没太懂……<br>　　陈延年：那你看过克鲁泡特金和托尔斯泰的书吗？<br>　　陈独秀：看过<br>　　陈延年：那你应该知道互助主义、无政府主义和泛劳动主义。<br>　　陈独秀：知道一点<br>　　陈延年：那你也应该知道，人类社会最理想的状态是什么？<br>　　陈独秀：我洗耳恭听！<br>　　陈延年：人类社会最理想的状态是，全社会所有的人都会通过自律，来不断地实现道德的自我完善，所有人都结成一种超越家庭和恋爱的友爱关系。<br>　　陈独秀：哦，你和柳眉是这样一种关系？<br>　　陈延年：这是我追求的<br>　　陈独秀：那在别人眼里，你们是一对啊！<br>　　陈延年：什么一对？<br>　　陈独秀：就是蝴蝶成双啊，鸳鸯……什么的一对，懂吗？<br>　　延年：这就是我们两代人的不同，你们还无法摆脱世俗的羁绊。但对我们来说，那正是我们要冲破的藩篱，我们追求的，是永远纯洁高尚的友谊。<br>　　陈独秀：那你要冲破这藩篱，柳眉理解吗？<br>　　陈延年：她当然理解，而且我们正在制定一个自律守则，我称它为六不，分别为不闲游，不看戏，不照相，不下馆子，不讲衣着，最重要的是不谈恋爱，不作私交。<br>　　陈独秀：哦，全社会所有的人都通过自律不断实现道德的自我完善，所有人要结合成一种超越家庭、恋爱的友爱关系。那这么说，我跟你姨妈、你姨妈跟你汪伯伯、汪伯伯跟你们、我跟柳眉、柳眉她爸妈跟你姨妈都是一种关系喽？<br>　　陈延年：应该是……<br>　　陈独秀：那你为什么叫你姨妈姨妈？<br>　　陈延年：那就是个称谓嘛！<br>　　陈独秀：那你怎么称谓我啊？<br>　　陈延年：我一直叫你陈独秀——陈独秀先生！<br>　　陈独秀：好，你们吃吧，我走了。还有一盘，吃吧！对了，陈独秀先生带来的，高君曼女士蒸的。　　</p><p>35、北大礼堂 开学典礼上胡适演讲《大学与中国高等学问之关系》<br>　　You shall see the difference now that we are back again. 我们回来了，你们看着办吧！这句话是《荷马史诗》当中的一句话，意思是我们回来了，请你们看分晓吧！我相信这句话也是此时此刻我们每一个北大学人的心情。<br>　　想必这位就是赫赫有名的辜鸿铭先生吧！初次见面就劳您教诲，晚生十分荣幸！<br>　　我非常感谢辜先生对我英语发音上的纠正，但是今天，我引用《荷马史诗》这句话，我不在乎它的语言、语音、语调；我不在乎它是否是正宗的英国人的伦敦腔，还是下等人的发音；我在乎的是，它所表达的内容。“如今我们回来了，请你们看分晓吧”，辜先生，这句话也是我想对您说的；这句话，也是我想送给在座的每一位；这句话也是我们北大学人，对一个旧的中国、一个旧的文化的宣言，也是我们对于办好新北大的一个——郑重的承诺。<br>　　各位前辈、各位老师、各位同学，刚刚蔡先生问到，乱世之中，北大将怎么办？这的确是我们每一个北大学人殚精竭虑的问题吧。还记得是在一九一五年一月，我和竺可桢谈过，创办国内著名大学的强烈愿望，后来我又和英语老师亚舟谈到过，在中国无著名大学的耻辱。在当天的日记当中，我大发感叹地写道 ：“吾他日能见中国，有一著名的国家大学，可比此邦的哈弗、英国之牛津剑桥、德国之柏林、法国之巴黎，吾死，瞑目矣。”第二天，我仍觉意犹未尽，又在日记当中写道：“<strong>国无大学、无国家藏书楼、无博物馆、无美术馆，乃可耻耳</strong>。”今天，我终于回来了，我胡适回到中国别无奢望，但求一张苦口，一支禿笔，献身于北大迈向世界著名大学的进程。</p><h2 id="辜教授讲课获学生们追捧-李大钊放弃当官机会重返北京"><a href="#辜教授讲课获学生们追捧-李大钊放弃当官机会重返北京" class="headerlink" title="辜教授讲课获学生们追捧  李大钊放弃当官机会重返北京"></a>辜教授讲课获学生们追捧  李大钊放弃当官机会重返北京</h2><p>36、做学问的，不能人云亦云，这是我反复强调的北大的学风。——北大凉亭外，蔡元培意欲劝退解雇辜鸿铭教授的学生　　</p><p>37、北大礼堂北大教授辜鸿铭演讲《中国人之精神》<br>　　诸位同学，我知道你们笑什么——笑我头上这根辫子，你们看！<br>　　辫子有什么好笑的呀？这是我们中华文化一条斩不断的根，在座的各位同学，不管你们愿不愿意听，只要你们承认自己是中国人，就要依附于这条辫子，只不过我们不同的是，我的辫子是有形的，顶在头上，你们的辫子是无形的，藏在心里。<br>　　<font color=yellow>千万不要以为我们割掉了毛发，穿上了西装，满嘴的english，洋人就会高看我们，恰恰相反，当一个中国人西化成一个洋人的时候，恰恰会引起他们的蔑视。只有让他们看到，我们中国人，有着他们与众不同的文明与精神，他们才会在心里对我们有真正的尊重。</font><br>　　好，下面，开始我的讲课。<br>　　同学们，我今天讲课的题目，是中国人的精神，这个题目我给洋人讲了好多次，但是，我给他们讲课，每人要收两块大洋的门票，而且我坚决不给他们插话和提问题的机会。当然今天不同了，我是在北大的课堂上，给我自己的学生讲课，这既是我的讲演，也是我们之间的交流，你们可以随时打断我，你们可以提任何的问题，我一定给予你们满意的答复。<br>　　何为中国人的精神？众所周知，在当今的世界上，每个国家、每一个民族都有自己的精神。比如说美国人，他们纯朴、博大，但是他们不深沉；英国人，纯朴、深沉，但是不够博大；德国人博大、深沉，但是没有纯朴。我听过一些外国朋友跟我讲，他们在中国居住得越久，就越喜欢中国人，这是为什么呀？为什么？<br>　　好，我现在就来回答你们的问题。我们中国人，思想、性格，有很多的弱点，但是，在我们中国人身上，有其他任何民族都没有的、难以言喻的东西，那就是<strong>温良</strong>。什么是温良啊？郭心刚同学，你来回答这个问题。郭心刚答：“回先生话，学生以为，温良就是温顺和懦弱。温良是一种不好的精神，而恰恰体现了中国人体制上和道德上的一种缺陷。</p><blockquote><p>”NO——no,no,错，错，错，温良，不是温顺，更不是懦弱，温良是一种力量，是一种同情和人类智慧的力量。我告诉你们一个秘密，我们中国人之所以有同情的力量，是因为我们完完全全、彻彻底底地生活在一种心灵的生活里，这就是与洋人不同的地方。中国人的全部生活是一种情感生活，是一种来自人性深处的情感，是心灵的激情，和人类之爱的情感。</p></blockquote><p>　　我给你举一个例子，为什么，与欧洲人相比，我们中国人有惊人的记忆力。因为我们中国人过着是一种心灵生活，心灵，用同情心和心灵的力量来记事，要强于用头脑来记事，后者枯燥无味。我再举个例子，中国人比外国人有礼貌，这是在全世界都公认的。<strong>礼貌的本质是什么呢？是体谅、照顾他人的情绪。中国人的礼貌是发自内心的，他们懂得自己的感情，他们会将心比心，以己以人，显示出体谅和照顾的特征</strong>。当然日本人也讲究礼貌，我个人认为，他们的礼貌是一种没有芬芳的花儿，我们中国人的礼貌是发自内心的，是一种名贵的、散发着芬芳的香水儿。<br>　　台下同学问：“辜教授，您的意思是，中国人用心，外国人用脑是吗？”<br>　　你可以这样理解。我辜鸿铭生在南洋、学在西洋、娶在东洋、仕在北洋，但是我，是一个堂堂正正的中国人。现在，我就来解开这个秘密，什么是真正的中国人？<strong>真正的中国人，是有着赤子之心和成人之思，过着心灵生活的人；中国人的精神，是永葆青春的精神；中国人精神不朽的秘密，就是中国人的心灵与理智的完美和谐。</strong>我辜鸿铭将终身致力于弘扬与传播这种伟大的精神，虽九死而无悔。<br>　<img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144346.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144346.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img">　</p><p>38、旁白：考察江南期间，通过对伪调和论、伪国家主义和梁启超改良主义的批判斗争，李大钊逐渐开始丢弃，对西方民主制和议会政治的幻想，他提出，对于像袁世凯、段祺瑞那样的反动暴力政治，善良公民有革命的权利。十一月十一日，李大钊毅然放弃朋友推荐他做官的机会，北上北京，踏上了以思想启蒙和社会革命为使命的新道路。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——02</title>
      <link href="/202108/46900/"/>
      <url>/202108/46900/</url>
      
        <content type="html"><![CDATA[<h2 id="李大钊回国当杂志社主编-陈延年兄弟与柳眉结怨"><a href="#李大钊回国当杂志社主编-陈延年兄弟与柳眉结怨" class="headerlink" title="李大钊回国当杂志社主编    陈延年兄弟与柳眉结怨"></a>李大钊回国当杂志社主编    陈延年兄弟与柳眉结怨</h2><p>15、人活得还不如畜牲呢。</p><p>——北京前门大街 路人甲看着衣衫褴褛跪地磕头乞讨的妇人感慨<br>　　<br>16、我们穷人生下来就是等死的命，穷人不是跪着的命，死也得站着，不能跪着。</p><p>——北京前门大街  北京长辛店工人葛树贵怒斥跪地乞讨的妻子<br>　　<br>17、人人平等，没有什么高低贵践之分。</p><p>——《晨钟报》主编 李大钊扶起欲下跪的葛树贵说<br>　　<br>18、<font color=yellow>为世界进文明，为人类造幸福，以青春之我，创建青春之家庭，青春之国家，青春之民族，青春之人类，青春之地球，青春之宇宙。</font><br>　　——上海震旦学院 陈独秀长子陈延年摆摊卖《新青年》，现场朗读李大钊的《青春》<br>　　<br>19、星华、葆华，<strong>以后你们长大之后呢，无论是当工兵还是当其他的，这个由你们自己选择，但是记住，无论我们当什么，我们要当一个堂堂正正的人，我们要当一个永远不祸害老百姓的人。</strong><br>　　——河北李大钊家中《晨钟报》主编李大钊用军棋教儿女做人道理<br>　　<br>20、北京街头，群众议论北京大学学生打架一事<br>　　小贩：我把小锣当当敲，北京大学真胡闹，争风吃醋打相打，只好派蔡元培，接管北京大学堂。哎呀！斯文扫地呀！<br>　　路人：泱泱大国，最高学府，竟养着这么一群败类，这个国家还有什么希望？<br>　　<br>21、蔡元培向北洋政府外交官员汪大燮请教是否应该应黎元洪之邀请出任北大校长<br>　　蔡元培：知我者伯棠兄也！坦率地说吧，北上之前呢，我专门拜访了孙中山先生，孙先生与我一席之谈，他希望我能把北大的校风扭转，唉！创建能跻身世界的一流学府，先生还希望我，树中国现代教育之旗帜，希望我，能为国家早点培养栋梁之材。是啊，<strong>教育救国、科学救国、人才救国，</strong>这正是我蔡元培之追求的理想！<br>　　汪大燮：是啊，当今中国，百废待举，开风气之先的，莫过于陈独秀所兴起的新文化运动，最有吸引力的，也莫过于陈独秀所高擎的科学与民主两面大旗。普及科学与民主，根子在教育，你蔡元培要是能借北大这块宝地，改革创新，重振我中华民族，就有了依托和希望。<br>　　蔡元培：伯棠兄之所言，正是蔡元培，我之心志！</p><h2 id="蔡元培担任北大校长-陈独秀谢绝蔡元培推荐入北大任职"><a href="#蔡元培担任北大校长-陈独秀谢绝蔡元培推荐入北大任职" class="headerlink" title="蔡元培担任北大校长 陈独秀谢绝蔡元培推荐入北大任职"></a>蔡元培担任北大校长 陈独秀谢绝蔡元培推荐入北大任职</h2><p>22、下大雪才浪漫，这就是读书人、卖书人的区别。<strong>苦中作乐，是士的本质</strong>。<br>  ——北京某旅馆 陈独秀跟汪孟邹讲要去招股北大教授钱玄同入伙新青年　　</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821143519.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821143519.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><blockquote><p>那年大雪纷飞，我迎先生到北大来。如今天凉入秋，我却要送先生离开。<br>不好受</p></blockquote><p>23、1916年12月 北京陶然亭 陈独秀与钱玄幻雪中相约<br>　陈独秀：德潜——是你吗？<br>  钱玄同：仲甫兄！久仰大名，如雷贯耳啊！今日总算是得识真颜啦！<br>  陈独秀：万物言同，相忘于道，你我虽天南地北，从未谋面，却神交已久。<br>  钱玄同：是啊！我可是你《新青年》的忠实读者，也是你陈仲甫的铁杆支持者呀！<br>  陈独秀：哎呀！德潜你过谦了啊！怎么样？今日，我约这雪中陶然亭相见，不觉得奇怪吧？<br>  钱玄同：雪中游陶然，要的就是一个“雅”！怎么会怪呢？<br>  陈独秀：那不觉得冷吗？<br>  钱玄同：与仲甫兄相见，如沐春风！寒意全无！<br>  陈独秀：果然是同道中人！<br>  钱玄同：同道中人还有一位！我给你介绍，这位——刘半农，文学翻译家，也是上海著名的鸳鸯蝴蝶派报人。<br>  陈独秀：哎呦！半农！我看过你翻译的很多欧洲小说，受益得很！<br>  刘玄同：与先生相比，半农不过就是泰山上的一抔土！<br>  陈独秀：这呆在北京的人，怎么都这么谦虚呀？<br>  钱玄同：哈哈哈，仲甫兄，咱们亭上说话！这陶然亭啊，最有名的当属江澡撰写的《陶然吟》，据说他经常请那些文人墨客、同僚好友来此饮宴、赋诗。<br>  陈独秀：果然是——红尘中的清净世界啊！可惜，今日无酒啊！<br>  钱玄同：仲甫兄前来，岂能无酒！来人，上酒！<br>  陈独秀：哎呀……这酒可是花雕？<br>  钱玄同：没错！我老家的花雕。烫好了，用棉被包裹着，黄包车送来的。<br>  陈独秀：哎呀！德潜，半农！你们可真用心！感动！感动！<br>  刘半农：更待菊黄家酝熟，共君一醉一陶然！<br>  陈独秀：好！今日，有你、有雪、有花雕；有琴、有诗、有红梅，高山流水觅知音，果然雅致！来！咱先干一杯！<br>  陈独秀：怎么样？钱玄同：暖！<br>  陈独秀：半农，你不是在上海吗？怎么也到北京了？是赶时髦吗？<br>  刘半农：北大搞改革，我是想过来应聘教书！<br>  陈独秀：哦！这北京对文化人就这么有吸引力吗？<br>  刘半农：说来也怪啊！眼下这些文人骚客们来了就不走，那是趋之若鹜啊！无论在这里活得多贫穷。<br>  陈独秀：为什么？钱玄同：阳春白雪、下里巴人、鱼龙混杂、包罗万象，机遇与风险并存。仲甫兄，这《新青年》就象今天这冬日里的一把火，点燃了振兴中华的希望之光，我们都是这把火炬的追随者。<br>  陈独秀：独秀此次来京，就是要拜谒各位，襄助《新青年》，把这把火烧得更旺些。<br>  钱玄同：责无旁贷！只是仲甫兄，有没有考虑过把《新青年》搬到北京来？<br>  陈独秀：北京？《新青年》在北京能立足吗？<br>  刘半农：岂止是立足？立足北京，放眼全国，发扬光大！陈：来！咱们今天不醉不归！</p><h2 id="陈独秀决定在北京发展事业-蔡元培带陈独秀参加学校会议"><a href="#陈独秀决定在北京发展事业-蔡元培带陈独秀参加学校会议" class="headerlink" title="陈独秀决定在北京发展事业 蔡元培带陈独秀参加学校会议"></a>陈独秀决定在北京发展事业 蔡元培带陈独秀参加学校会议</h2><p>24、新青年的宗旨是创造一代新人，但是新人是什么？我以为，新人就是新学生、新工人、新农民，甚至是新官僚，你只有各个阶层都改造了，整个社会才能发生质变。北京呢，上通天，下接地，绝对是新青年的最好的用武之地。</p><p>——北京《甲寅日刊》编辑部 李大钊建议陈独秀把《新青年》搬到北京发展　　</p><p>25、北京大学礼堂 北大校长蔡元培发表就职演说<br>　　各位，五年前严复先生为北大校长时，我服务于教育部，做教育总长。记得北大开学的那天，我为本校做了一点贡献。诸君多自预科毕业而来，想必也知道，士别三日当刮目相看，何况时日已过去数年，诸君与往昔相比，一定有了长足的进步。我今天就要服务于北大，我有三件事要告诉诸君：<br>　　一、抱定宗旨。诸君来此求学，必有一定宗旨，须知宗旨，正大与否，必先知大学之性质。大学者，研究高深学问之者也。现在外面常常有人指责北大之腐败，是因为来此求学者，都抱有当官发财的思想，以此为捷径。因为一心要做官，一心想发财，所以，<strong>从不问教员之学问深浅，唯问教员官职的大小</strong>，官阶大的，就特别受欢迎，这大概是为了方便毕业时有人提携吧。我想说的是，诸君来北大求学，三年或四年，时间不谓不多，如能爱惜光阴，孜孜求学，则其造诣定然会很高、很深。诸君来北大求学的宗旨是做官发财，那这个宗旨就错了，求学的路，就必然走偏了。<strong>平时冶游，考试来了，才去翻读讲义，不问学问之有无，唯争分数之多寡；考试结束，书籍，束之高阁，毫不过问，潦草塞责；文凭到手，即可以此活动于社会，光阴虚度，学问毫无。</strong>这是自误啊，这与到北大求学的真正宗旨，是大相背驰的。大家也许还记得，发生不久的辛亥革命，我们之所以要革命，就是因为清朝政府太腐败，就是现在也有许多人，对现状不满意，也是因为社会道德沦丧。诸君在这个时候，如果不打好基础，勤奋求学，万一为生计所迫，做了教员，则一定会耽误学生哪；你进入政界，则一定会耽误国家呀，这是耽误别人，误人误己。所以，宗旨不可以不正大，这是我希望于诸君者之一。<br>　　二、砥砺德行。如今的社会风气啊，越来越苟且敷衍，只顾眼前，道德伦丧、败坏德行的事情，触目皆是，不是德行根基牢固的人，少有不被这种社会风气所污染。各位，国家的兴衰，要看社会风气是高尚还是低劣，如果都流行于这种社会风气，前途不堪设想，<strong>所以要有卓越之人，以身作则，尽力去矫正这种颓废的社会风气。诸君皆为大学学生，地位甚高，肩此重任，责无旁贷。如果德不修、学不讲，还与这种颓废的社会风气同流合污，那亦是侮辱自己</strong>，更何谈，做他人的榜样呢？所以，品行不可以不严谨对待和修养，这是我希望于诸君者之二。<br>　　三、尊敬师友、坦诚相见、开诚布公、相互勉励。各位，我们同处北大，要荣辱与共啊。我相信，我们北大一定会是出文化大家、思想大家的地方。<br>　　我今天就说这么多，来日方长，随时再为商榷。</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-d1de0413706c5803f5403de4a4c19f2c_720w.jpg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-d1de0413706c5803f5403de4a4c19f2c_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="陈独秀杂志文被老师痛批-毛泽东写文章获杂志社赏识"><a href="#陈独秀杂志文被老师痛批-毛泽东写文章获杂志社赏识" class="headerlink" title="陈独秀杂志文被老师痛批 毛泽东写文章获杂志社赏识"></a>陈独秀杂志文被老师痛批 毛泽东写文章获杂志社赏识</h2><p>26、文化是政治的先导。这个文化啊它是割不断的，<strong>它新文化只能在旧文化的襁褓中生长，对旧文化，它只是扬弃和革新</strong>，在学术研究上不能搞清一色，要鼓励和支持百家争鸣。作为北大的文科学长，不能容不得人啊，你知道，<strong>人和文化是最复杂的，在当今这么一个混沌的时代，其实每个人都在为国家寻找出路，只是思路不同罢了。</strong>我的理想：北大，它要成为群贤必至的学术大舞台，因为只有这样，才能滋生出健康的新文化，我请仲甫兄到北大来任文科学长，盖源于此。</p><p>——北大校长办公室，评议委员会会议之后，蔡元培开导陈独秀接受保守派教授　　</p><p>27、同学们，文学革命之气运，酝酿已非一日，其首举义旗之急先锋，则为吾友胡适，余甘冒全国学究之敌，高张文化革命军大旗，以为吾友之声援，旗上大书特书，吾革命军三大主义：</p><blockquote><p>曰，推倒雕琢、阿谀的贵族文学，建设平易的、抒情的国民文学；<br>曰，推倒陈腐的、铺张的古典文学，建设新鲜的、立诚的写实文学；<br>曰，推倒迂晦的、艰涩的山林文学，建设明了的、通俗的社会文学。</p></blockquote><p>——北大礼堂 陈独秀宣导胡适的文学革命三大主义</p><p>28、国力苶弱，武风不振，民族之体质，日趋轻细，此甚可忧之现象也。提倡之者，不得其本，久而无效，长是不改，弱其加甚。</p><p>——湖南省立第一师范学校 新文化运动学者易白沙朗读学生毛泽东准备投稿《新青年》的文章《体育之研究》</p><h2 id="周树人目睹百姓买人血馒头-李大钊到《新年青》杂志社任职"><a href="#周树人目睹百姓买人血馒头-李大钊到《新年青》杂志社任职" class="headerlink" title="周树人目睹百姓买人血馒头 李大钊到《新年青》杂志社任职"></a>周树人目睹百姓买人血馒头 李大钊到《新年青》杂志社任职</h2><p>29、这新青年提出的砸烂孔家店，砸的不是孔子儒学，砸的是孔教的三纲五常，我们反对的是政治尊孔，不是学问尊孔。众所周知，自董仲舒罢黜百家独尊儒术起，这个孔子儒学就变了味道了，就成了历代皇帝统治国家的权术，愚弄民众的武器。所谓君为臣钢、父为子纲、夫为妻纲，窒息了国家的活力、祸害了民众的生活、阻碍了文明的进步，一句话——造成了中国的落后，这种孔教三纲，不应该被砸烂吗？袁世凯复辟帝制，要做皇帝，就要拜孔教为国教，尊孔学为国学，这就是眼前的政治啊！封建礼教，至今还在统治着社会生活，奴役着人民思想，难道这不是中国落后的原因吗？</p><p>——北大凉亭 校评议委员会上陈独秀舌战保守派教授辜鸿铭、黄侃　　</p><p>30、北京菜市口，钱玄同找到独自默默看碑文的鲁迅，替陈独秀邀请其为新青年投稿，两人激烈辩论<br>　　鲁迅：我现在，躲进小楼，不问春秋，就三件事我办：抄古碑、辑录金石碑帖、校对古籍，别的事我一概都不感兴趣。你要是找我写稿子，那就不聊了。<br>　　钱玄同：那，那你说，你现在写这些有什么意思？既然没什么意思，你抄它干嘛，你现在可消沉了啊。<br>　　鲁迅：不是消沉，是看不到前程，家事、国事都一样。<br>　　钱玄同：豫才兄，你怎么变得这样啊？你还是我认识的那个气冲牛斗的周树人吗？你知道现在是什么时局吗？有人想要复辟帝制，请那个小宣统皇帝再出来当皇帝，你就不想说点什么？<br>　　鲁迅：假如啊有这么一间铁屋子，绝无窗户而且是万难破毁的，里边有许多熟睡的人们，不久就要被闷死，然而从昏睡入死他们全然不知道就要死的悲哀。现在，你，大嚷一声，惊醒这几个较为清醒的人，但是这不幸的少数者， 要去承受这无可挽救的临终的苦楚，你倒以为，你对得起他们？<br>　　钱：<strong>如果我嚷几声，能叫醒那几个人，我就绝不能说，他没有毁坏这铁屋的希望。</strong><br>　　<br><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-90a8c531c01d9171a8dc94305d3d31b7_720w.jpg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-90a8c531c01d9171a8dc94305d3d31b7_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-6eba475fbb77804439f35b08e58ff76a_720w.jpg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/v2-6eba475fbb77804439f35b08e58ff76a_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>31、1917年6月，张勋率辫子军进京城前夕，被砸烂的北京《甲寅日刊》编辑部，李大钊不同意解散杂志社，与陈独秀意见相左，不欢而散。<br>　　李大钊：仲甫啊，现在国家这个形势，你那个《新青年》还编得下去吗？恕我直言，你那个二十年不谈政治的口号，不能再提了。我的意思很明确，那个口号不合乎中国的实际。<br>　　陈独秀：糊涂！守常，我一直以为你明事理，晓局势，怎么能这么糊涂？你看看当下国民素质，你怎么跟他们谈政治啊？<br>　　李大钊：三年之内，两次复辟，这个政府允许我们提高国民素质吗？仲甫兄啊，丢掉幻想，准备战斗吧！<br>　　陈独秀：不行，总之，我不能让你去送死，当下的中国，不需要你这样的谭嗣同。<br>　　旁白：在方兴未艾的新文化运动中，李大钊，通过他编辑的《甲寅日刊》与陈独秀主编的《新青年》相呼应，发表大量文章，集中倡导民主主义，猛烈抨击封建主义及旧文化、旧思想。和陈独秀不同的是，李大钊不回避政治，对当时的政治制度进行了深刻的批判与研究，在社会革命家的道路上自觉实践，社会革命的思想得到进一步深化。　　</p><p>32、</p><p>英雄淘尽大江流，歌舞依然上画楼。<br>一代声华空醉梦，十年潦倒剩穷愁。<br>竹帘半卷江天雨，蕉扇初迎海外秋。<br>忆到万山无语句，只应共泛五湖舟。</p><p>——1917年7月张勋复辟，李大钊写信给天津友人白坚武，做诗《复辟变后寄友人》，并题词“铁肩担道义，妙手著文章”</p><p>　　##   李大钊被清朝政府通辑逃往上海 段琪瑞拥护蔡元培继续做北大校长</p><p>　　</p><p>33、同胞们，逆贼张勋冒天下之大不韪，携五千辫子军闯入我京师，悍然发动政变，复辟了那个已经死了六年之久的腐朽的清朝政府。<br>同胞们，在去年，我们的民国就已经被窃国大盗袁世凯蹂躏过一次了，那么现在，这群肮脏的、无耻的辫子军又一次用卑鄙的手段蹂躏了我们的民国。<br>同胞们，他们可以掐死我们的民国，但是他们掐不死民众内心当中的共和；他们可以挡住天上的太阳，但是他们无法挡住民主的光芒。</p><p>京师是首善之地，我们绝不能允许那些前清的遗老遗少们戴着马尾巴做的假辫子，在这儿招摇过市；我们也绝不能允许张勋复辟的阴谋得逞。反对张勋复辟，誓死维护共和。</p><p>——张勋率辫子军闯入北京城，《甲寅日刊》编辑李大钊率领北大学生当街游行并当众演讲</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《觉醒年代》经典台词——01</title>
      <link href="/202108/10062/"/>
      <url>/202108/10062/</url>
      
        <content type="html"><![CDATA[<h2 id="袁世凯丧权辱国引民愤-李大钊慷慨陈词欲救国"><a href="#袁世凯丧权辱国引民愤-李大钊慷慨陈词欲救国" class="headerlink" title="袁世凯丧权辱国引民愤   李大钊慷慨陈词欲救国"></a>袁世凯丧权辱国引民愤   李大钊慷慨陈词欲救国</h2><p>1、天发杀机，战云四飞，倭族趁机，逼我夏宇，留日学子，羁身异域，回望神州，仰天悲愤。<br>既然已经到了国亡人死之际，便再无投鼠忌器之顾虑，我们应该有破釜沉舟之决心。<br>窃国大盗袁世凯，恢复帝制想要当皇帝，中华民国危在旦夕了；卖国贼袁世凯签定了二十一条，中华民族危在旦夕了。<br>同胞们，共和就要死了，青岛就要丢了，同胞们，你们说，怎么办？</p><p>——留日学生李大钊在日本早稻田大学听到袁世凯签定二十一条的消息后愤慨陈词<br>　　<br>2、辛亥革命以来，整个民众的思想早已经得到了翻天覆地的变化，从海内外齐声倒袁这个现象来看，便是铁证。<br>越是在民族危亡之时，就越应该唤起民众的觉悟，振作民族精神，而且要把共和的思想灌输给民众，则必须推翻封建的思想。<br>逆历史潮流者，必被时代的洪流所淹没。<br>我们为了爱国，必须要救国，倒袁；我们为了我们的中华民族，更必须要救国，倒袁。</p><p>——李大钊批判张丰载反对革命的封建思想<br>　　<br>3、日本早稻田大学，二次革命失败，流亡日本的陈独秀与留日学生李大钊一见如故，探讨爱国之路：<br>　　李大钊：您说，爱国要有立场，爱国不能打着爱国的旗号，甘愿去当袁世凯的顺民，那按您的意思来说，只要是袁世凯当政，大家就不要爱国了？<br>　　陈独秀：爱国要有立场，不能把爱国跟效忠袁世凯混同起来，打着爱国的旗号来掩饰袁世凯的窃国行为。那袁世凯口口声声说他就代表国家，他是在混淆概念。如果爱国没有立场，那我们就根本没有理由来打倒袁世凯。<br>　　李大钊：我深以为然。我认为当今的第一要务是启发民众真正的爱国心，眼下中国正在被西方列强所瓜分，如果大家都不爱国的话，那这个国家就亡了。<br>　　陈独秀：守常，我问你，西方列强瓜分中国靠的是什么？<br>　　李大钊：船坚炮利啊<br>　　陈独秀：非也！你说的那是鸦片战争和甲午海事。<font color=yellow>现在列强瓜分中国靠的是借债</font>。中国政府，每年，向西方各国借的外债，占国库收入一半以上。一个没有生产力的国家，只能靠，以国税铁路为抵押，借债来维持政权。这样的国家有什么希望？<br>　　李大钊：正因为这样，我们才要倒袁，推翻这个腐朽的统治，建立一个新的国家。<br>　　陈独秀：非也！靠政治革命可以救中国？中国的问题积重难返，靠换人、换政府能解决吗？<br>　　李大钊：那照您这么说，中国岂不是没有出路了？<br>　　陈独秀：有！但出路不是老路，只有找到一条新路，中国才不会亡。<br>　　李大钊：何谓老路？<br>　　陈独秀：<strong>政权更迭，推翻一个旧王朝，建立一个新王朝，循环往复，这是老路。</strong><br>　　李大钊：那何为新路呢？<br>　　陈独秀：不知道！——我正在找。守常，我欣赏你的见识和才华，你愿意跟我一起找吗？<br>　　李大钊：为中国寻找一条救国之路，乃是我李大钊毕生所求。我愿意！<br>　　陈独秀：好！</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821143808.png" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821143808.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821143848.png" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821143848.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210821143848657"></p><p>4、从日本回国船上，陈独秀与易白沙聊天：<br>　　陈独秀：杨度、严复，那是聪明一世，糊涂一时，而那个梁士诒一伙，则是没有道德底线的政治流氓，我给他们起了个名字，叫礼义廉。<br>　　易白沙：什么意思？礼义廉？<br>　　陈独秀：礼义廉，无耻啊！无耻之极，无耻之尤。<br>　　易白沙：仲甫，思想清奇啊！<br>　　陈独秀：十多年了，我陈独秀先学康梁，后随中山，致力政治革命，为了革命，东奔西走，九死一生，光日本就去了五次。结果到现在，不还是一事无成吗？中国的事情，光靠政治革命，解决不了根本问题。追根溯源，要换换思路了。<br>　　易白沙：你有什么新思想？<br>　　陈独秀：新思想不敢说，我这次回国，打定主意了，二十年不谈政治。<br>　　易白沙：不谈政治，你想干什么呀？<br>　　陈独秀：<strong>脱胎换骨，换人、换脑子</strong>。<br>　　<br>5、吾辈学生，于国民中尤当负重大之责任，研究精神上之学术者，宜时出其优美之文学，高尚之思潮，助我国民精神界之发展；研究物质上之学术者，宜时摅其湛深之思考，施以精巧之应用，谋我国军事工艺器械之发达，诚以精神具万能之势力，苟克持之以诚毅，将有伟大之功能事业。基于良知，一念之微明，则曹沫雪辱，勾践复仇，会有其时。——李大钊于日本早稻田大学宿舍写日记<br>　　<br>6、同胞受辱，就远没有，比你们打麻将重要是吗？<font color=red>国之所以不昌，在于民智未开也</font>。</p><p>——回国船上陈独秀扔了张丰载麻将牌后愤慨之言</p><h2 id="陈独秀终于抵达上海-遭儿子戏弄却反欢喜"><a href="#陈独秀终于抵达上海-遭儿子戏弄却反欢喜" class="headerlink" title="陈独秀终于抵达上海    遭儿子戏弄却反欢喜"></a>陈独秀终于抵达上海    遭儿子戏弄却反欢喜</h2><p>　　</p><p>7、上海陈独秀家里，陈独秀和高君曼听雨聊天：<br>　　陈独秀：我在国外，听过欧洲一首歌曲，名字叫《国际歌》，歌词还没翻译过来，不过有几句倒是让我印象深刻。大意是：世上没有救世主，也没有神仙上帝。要创造大家的幸福，只有靠我们自己。唱得好，说得对。大到国家，小到个体，自己的命运自己争取，把自己的命运寄托到老子和家庭身上，是靠不住的。<br>　　高君曼：那，你这个父亲是干什么的？你的责任到哪里去了？<br>　　陈独秀：我的责任就是，<strong>让他们知道，怎么才能担得起这个国家、社会和历史的责任。</strong>如今乱世，作我陈独秀的儿子，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p><p>8、上海亚东图书馆，汪孟邹为陈独秀接风设宴，陈独秀与仁人志士分析当前局势：<br>　　陈独秀：同治十三年，满人李鸿章在筹议海防折中，称我中华已处于三千年未遇之大变局，三千年未遇之大强敌的时代，我想问问诸位，这个变局和强敌指的是什么？自道光二十年，英吉利人用坚船利炮打开了中国的大门，我们这个国家就已经在大变局了。李鸿章精心办洋务、建海军，忙忙碌碌几十年，自救自强，结果呢？甲午年一战崩溃，成全了一个日本帝国。从那个时候起，大清王朝就已经名存实亡了。后来辛亥革命，孙中山推翻帝制建立了共和国，但是什么是共和啊？中山先生也在苦苦求索，国人更是莫衷一是，各取所需，自说自话。我们这些反帝制、求共和，出生入死几十年的人，现在倒要回去当皇帝的顺民了？是历史在跟我们开玩笑吗？所以我今天就想问问，这三千年未遇之大变局，三千年未遇之大强敌，到底指的是什么？<br>　　易白沙：依我所看，变局指的是帝制的崩溃，强敌指的就是西方列强吧。<br>　　陈独秀：变局中国经历的多了，从秦始皇到小宣统，改朝换代几十次，到头来还不是专制体制的循环吗？强敌中国也经历多了，古往今来，有多少强敌打到了中原，结果呢？我泱泱中华不仅没有消亡，反而像滚雪球一样的越滚越大。中华文明五千年，这是老祖宗留给我们的优势，所以，我们有这个自信。<br>　　陈子寿：仲甫啊，你说的这些个都是历史，现在今非昔比了。<br>　　陈独秀：没错！鸦片战争打破了这个格局。这一次真的不同了，这一次我们遇到的真的是前所未有的强敌。这个强敌，不光强在武力上，更重要的，他是强在思想上和理念上。他们不仅有工业时代所产生的先进武器，他们还有资本时代所产生的先进理念和先进的体制。在他们面前，我们的制度落后了，我们的思想也落后了，一句话——我们的人，落后了。这是我们泱泱中华几千年文明史上的第一次，对吗？所以，我的结论是：改造中国，首先要改造中国人的思想，提高中国人的素质；<strong>要想光复中华昔日之辉煌，首当其冲的，要造就一代新人。</strong><br>　　邹永成：仲甫兄说得太有见地了！但是这事太难了，不是一朝一夕能完成的。<br>　　陈独秀：确实，这需要很长的一个过程，不能急功近利，我们也不能彷徨徘徊，天生我才，不敢担当就是失职，就会遗祸子孙，我等，绝不能作壁上观的局外人吧。<br>　　陈子沛：操大心，办大事，这是我等的责任。<br>　　陈子寿：仲甫，说得好啊，我们该怎么做？<br>　　陈独秀：<strong>一、思想启蒙；二、改造社会。</strong>悠悠万事，千头万绪，唯此两项为大。<br>　　汪孟邹：仲甫啊，那外国人那思想是五花八门啊，制度也是五花八门啊，哪一个适合我们国家？<br>　　陈独秀：问得好！对西洋先进的思想和制度，我们必须要辨析，我们要找到最核心、最普遍、最实用的东西来武装我们的青年。这个问题我探索多年，已经找到了明确的结论，不久，我会昭告天下。所以此次归国，我想创办一份杂志，作为唤醒国人政治的觉悟，和伦理的觉悟的号角。我向各位保证，让我办十年杂志，全国思想都会为之改观。各位，一代人有一代人的责任，我们这些人的责任就是要通过办杂志辨析、选择和验证出一种当代最先进的思想理论，作为改造中国青年和改造社会的指导思想，来探索出一条振兴中华的道路。　</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144702.jpeg" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/08/20210821144702.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>9、首先，我认为仲甫先生提倡的那个<strong>“有国家不为喜，无国家不为忧”</strong>的自觉心是一种悲观厌世误国的论调。何为自觉？自觉就是改进国家精神，自强不息地创立一个新的国家，<strong>我们不能因为这个国家不可爱了，就不爱国了。更不能因为我们没有享受到这个国家的爱，就去厌恶，甚至是抛弃这个国家。</strong></p><p>——李大钊在日本早稻田大学与章士钊、高一涵谈他即将在《甲寅》杂志上发表的作品《厌世心与自觉心》</p><h2 id="陈独秀为筹钱竟然卖字-李大钊被开除决心革命"><a href="#陈独秀为筹钱竟然卖字-李大钊被开除决心革命" class="headerlink" title="陈独秀为筹钱竟然卖字 李大钊被开除决心革命"></a>陈独秀为筹钱竟然卖字 李大钊被开除决心革命</h2><p>10、上海东亚图书馆，章士钊、陈独秀、汪孟邹、邹永成开会：</p><p>​        陈独秀：这两个月，我和易白沙足不出户，创办了本《青年杂志》，本意是鼓吹新文化、宣传新思想、造就新青年，就是想用世界上最先进的思想理论，来替代统治了中国几千年的孔教三纲，用科学与民主的旗帜，重塑一代新青年。这是创刊号的草样，各位先生指教。<br>　　邹永成：这封面上怎么是个外国人，这谁呀？<br>　　陈独秀：卡内基啊！钢铁大王兼慈善家，他是苏格兰人，十一岁迫于生计移居美国，为了糊口，在纺织厂打过工，烧过锅炉，做过快递员，后来靠着自身的聪明和努力，建立了自己的公司，创建了与洛克菲勒和摩根并立的钢铁帝国，成了美国经济三大巨头之一。我之所以把卡内基作为创刊号的封面人物，就是想告诉那些还在吃苦受罪的中国孩子，<strong>天下的路是留给天下的人走的，有志者事竟成。</strong>　　</p><p>11、上海震旦学院礼堂 陈独秀演讲<br>　　可是建立了民国又怎么样呢？洋人照样欺负我们，老百姓照样吃不饱饭，这是为什么？<strong>这就不光是我们技不如人，制度不如人，最根本的，是我们思想、道德、理念不如人家先进。所以我说，所有觉悟，归根结底，就是思想的觉悟、道德理念的觉悟，这最后的觉悟，说到底——人的觉悟。</strong>这最后的觉悟就是要换脑子，要找到世界上最先进的思想，来武装我们的人民，来塑造新一代青年，来创造一个崭新的国家。<br>　　当代中国的新青年，我以为应该有六个标准：</p><blockquote><p>一、自主的而非奴隶的；<br>二、进步的而非保守的；<br>三、进取的而非退隐的；<br>四、世界的而非锁国的；<br>五、实利的而非虚文的；<br>第六、科学的而想象的。</p></blockquote><p>六条标准，总的来说，就是<strong>科学与民主</strong>。</p><p>要造就一代新青年，唯有用科学和民主并重。科学与民主就是检验政治、法律、伦理、学术以及社会风俗和人们日常生活一言一行的准绳，凡是违反科学与民主的，哪怕是祖宗之遗留、圣贤之垂教、社会之崇尚皆不值得提倡。<br>　　旁白：一九一五年九月十五日，陈独秀在上海创办《青年杂志》，现代中国思想启蒙的新文化运动应运而生　　</p><p>12、湖南长沙 湖南省立第一师范学生毛泽东急切寻找志同道合朋友，冒雨赴约结识新友人<br>　　毛泽东：纳于大麓，藏之名山。<br>　　李立三：对呀，书经曰：纳于大麓，烈风雷雨弗迷，二十八画生，我相信，天必降大任于斯人也。<br>　　毛泽东：各位啊，这我国士人，<strong>文弱者多，武风不振</strong>，敢于努力救国之新青年，<strong>筋骨强，方能气力雄</strong>，才能真的把外国人叫我们东亚病夫的帽子彻底地踩在脚下。文明其思想，野蛮其体魄，心力体力合二为一，世上事未有不成。诸位这才是我们中国的新青年。<br>　　旁白：毛泽东被《新青年》打开了眼界，他开始循着初期新文化运动的思路探索，这期间，他在日记中写下这样的话：</p><blockquote><p>与天奋斗，其乐无穷，与地奋斗，其乐无穷，与人奋斗，其乐无穷。</p></blockquote><p>13、天津南开中学小礼堂  南开学校学生周恩来为同学们朗读《敬告青年》<br>　　各位同学，我看了这本新出刊的《青年杂志》，一下子被陈独秀先生写的创刊词《敬告青年》所吸引住了。它就像一盏明灯，照亮了我的心志，让我感到我以前的所思、所学、所行实在是一无所取。所以，我打算更换一下我朗读的文章，读一读这篇《敬告青年》，同大家一同分享我心中的快活。<br>　　国人而欲脱蒙昧时代，羞为浅化之民也，则急起直追，当以科学与人权并重。士不知科学，故袭阴阳家符瑞五行之说，惑世巫民；农不知科学，故无择种去虫之术；工不知科学，故货弃于地，仰给于异国；商不知科学，故惟识罔取近利，未来之用处，无容心焉；医不知科学，既不解人身之构造。宇宙间之事理无穷，科学领土内之膏腴待辟者，正自广阔，青年勉乎哉？　　</p><p>14、日本早稻田大学 李大钊为高一涵朗读《青春》<br>　　地球即成白首，吾人尚在青春，以吾人之青春，柔化地球之白首，虽老犹未老也。是则地球一日存在，即吾人之青春一日存在，吾人之青春一日存在，即地球之青春一日存在。<br>　　旁白：一九一六年，李大钊在日本写下了著名的《青春》一文，文章以昂扬的革命精神和科学的人生态度，表达了明显的唯物主义思想，提出了再造青春中华的理想主张。号召青年，冲决过去历史之网罗，破坏陈腐学说之囹圄，以青春的精神不断改造自我，以青春的朝气、青春的理想，唤醒百年沉睡的旧中国，建立青春之中华。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电视剧 </tag>
            
            <tag> 觉醒年代 </tag>
            
        </tags>
      
    </entry>
    
    
<<<<<<< Updated upstream
=======
    
    <entry>
      <title>【手把手教你写Go】GO语言并发编程</title>
      <link href="/202107/62908/"/>
      <url>/202107/62908/</url>
      
        <content type="html"><![CDATA[<h1 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a><strong>11.1 概述</strong></h1><h3 id="11-1-1-并行和并发"><a href="#11-1-1-并行和并发" class="headerlink" title="11.1.1 并行和并发"></a><strong>11.1.1 并行和并发</strong></h3><p><strong>并行(parallel)：</strong> 指在同一时刻，有多条指令在多个处理器上同时执行。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1c1a6be4cd94c38827d8a2d55505211~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1c1a6be4cd94c38827d8a2d55505211~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p><strong>并发(concurrency)：</strong> 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b343cfd84444db978f820008487cab~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b343cfd84444db978f820008487cab~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>并行是两个队列<strong>同时</strong>使用两台咖啡机</li><li>并发是两个队列<strong>交替</strong>使用一台咖啡机</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d45916d44f043afaa1ca4359783accc~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d45916d44f043afaa1ca4359783accc~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="11-1-2-Go语言并发优势"><a href="#11-1-2-Go语言并发优势" class="headerlink" title="11.1.2 Go语言并发优势"></a><strong>11.1.2 Go语言并发优势</strong></h3><p>有人把Go比作21世纪的C语言，第一是因为Go语言设计简单，第二，21世纪最重要的就是并行程序设计，而Go从语言层面就支持了并行。同时，并发程序的内存管理有时候是非常复杂的，而Go语言提供了自动垃圾回收机制。</p><p>Go语言为并发编程而内置的上层API基于CSP(communicating sequential processes, 顺序通信进程)模型。这就意味着显式锁都是可以避免的，因为Go语言通过相册安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p><p>一般情况下，一个普通的桌面计算机跑十几二十个线程就有点负载过大了，但是同样这台机器却可以轻松地让成百上千甚至过万个goroutine进行资源竞争。</p><h1 id="11-2-goroutine"><a href="#11-2-goroutine" class="headerlink" title="11.2 goroutine"></a><strong>11.2 goroutine</strong></h1><h3 id="11-2-1-goroutine是什么"><a href="#11-2-1-goroutine是什么" class="headerlink" title="11.2.1 goroutine是什么"></a><strong>11.2.1 goroutine是什么</strong></h3><p>goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p><h3 id="11-2-2-创建goroutine"><a href="#11-2-2-创建goroutine" class="headerlink" title="11.2.2 创建goroutine"></a><strong>11.2.2 创建goroutine</strong></h3><p>只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。开发⼈员无需了解任何执⾏细节，调度器会自动将其安排到合适的系统线程上执行。</p><p>在并发编程里，我们通常想讲一个过程切分成几块，然后让每个goroutine各自负责一块工作。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line"> </span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">//main goroutine 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a1d79d8750432ca51256f007e1a98b~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a1d79d8750432ca51256f007e1a98b~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="11-2-3-主goroutine先退出"><a href="#11-2-3-主goroutine先退出" class="headerlink" title="11.2.3 主goroutine先退出"></a><strong>11.2.3 主goroutine先退出</strong></h3><p>主goroutine退出后，其它的工作goroutine也会自动退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76707b325c684544820d0eb4558efa5d~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76707b325c684544820d0eb4558efa5d~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="读写操作的重新排序"><a href="#读写操作的重新排序" class="headerlink" title="读写操作的重新排序"></a><strong>读写操作的重新排序</strong></h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> u1()    <span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line">    <span class="keyword">go</span> u2()    </span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d19e0492068444b8b618f3a09c85c42~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d19e0492068444b8b618f3a09c85c42~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p><h3 id="11-2-4-runtime包"><a href="#11-2-4-runtime包" class="headerlink" title="11.2.4 runtime包"></a><strong>11.2.4 runtime包</strong></h3><h3 id="11-2-4-1-Gosched-goroutine-优先调度"><a href="#11-2-4-1-Gosched-goroutine-优先调度" class="headerlink" title="11.2.4.1 Gosched goroutine 优先调度"></a><strong>11.2.4.1 Gosched</strong> goroutine 优先调度</h3><p>runtime.Gosched() 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p><p>这就像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched() <span class="comment">//import &quot;runtime&quot;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            屏蔽runtime.Gosched()运行结果如下：</span></span><br><span class="line"><span class="comment">                hello</span></span><br><span class="line"><span class="comment">                hello</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">            没有runtime.Gosched()运行结果如下：</span></span><br><span class="line"><span class="comment">                world</span></span><br><span class="line"><span class="comment">                world</span></span><br><span class="line"><span class="comment">                hello</span></span><br><span class="line"><span class="comment">                hello</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先调度"><a href="#优先调度" class="headerlink" title="优先调度"></a><strong>优先调度</strong></h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p><p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)    <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5504e7964aeb46c8b61d80192461f6ae~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5504e7964aeb46c8b61d80192461f6ae~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43bd1b689d9443c282ee28b4a11a1b8b~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43bd1b689d9443c282ee28b4a11a1b8b~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="11-2-4-2-Goexit"><a href="#11-2-4-2-Goexit" class="headerlink" title="11.2.4.2 Goexit"></a><strong>11.2.4.2 Goexit</strong></h3><p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            runtime.Goexit() <span class="comment">// 终止当前 goroutine, import &quot;runtime&quot;</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">        &#125;()</span><br><span class="line"> </span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;() <span class="comment">//别忘了()</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//死循环，目的不让主goroutine结束</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727268894b5e44978a934c89c24b48d7~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727268894b5e44978a934c89c24b48d7~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="11-2-4-3-GOMAXPROCS"><a href="#11-2-4-3-GOMAXPROCS" class="headerlink" title="11.2.4.3 GOMAXPROCS"></a><strong>11.2.4.3 GOMAXPROCS</strong></h3><p>调用 runtime.GOMAXPROCS() 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//n := runtime.GOMAXPROCS(1) //打印结果：111111111111111111110000000000000000000011111...</span></span><br><span class="line">    n := runtime.GOMAXPROCS(<span class="number">2</span>)     <span class="comment">//打印结果：010101010101010101011001100101011010010100110...</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;n = %d\n&quot;</span>, n)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> fmt.Print(<span class="number">0</span>)</span><br><span class="line">        fmt.Print(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一次执行(runtime.GOMAXPROCS(1))时，最多同时只能有一个goroutine被执行。所以会打印很多1。</p><p>过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。</p><p>在第二次执行(runtime.GOMAXPROCS(2))时，我们使用了两个CPU，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。</p><h1 id="11-3-channel"><a href="#11-3-channel" class="headerlink" title="11.3 channel"></a><strong>11.3 channel</strong></h1><p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</p><p>引⽤类型 channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</p><h3 id="11-3-1-channel类型"><a href="#11-3-1-channel类型" class="headerlink" title="11.3.1 channel类型"></a><strong>11.3.1 channel类型</strong></h3><p>和map类似，channel也一个对应make创建的底层数据结构的引用。</p><p>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者何被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p><p>定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make()函数来创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">//等价于make(chan Type, 0)</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity)</span><br></pre></td></tr></table></figure><p>当 capacity= 0 时，channel 是无缓冲阻塞读写的，当capacity&gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。</p><p>channel通过操作符&lt;-来接收和发送数据，发送和接收数据语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel &lt;- value      <span class="comment">//发送value到channel</span></span><br><span class="line">&lt;-channel             <span class="comment">//接收并将其丢弃</span></span><br><span class="line">x := &lt;-channel        <span class="comment">//从channel中接收数据，并赋值给x</span></span><br><span class="line">x, ok := &lt;-channel    <span class="comment">//功能同上，同时检查通道是否已关闭或者是否为空</span></span><br></pre></td></tr></table></figure><p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;子协程结束&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        fmt.Println(<span class="string">&quot;子协程正在运行……&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        c &lt;- <span class="number">666</span> <span class="comment">//666发送到c</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    num := &lt;-c <span class="comment">//从c中接收数据，并赋值给num</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main协程结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><h3 id="11-3-2-无缓冲的channel"><a href="#11-3-2-无缓冲的channel" class="headerlink" title="11.3.2 无缓冲的channel"></a><strong>11.3.2 无缓冲的channel</strong></h3><p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。</p><p>这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。</p><p>这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p><p>下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6f3825bc7dc4828a4321e9f351a3c8d~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6f3825bc7dc4828a4321e9f351a3c8d~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执行发送或者接收。</li><li>在第 2 步，左侧的 goroutine 将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine 会在通道中被锁住，直到交换完成。</li><li>在第 3 步，右侧的 goroutine 将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。</li><li>在第 4 步和第 5 步，进行交换，并最终，在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做别的事情了。</li></ul><p>无缓冲的channel创建格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">//等价于make(chan Type, 0)</span></span><br></pre></td></tr></table></figure><p>如果没有指定缓冲区容量，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//无缓冲的通道</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;len(c)=%d, cap(c)=%d\n&quot;</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;子协程结束&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">            fmt.Printf(<span class="string">&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;</span>, i, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">//延时2s</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        num := &lt;-c <span class="comment">//从c中接收数据，并赋值给num</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;main协程结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aab223ccc9d841b79b26ad99679d889d~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aab223ccc9d841b79b26ad99679d889d~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="11-3-3-有缓冲的channel"><a href="#11-3-3-有缓冲的channel" class="headerlink" title="11.3.3 有缓冲的channel"></a><strong>11.3.3 有缓冲的channel</strong></h3><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。</p><p>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p><p>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p><p>示例图如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b022096ccd814837aa37366b66a25b43~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b022096ccd814837aa37366b66a25b43~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>在第 1 步，右侧的 goroutine 正在从通道接收一个值。</li><li>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。</li><li>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的两个操作既不是同步的，也不会互相阻塞。</li><li>最后，在第 4 步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</li></ul><p>有缓冲的channel创建格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity)</span><br></pre></td></tr></table></figure><p>如果给定了一个缓冲区容量，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//带缓冲的通道</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;len(c)=%d, cap(c)=%d\n&quot;</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;子协程结束&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">            fmt.Printf(<span class="string">&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;</span>, i, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">//延时2s</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        num := &lt;-c <span class="comment">//从c中接收数据，并赋值给num</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main协程结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad2ba586726146a39c707d6064d76f45~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad2ba586726146a39c707d6064d76f45~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9791572ce1024e9f89c441a1265466b9~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="11-3-4-range和close"><a href="#11-3-4-range和close" class="headerlink" title="11.3.4 range和close"></a><strong>11.3.4 range和close</strong></h3><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把 close(c) 注释掉，程序会一直阻塞在 if data, ok := &lt;-c; ok 那一行</span></span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//ok为true说明channel没有关闭，为false说明管道已经关闭</span></span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff31d2fbdff4b5db9bfb26725643ca1~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff31d2fbdff4b5db9bfb26725643ca1~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6553d977b4314ec2864af811bcfb274c~tplv-k3u1fbpfcp-zoom-1.image"></p><p>注意点：</p><ul><li>  l channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的，才去关闭channel；</li><li>  l 关闭channel后，无法向channel 再发送数据(引发 panic 错误后导致接收立即返回零值)；</li><li>  l 关闭channel后，可以继续向channel接收数据；</li><li>  l 对于nil channel，无论收发都会被阻塞。</li></ul><p>可以使用 range 来迭代不断操作channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把 close(c) 注释掉，程序会一直阻塞在 for data := range c 那一行</span></span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-5-单方向的channel"><a href="#11-3-5-单方向的channel" class="headerlink" title="11.3.5 单方向的channel"></a><strong>11.3.5 单方向的channel</strong></h3><p>默认情况下，通道是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。</p><p>但是，我们经常见一个通道作为参数进行传递而值希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。</p><p>单向channel变量的声明非常简单，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>       <span class="comment">// ch1是一个正常的channel，不是单向的</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="keyword">float64</span> <span class="comment">// ch2是单向channel，只用于写float64数据</span></span><br><span class="line"><span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>     <span class="comment">// ch3是单向channel，只用于读取int数据</span></span><br></pre></td></tr></table></figure><p>l chan&lt;- 表示数据进入管道，要把数据写进管道，对于调用者就是输出。</p><p>l &lt;-chan 表示数据从管道出来，对于调用者就是得到管道的数据，当然就是输入。</p><p>可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel 转换为普通 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = c <span class="comment">// send-only</span></span><br><span class="line"><span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = c <span class="comment">// receive-only</span></span><br><span class="line">send &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment">//&lt;-send //invalid operation: &lt;-send (receive from send-only type chan&lt;- int)</span></span><br><span class="line">&lt;-recv</span><br><span class="line"><span class="comment">//recv &lt;- 2 //invalid operation: recv &lt;- 2 (send to receive-only type &lt;-chan int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能将单向 channel 转换为普通 channel</span></span><br><span class="line">d1 := (<span class="keyword">chan</span> <span class="keyword">int</span>)(send) <span class="comment">//cannot convert send (type chan&lt;- int) to type chan int</span></span><br><span class="line">d2 := (<span class="keyword">chan</span> <span class="keyword">int</span>)(recv) <span class="comment">//cannot convert recv (type &lt;-chan int) to type chan int</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   chan&lt;- //只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        out &lt;- i <span class="comment">//如果对方不读 会阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//   &lt;-chan //只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//   chan   //读写</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> counter(c) <span class="comment">//生产者</span></span><br><span class="line">    printer(c)    <span class="comment">//消费者</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-6-定时器"><a href="#11-3-6-定时器" class="headerlink" title="11.3.6 定时器"></a><strong>11.3.6 定时器</strong></h3><h3 id="11-3-6-1-Timer"><a href="#11-3-6-1-Timer" class="headerlink" title="11.3.6.1 Timer"></a><strong>11.3.6.1 Timer</strong></h3><p>Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个channel，在将来的那个时间那个channel提供了一个时间值。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建定时器，2秒后，定时器就会向自己的C字节发送一个time.Time类型的元素值</span></span><br><span class="line">    timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">    t1 := time.Now() <span class="comment">//当前时间</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;t1: %v\n&quot;</span>, t1)</span><br><span class="line"> </span><br><span class="line">    t2 := &lt;-timer1.C</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t2: %v\n&quot;</span>, t2)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果只是想单纯的等待的话，可以使用 time.Sleep 来实现</span></span><br><span class="line">    timer2 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">    &lt;-timer2.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;2s后&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;再一次2s后&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    &lt;-time.After(time.Second * <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;再再一次2s后&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    timer3 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-timer3.C</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 3 expired&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    stop := timer3.Stop() <span class="comment">//停止定时器</span></span><br><span class="line">    <span class="keyword">if</span> stop &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 3 stopped&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;before&quot;</span>)</span><br><span class="line">    timer4 := time.NewTimer(time.Second * <span class="number">5</span>) <span class="comment">//原来设置3s</span></span><br><span class="line">    timer4.Reset(time.Second * <span class="number">1</span>)            <span class="comment">//重新设置时间</span></span><br><span class="line">    &lt;-timer4.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;after&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-6-2-Ticker"><a href="#11-3-6-2-Ticker" class="headerlink" title="11.3.6.2 Ticker"></a><strong>11.3.6.2 Ticker</strong></h3><p>Ticker是一个定时触发的计时器，它会以一个间隔(interval)往channel发送一个事件(当前时间)，而channel的接收者可以以固定的时间间隔从channel中读取事件。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间)</span></span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123; <span class="comment">//循环</span></span><br><span class="line">            &lt;-ticker.C</span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                ticker.Stop() <span class="comment">//停止定时器</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;() <span class="comment">//别忘了()</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//死循环，特地不让main goroutine结束</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-4-select"><a href="#11-4-select" class="headerlink" title="11.4 select"></a><strong>11.4 select</strong></h1><h3 id="11-4-1-select作用"><a href="#11-4-1-select作用" class="headerlink" title="11.4.1 select作用"></a><strong>11.4.1 select作用</strong></h3><p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。</p><p>select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。</p><p>与switch语句可以选择任何可使用相等比较的条件相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">    <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。</p><p>如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。</p><p>如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：</p><ul><li>  如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。</li><li>  如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。</li></ul><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b9c8bdf557b478590b717da29b15026~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b9c8bdf557b478590b717da29b15026~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/220e5d4c2ac04abe9a9cd4743eee32b3~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="11-4-2-超时"><a href="#11-4-2-超时" class="headerlink" title="11.4.2 超时"></a><strong>11.4.2 超时</strong></h3><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">                fmt.Println(v)</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                o &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//c &lt;- 666 // 注释掉，引发 timeout</span></span><br><span class="line">    &lt;-o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】Go语言文本处理</title>
      <link href="/202107/28598/"/>
      <url>/202107/28598/</url>
      
        <content type="html"><![CDATA[<h1 id="10-1-字符串处理"><a href="#10-1-字符串处理" class="headerlink" title="10.1 字符串处理"></a><strong>10.1 字符串处理</strong></h1><p>字符串在开发中经常用到，包括用户的输入，数据库读取的数据等，我们经常需要对字符串进行分割、连接、转换等操作，我们可以通过Go标准库中的strings和strconv两个包中的函数进行相应的操作。</p><h3 id="10-1-1-字符串操作"><a href="#10-1-1-字符串操作" class="headerlink" title="10.1.1 字符串操作"></a><strong>10.1.1 字符串操作</strong></h3><p>下面这些函数来自于strings包，这里介绍一些我平常经常用到的函数，更详细的请参考官方的文档。</p><h3 id="10-1-1-1-Contains-子串查询"><a href="#10-1-1-1-Contains-子串查询" class="headerlink" title="10.1.1.1 Contains 子串查询"></a><strong>10.1.1.1 Contains 子串查询</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line">功能：字符串s中是否包含substr，返回<span class="keyword">bool</span>值</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">fmt.Println(strings.Contains(<span class="string">&quot;seafood&quot;</span>, <span class="string">&quot;foo&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="10-1-1-2-Join-数组拼接成字符串"><a href="#10-1-1-2-Join-数组拼接成字符串" class="headerlink" title="10.1.1.2 Join 数组拼接成字符串"></a><strong>10.1.1.2 Join 数组拼接成字符串</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">功能：字符串链接，把slice a通过sep链接起来</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>&#125;</span><br><span class="line">fmt.Println(strings.Join(s, <span class="string">&quot;, &quot;</span>))</span><br><span class="line"><span class="comment">//运行结果:foo, bar, baz</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-3-Index"><a href="#10-1-1-3-Index" class="headerlink" title="10.1.1.3 Index"></a><strong>10.1.1.3 Index</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line">功能：在字符串s中查找sep所在的位置，返回位置值，找不到返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;ken&quot;</span>))</span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;dmr&quot;</span>))</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"><span class="comment">//    4</span></span><br><span class="line"><span class="comment">//    -1</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-4-Repeat"><a href="#10-1-1-4-Repeat" class="headerlink" title="10.1.1.4 Repeat"></a><strong>10.1.1.4 Repeat</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line">功能：重复s字符串count次，最后返回重复的字符串</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">fmt.Println(<span class="string">&quot;ba&quot;</span> + strings.Repeat(<span class="string">&quot;na&quot;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">//运行结果:banana</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-5-Replace"><a href="#10-1-1-5-Replace" class="headerlink" title="10.1.1.5 Replace"></a><strong>10.1.1.5 Replace</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line">功能：在s字符串中，把old字符串替换为<span class="built_in">new</span>字符串，n表示替换的次数，小于<span class="number">0</span>表示全部替换</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;ky&quot;</span>, <span class="number">2</span>))</span><br><span class="line">    fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="comment">//运行结果:</span></span><br><span class="line">    <span class="comment">//oinky oinky oink</span></span><br><span class="line">    <span class="comment">//moo moo moo</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-6-Split"><a href="#10-1-1-6-Split" class="headerlink" title="10.1.1.6 Split"></a><strong>10.1.1.6 Split</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line">功能：把s字符串按照sep分割，返回slice</span><br><span class="line"> </span><br><span class="line">示例代码：</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a man a plan a canal panama&quot;</span>, <span class="string">&quot;a &quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot; xyz &quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Bernardo O&#x27;Higgins&quot;</span>))</span><br><span class="line">    <span class="comment">//运行结果:</span></span><br><span class="line">    <span class="comment">//[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span></span><br><span class="line">    <span class="comment">//[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</span></span><br><span class="line">    <span class="comment">//[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</span></span><br><span class="line">    <span class="comment">//[&quot;&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-7-Trim"><a href="#10-1-1-7-Trim" class="headerlink" title="10.1.1.7 Trim"></a><strong>10.1.1.7 Trim</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">功能：在s字符串的头部和尾部去除cutset指定的字符串</span><br><span class="line"> </span><br><span class="line">示例代码：</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%q]&quot;</span>, strings.Trim(<span class="string">&quot; !!! Achtung !!! &quot;</span>, <span class="string">&quot;! &quot;</span>))</span><br><span class="line">    <span class="comment">//运行结果:[&quot;Achtung&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-8-Fields"><a href="#10-1-1-8-Fields" class="headerlink" title="10.1.1.8 Fields"></a><strong>10.1.1.8 Fields</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line">功能：去除s字符串的空格符，并且按照空格分割返回slice</span><br><span class="line"> </span><br><span class="line">示例代码：</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>, strings.Fields(<span class="string">&quot;  foo bar  baz   &quot;</span>))</span><br><span class="line">    <span class="comment">//运行结果:Fields are: [&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="10-1-2-字符串转换"><a href="#10-1-2-字符串转换" class="headerlink" title="10.1.2 字符串转换"></a><strong>10.1.2 字符串转换</strong></h3><p>字符串转化的函数在strconv中，如下也只是列出一些常用的。</p><h3 id="10-1-2-1-Append"><a href="#10-1-2-1-Append" class="headerlink" title="10.1.2.1 Append"></a><strong>10.1.2.1 Append</strong></h3><p>Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line">    str := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    str = strconv.AppendInt(str, <span class="number">4567</span>, <span class="number">10</span>) <span class="comment">//以10进制方式追加</span></span><br><span class="line">    str = strconv.AppendBool(str, <span class="literal">false</span>)</span><br><span class="line">    str = strconv.AppendQuote(str, <span class="string">&quot;abcdefg&quot;</span>)</span><br><span class="line">    str = strconv.AppendQuoteRune(str, <span class="string">&#x27;单&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(str)) <span class="comment">//4567false&quot;abcdefg&quot;&#x27;单&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="10-1-2-2-Format"><a href="#10-1-2-2-Format" class="headerlink" title="10.1.2.2 Format"></a><strong>10.1.2.2 Format</strong></h3><p>Format 系列函数把其他类型的转换为字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line">    a := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">    b := strconv.FormatInt(<span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">    c := strconv.FormatUint(<span class="number">12345</span>, <span class="number">10</span>)</span><br><span class="line">    d := strconv.Itoa(<span class="number">1023</span>)</span><br><span class="line"> </span><br><span class="line">    fmt.Println(a, b, c, d) <span class="comment">//false 1234 12345 1023</span></span><br></pre></td></tr></table></figure><h3 id="10-1-2-3-Parse"><a href="#10-1-2-3-Parse" class="headerlink" title="10.1.2.3 Parse"></a><strong>10.1.2.3 Parse</strong></h3><p>Parse 系列函数把字符串转换为其他类型。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, err := strconv.ParseBool(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    b, err := strconv.ParseFloat(<span class="string">&quot;123.23&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    c, err := strconv.ParseInt(<span class="string">&quot;1234&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    d, err := strconv.ParseUint(<span class="string">&quot;12345&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    e, err := strconv.Atoi(<span class="string">&quot;1023&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    fmt.Println(a, b, c, d, e) <span class="comment">//false 123.23 1234 12345 1023</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-2-正则表达式"><a href="#10-2-正则表达式" class="headerlink" title="10.2 正则表达式"></a><strong>10.2 正则表达式</strong></h1><p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何你想要得到的字符组合。</p><p>Go语言通过regexp标准包为正则表达式提供了官方支持，如果你已经使用过其他编程语言提供的正则相关功能，那么你应该对Go语言版本的不会太陌生，但是它们之间也有一些小的差异，因为Go实现的是RE2标准，除了\C，详细的语法描述参考：<a href="http://code.google.com/p/re2/wiki/Syntax"></a><a href="http://code.google.com/p/re2/wiki/Syntax">http://code.google.com/p/re2/wiki/Syntax</a></p><p>其实字符串处理我们可以使用strings包来进行搜索(Contains、Index)、替换(Replace)和解析(Split、Join)等操作，但是这些都是简单的字符串操作，他们的搜索都是大小写敏感，而且固定的字符串，如果我们需要匹配可变的那种就没办法实现了，当然如果strings包能解决你的问题，那么就尽量使用它来解决。因为他们足够简单、而且性能和可读性都会比正则好。</p><h1 id="10-3-JSON处理"><a href="#10-3-JSON处理" class="headerlink" title="10.3 JSON处理"></a><strong>10.3 JSON处理</strong></h1><p>JSON （JavaScript Object Notation）是一种比XML更轻量级的数据交换格式，在易于人们阅读和编写的同时，也易于程序解析和生成。尽管JSON是JavaScript的一个子集，但JSON采用完全独立于编程语言的文本格式，且表现为键/值对集合的文本描述形式（类似一些编程语言中的字典结构），这使它成为较为理想的、跨平台、跨语言的数据交换语言。</p><p>开发者可以用 JSON 传输简单的字符串、数字、布尔值，也可以传输一个数组，或者一个更复杂的复合结构。在 Web 开发领域中， JSON被广泛应用于 Web 服务端程序和客户端之间的数据通信。</p><p>Go语言内建对JSON的支持。使用Go语言内置的encoding/json 标准库，开发者可以轻松使用Go程序生成和解析JSON格式的数据。</p><p>JSON官方网站：<a href="http://www.json.org/"></a><a href="http://www.json.org/">http://www.json.org/</a></p><p>在线格式化：<a href="http://www.json.cn/"></a><a href="http://www.json.cn/">http://www.json.cn/</a></p><h3 id="10-3-1-编码JSON"><a href="#10-3-1-编码JSON" class="headerlink" title="10.3.1 编码JSON"></a><strong>10.3.1 编码JSON</strong></h3><h3 id="10-3-1-1-通过结构体生成JSON"><a href="#10-3-1-1-通过结构体生成JSON" class="headerlink" title="10.3.1.1 通过结构体生成JSON"></a><strong>10.3.1.1 通过结构体生成JSON</strong></h3><p>使用json.Marshal()函数可以对一组数据进行JSON格式的编码。 json.Marshal()函数的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>还有一个格式化输出：</p><p>// MarshalIndent 很像 Marshal，只是用缩进对输出进行格式化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><ol><li> 编码JSON</li></ol><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> IT <span class="keyword">struct</span> &#123;</span><br><span class="line">    Company  <span class="keyword">string</span></span><br><span class="line">    Subjects []<span class="keyword">string</span></span><br><span class="line">    IsOk     <span class="keyword">bool</span></span><br><span class="line">    Price    <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := IT&#123;<span class="string">&quot;itcast&quot;</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Test&quot;</span>&#125;, <span class="literal">true</span>, <span class="number">666.666</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成一段JSON格式的文本</span></span><br><span class="line">    <span class="comment">//如果编码成功， err 将赋于零值 nil，变量b 将会是一个进行JSON格式化之后的[]byte类型</span></span><br><span class="line">    <span class="comment">//b, err := json.Marshal(t1)</span></span><br><span class="line">    <span class="comment">//输出结果：&#123;&quot;Company&quot;:&quot;itcast&quot;,&quot;Subjects&quot;:[&quot;Go&quot;,&quot;C++&quot;,&quot;Python&quot;,&quot;Test&quot;],&quot;IsOk&quot;:true,&quot;Price&quot;:666.666&#125;</span></span><br><span class="line"> </span><br><span class="line">    b, err := json.MarshalIndent(t1, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            &quot;Company&quot;: &quot;itcast&quot;,</span></span><br><span class="line"><span class="comment">            &quot;Subjects&quot;: [</span></span><br><span class="line"><span class="comment">                &quot;Go&quot;,</span></span><br><span class="line"><span class="comment">                &quot;C++&quot;,</span></span><br><span class="line"><span class="comment">                &quot;Python&quot;,</span></span><br><span class="line"><span class="comment">                &quot;Test&quot;</span></span><br><span class="line"><span class="comment">            ],</span></span><br><span class="line"><span class="comment">            &quot;IsOk&quot;: true,</span></span><br><span class="line"><span class="comment">            &quot;Price&quot;: 666.666</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> struct tag</li></ol><p>输出字段名的首字母都是大写的，如果你想用小写的首字母怎么办呢？把结构体的字段名改成首字母小写的？</p><p>JSON输出的时候必须注意:</p><blockquote><p>只有导出的字段(首字母是大写)才会被输出，如果修改字段名，那么就会发现什么都不会输出，所以必须通过struct tag定义来实现。</p></blockquote><p>针对JSON的输出，我们在定义struct tag的时候需要注意的几点是：</p><ul><li>  字段的tag是”-“，那么这个字段不会输出到JSON</li><li>  tag中带有自定义名称，那么这个自定义名称会出现在JSON的字段名中</li><li>  tag中如果带有”omitempty”选项，那么如果该字段值为空，就不会输出到JSON串中</li><li>  如果字段类型是bool, string, int, int64等，而tag中带有”,string”选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串</li></ul><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IT <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//Company不会导出到JSON中</span></span><br><span class="line">    Company <span class="keyword">string</span> <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Subjects 的值会进行二次JSON编码</span></span><br><span class="line">    Subjects []<span class="keyword">string</span> <span class="string">`json:&quot;subjects&quot;`</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//转换为字符串，再输出</span></span><br><span class="line">    IsOk <span class="keyword">bool</span> <span class="string">`json:&quot;,string&quot;`</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果 Price 为空，则不输出到JSON串中</span></span><br><span class="line">    Price <span class="keyword">float64</span> <span class="string">`json:&quot;price, omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := IT&#123;Company: <span class="string">&quot;itcast&quot;</span>, Subjects: []<span class="keyword">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Test&quot;</span>&#125;, IsOk: <span class="literal">true</span>&#125;</span><br><span class="line"> </span><br><span class="line">    b, err := json.Marshal(t1)</span><br><span class="line">    <span class="comment">//json.MarshalIndent(t1, &quot;&quot;, &quot;    &quot;)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">    <span class="comment">//输出结果：&#123;&quot;subjects&quot;:[&quot;Go&quot;,&quot;C++&quot;,&quot;Python&quot;,&quot;Test&quot;],&quot;IsOk&quot;:&quot;true&quot;,&quot;price&quot;:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-1-2-通过map生成JSON"><a href="#10-3-1-2-通过map生成JSON" class="headerlink" title="10.3.1.2 通过map生成JSON"></a><strong>10.3.1.2 通过map生成JSON</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个保存键值对的映射</span></span><br><span class="line">    t1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    t1[<span class="string">&quot;company&quot;</span>] = <span class="string">&quot;itcast&quot;</span></span><br><span class="line">    t1[<span class="string">&quot;subjects &quot;</span>] = []<span class="keyword">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Test&quot;</span>&#125;</span><br><span class="line">    t1[<span class="string">&quot;isok&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    t1[<span class="string">&quot;price&quot;</span>] = <span class="number">666.666</span></span><br><span class="line"> </span><br><span class="line">    b, err := json.Marshal(t1)</span><br><span class="line">    <span class="comment">//json.MarshalIndent(t1, &quot;&quot;, &quot;    &quot;)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">    <span class="comment">//输出结果：&#123;&quot;company&quot;:&quot;itcast&quot;,&quot;isok&quot;:true,&quot;price&quot;:666.666,&quot;subjects &quot;:[&quot;Go&quot;,&quot;C++&quot;,&quot;Python&quot;,&quot;Test&quot;]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="10-3-2-解码JSON"><a href="#10-3-2-解码JSON" class="headerlink" title="10.3.2 解码JSON"></a><strong>10.3.2 解码JSON</strong></h3><p>可以使用json.Unmarshal()函数将JSON格式的文本解码为Go里面预期的数据结构。</p><p>json.Unmarshal()函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Unmarshal(data []byte, v interface&#123;&#125;) error</span><br></pre></td></tr></table></figure><p>该函数的第一个参数是输入，即JSON格式的文本（比特序列），第二个参数表示目标输出容器，用于存放解码后的值。</p><h3 id="10-3-2-1-解析到结构体"><a href="#10-3-2-1-解析到结构体" class="headerlink" title="10.3.2.1 解析到结构体"></a><strong>10.3.2.1 解析到结构体</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IT <span class="keyword">struct</span> &#123;</span><br><span class="line">    Company  <span class="keyword">string</span>   <span class="string">`json:&quot;company&quot;`</span></span><br><span class="line">    Subjects []<span class="keyword">string</span> <span class="string">`json:&quot;subjects&quot;`</span></span><br><span class="line">    IsOk     <span class="keyword">bool</span>     <span class="string">`json:&quot;isok&quot;`</span></span><br><span class="line">    Price    <span class="keyword">float64</span>  <span class="string">`json:&quot;price&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">    &quot;company&quot;: &quot;itcast&quot;,</span></span><br><span class="line"><span class="string">    &quot;subjects&quot;: [</span></span><br><span class="line"><span class="string">        &quot;Go&quot;,</span></span><br><span class="line"><span class="string">        &quot;C++&quot;,</span></span><br><span class="line"><span class="string">        &quot;Python&quot;,</span></span><br><span class="line"><span class="string">        &quot;Test&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;isok&quot;: true,</span></span><br><span class="line"><span class="string">    &quot;price&quot;: 666.666</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> t IT</span><br><span class="line">    err := json.Unmarshal(b, &amp;t)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">    <span class="comment">//运行结果：&#123;itcast [Go C++ Python Test] true 666.666&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//只想要Subjects字段</span></span><br><span class="line">    <span class="keyword">type</span> IT2 <span class="keyword">struct</span> &#123;</span><br><span class="line">        Subjects []<span class="keyword">string</span> <span class="string">`json:&quot;subjects&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> t2 IT2</span><br><span class="line">    err = json.Unmarshal(b, &amp;t2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(t2)</span><br><span class="line">    <span class="comment">//运行结果：&#123;[Go C++ Python Test]&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-2-2-解析到interface"><a href="#10-3-2-2-解析到interface" class="headerlink" title="10.3.2.2 解析到interface"></a><strong>10.3.2.2 解析到interface</strong></h3><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">    &quot;company&quot;: &quot;itcast&quot;,</span></span><br><span class="line"><span class="string">    &quot;subjects&quot;: [</span></span><br><span class="line"><span class="string">        &quot;Go&quot;,</span></span><br><span class="line"><span class="string">        &quot;C++&quot;,</span></span><br><span class="line"><span class="string">        &quot;Python&quot;,</span></span><br><span class="line"><span class="string">        &quot;Test&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;isok&quot;: true,</span></span><br><span class="line"><span class="string">    &quot;price&quot;: 666.666</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err := json.Unmarshal(b, &amp;t)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(t)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用断言判断类型</span></span><br><span class="line">    m := t.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Println(k, <span class="string">&quot;is string&quot;</span>, vv)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">            fmt.Println(k, <span class="string">&quot;is int&quot;</span>, vv)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Println(k, <span class="string">&quot;is float64&quot;</span>, vv)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Println(k, <span class="string">&quot;is bool&quot;</span>, vv)</span><br><span class="line">        <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">            fmt.Println(k, <span class="string">&quot;is an array:&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">                fmt.Println(i, u)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(k, <span class="string">&quot;is of a type I don&#x27;t know how to handle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-4-文件操作"><a href="#10-4-文件操作" class="headerlink" title="10.4 文件操作"></a><strong>10.4 文件操作</strong></h1><h3 id="10-4-1-相关api介绍"><a href="#10-4-1-相关api介绍" class="headerlink" title="10.4.1 相关api介绍"></a><strong>10.4.1 相关api介绍</strong></h3><h3 id="10-4-1-1-建立与打开文件"><a href="#10-4-1-1-建立与打开文件" class="headerlink" title="10.4.1.1 建立与打开文件"></a><strong>10.4.1.1 建立与打开文件</strong></h3><p>新建文件可以通过如下两个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line">根据提供的文件名创建新的文件，返回一个文件对象，默认权限是<span class="number">0666</span>的文件，返回的文件对象是可读写的。</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span></span><br><span class="line">根据文件描述符创建相应的文件，返回一个文件对象</span><br></pre></td></tr></table></figure><p>通过如下两个方法来打开文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line">该方法打开一个名称为name的文件，但是是只读方式，内部实现其实调用了OpenFile。</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm <span class="keyword">uint32</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line">打开名称为name的文件，flag是打开的方式，只读、读写等，perm是权限</span><br></pre></td></tr></table></figure><h3 id="10-4-1-2-写文件"><a href="#10-4-1-2-写文件" class="headerlink" title="10.4.1.2 写文件"></a><strong>10.4.1.2 写文件</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line">写入<span class="keyword">byte</span>类型的信息到文件</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line">在指定位置开始写入<span class="keyword">byte</span>类型的信息</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line">写入<span class="keyword">string</span>信息到文件</span><br></pre></td></tr></table></figure><h3 id="10-4-1-3-读文件"><a href="#10-4-1-3-读文件" class="headerlink" title="10.4.1.3 读文件"></a><strong>10.4.1.3 读文件</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line">读取数据到b中</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line">从off开始读取数据到b中</span><br></pre></td></tr></table></figure><h3 id="10-4-1-4-删除文件"><a href="#10-4-1-4-删除文件" class="headerlink" title="10.4.1.4 删除文件"></a><strong>10.4.1.4 删除文件</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Error</span></span></span><br><span class="line">调用该函数就可以删除文件名为name的文件</span><br></pre></td></tr></table></figure><h3 id="10-4-2-示例代码"><a href="#10-4-2-示例代码" class="headerlink" title="10.4.2 示例代码"></a><strong>10.4.2 示例代码</strong></h3><h3 id="10-4-2-1-写文件"><a href="#10-4-2-1-写文件" class="headerlink" title="10.4.2.1 写文件"></a><strong>10.4.2.1 写文件</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.Create(<span class="string">&quot;./xxx.txt&quot;</span>) <span class="comment">//新建文件</span></span><br><span class="line">    <span class="comment">//fout, err := os.OpenFile(&quot;./xxx.txt&quot;, os.O_CREATE, 0666)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">defer</span> fout.Close() <span class="comment">//main函数结束前， 关闭文件</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        outstr := fmt.Sprintf(<span class="string">&quot;%s:%d\n&quot;</span>, <span class="string">&quot;Hello go&quot;</span>, i)</span><br><span class="line">        fout.WriteString(outstr)     <span class="comment">//写入string信息到文件</span></span><br><span class="line">        fout.Write([]<span class="keyword">byte</span>(<span class="string">&quot;abcd\n&quot;</span>)) <span class="comment">//写入byte类型的信息到文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-2-2-读文件"><a href="#10-4-2-2-读文件" class="headerlink" title="10.4.2.2 读文件"></a><strong>10.4.2.2 读文件</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fin, err := os.Open(<span class="string">&quot;./xxx.txt&quot;</span>) <span class="comment">//打开文件</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fin.Close()</span><br><span class="line"> </span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>) <span class="comment">//开辟1024个字节的slice作为缓冲</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, _ := fin.Read(buf) <span class="comment">//读文件</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;           <span class="comment">//0表示已经到文件结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(buf)) <span class="comment">//输出读取的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-3-案例：拷贝文件"><a href="#10-4-3-案例：拷贝文件" class="headerlink" title="10.4.3 案例：拷贝文件"></a><strong>10.4.3 案例：拷贝文件</strong></h3><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    args := os.Args <span class="comment">//获取用户输入的所有参数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果用户没有输入,或参数个数不够,则调用该函数提示用户</span></span><br><span class="line">    <span class="keyword">if</span> args == <span class="literal">nil</span> || <span class="built_in">len</span>(args) != <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;useage : xxx srcFile dstFile&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    srcPath := args[<span class="number">1</span>] <span class="comment">//获取输入的第一个参数</span></span><br><span class="line">    dstPath := args[<span class="number">2</span>] <span class="comment">//获取输入的第二个参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;srcPath = %s, dstPath = %s\n&quot;</span>, srcPath, dstPath)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> srcPath == dstPath &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;源文件和目的文件名字不能相同&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    srcFile, err1 := os.Open(srcPath) <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err1)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dstFile, err2 := os.Create(dstPath) <span class="comment">//创建目的文件</span></span><br><span class="line">    <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err2)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>) <span class="comment">//切片缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//从源文件读取内容，n为读取文件内容的长度</span></span><br><span class="line">        n, err := srcFile.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;文件处理完毕&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//切片截取</span></span><br><span class="line">        tmp := buf[:n]</span><br><span class="line">        <span class="comment">//把读取的内容写入到目的文件</span></span><br><span class="line">        dstFile.Write(tmp)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    srcFile.Close()</span><br><span class="line">    dstFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】Go语言的异常处理</title>
      <link href="/202107/54234/"/>
      <url>/202107/54234/</url>
      
        <content type="html"><![CDATA[<h1 id="9-1-error接口"><a href="#9-1-error接口" class="headerlink" title="9.1 error接口"></a><strong>9.1 error接口</strong></h1><p>Go语言引入了一个关于错误处理的标准模式，即error接口，它是Go语言内建的接口类型，该接口的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Go语言的标准库代码包errors为用户提供如下方法：</span><br><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; </span><br><span class="line">    text <span class="keyword">string</span> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> e.text </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个可以生成error类型值的方法是调用fmt包中的Errorf函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">示例代码：</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err1 error = errors.New(<span class="string">&quot;a normal err1&quot;</span>)</span><br><span class="line">    fmt.Println(err1) <span class="comment">//a normal err1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> err2 error = fmt.Errorf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;a normal err2&quot;</span>)</span><br><span class="line">    fmt.Println(err2) <span class="comment">//a normal err2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">函数通常在最后的返回值中返回错误信息：</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">float64</span>)</span> <span class="params">(result <span class="keyword">float64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="number">0.0</span></span><br><span class="line">        err = errors.New(<span class="string">&quot;runtime error: divide by zero&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    result = a / b</span><br><span class="line">    err = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r, err := Divide(<span class="number">10.0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err) <span class="comment">//错误处理 runtime error: divide by zero</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(r) <span class="comment">// 使用返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-2-panic"><a href="#9-2-panic" class="headerlink" title="9.2 panic"></a><strong>9.2 panic</strong></h1><p>在通常情况下，向程序使用方报告错误状态的方式可以是返回一个额外的error类型值。</p><p>但是，当遇到不可恢复的错误状态的时候，如数组访问越界、空指针引用等，这些运行时错误会引起painc异常。这时，上述错误处理方式显然就不适合了。</p><p>反过来讲，在一般情况下，我们不应通过调用panic函数来报告普通的错误，而应该只把它作为报告致命错误的一种方式。当某些不应该发生的场景发生时，我们就应该调用panic。</p><p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在中被延迟的函数（defer 机制）。</p><p>随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。</p><p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func panic(v interface&#123;&#125;)</span><br></pre></td></tr></table></figure><p>调用panic函数引发的panic异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func TestA()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;func TestB(): panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func TestC()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    TestA()</span><br><span class="line">    TestB()<span class="comment">//TestB()发生异常，中断程序</span></span><br><span class="line">    TestC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的panic函数引发的panic异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func TestA()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    a[x] = <span class="number">222</span> <span class="comment">//x值为11时，数组越界</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func TestC()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    TestA()</span><br><span class="line">    TestB(<span class="number">11</span>)<span class="comment">//TestB()发生异常，中断程序</span></span><br><span class="line">    TestC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-3-recover"><a href="#9-3-recover" class="headerlink" title="9.3 recover"></a><strong>9.3 recover</strong></h1><p>运行时panic异常一旦被引发就会导致程序崩溃。这当然不是我们愿意看到的，因为谁也不能保证程序不会发生任何运行时错误。</p><p>不过，Go语言为我们提供了专用于“拦截”运行时panic的内建函数——recover。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意：recover只有在defer调用的函数中有效。</p><p>如果调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。</p><p>导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func TestA()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//在发生异常时，设置恢复</span></span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//panic value被附加到错误信息中；</span></span><br><span class="line">          <span class="comment">//并用err变量接收错误信息，返回给调用者。</span></span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;func TestB(): panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func TestC()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    TestA()</span><br><span class="line">    err := TestB()</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    TestC()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        运行结果：</span></span><br><span class="line"><span class="comment">        func TestA()</span></span><br><span class="line"><span class="comment">        internal error: func TestB(): panic</span></span><br><span class="line"><span class="comment">        func TestC()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后⼀个错误可被捕获：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">    <span class="comment">//运行结果：defer panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> go error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】面向对象编程</title>
      <link href="/202107/18820/"/>
      <url>/202107/18820/</url>
      
        <content type="html"><![CDATA[<h1 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a><strong>8.1 概述</strong></h1><p>对于面向对象编程的支持Go 语言设计得非常简洁而优雅。因为， Go语言并没有沿袭传统面向对象编程中的诸多概念，比如继承(不支持继承，尽管匿名字段的内存布局和行为类似继承，但它并不是继承)、虚函数、构造函数和析构函数、隐藏的this指针等。</p><p>尽管Go语言中没有封装、继承、多态这些概念，但同样通过别的方式实现这些特性：</p><ul><li>  l 封装：通过方法实现</li><li>  l 继承：通过匿名字段实现</li><li>  l 多态：通过接口实现</li></ul><h1 id="8-2-匿名组合"><a href="#8-2-匿名组合" class="headerlink" title="8.2 匿名组合"></a><strong>8.2 匿名组合</strong></h1><h3 id="8-2-1-匿名字段"><a href="#8-2-1-匿名字段" class="headerlink" title="8.2.1 匿名字段"></a><strong>8.2.1 匿名字段</strong></h3><p>一般情况下，定义结构体的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p><p>当匿名字段也是一个结构体的时候，那么这个结构体所拥有的全部字段都被隐式地引入了当前定义的这个结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person <span class="comment">// 匿名字段，那么默认Student就包含了Person的所有字段</span></span><br><span class="line">    id     <span class="keyword">int</span></span><br><span class="line">    addr   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-2-初始化"><a href="#8-2-2-初始化" class="headerlink" title="8.2.2 初始化"></a><strong>8.2.2 初始化</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person <span class="comment">// 匿名字段，那么默认Student就包含了Person的所有字段</span></span><br><span class="line">    id     <span class="keyword">int</span></span><br><span class="line">    addr   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//顺序初始化</span></span><br><span class="line">    s1 := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//s1 = &#123;Person:&#123;name:mike sex:109 age:18&#125; id:1 addr:sz&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 = %+v\n&quot;</span>, s1)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//s2 := Student&#123;&quot;mike&quot;, &#x27;m&#x27;, 18, 1, &quot;sz&quot;&#125; //err</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//部分成员初始化1</span></span><br><span class="line">    s3 := Student&#123;Person: Person&#123;<span class="string">&quot;lily&quot;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">19</span>&#125;, id: <span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">//s3 = &#123;Person:&#123;name:lily sex:102 age:19&#125; id:2 addr:&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;s3 = %+v\n&quot;</span>, s3)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//部分成员初始化2</span></span><br><span class="line">    s4 := Student&#123;Person: Person&#123;name: <span class="string">&quot;tom&quot;</span>&#125;, id: <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">//s4 = &#123;Person:&#123;name:tom sex:0 age:0&#125; id:3 addr:&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;s4 = %+v\n&quot;</span>, s4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-3-成员的操作"><a href="#8-2-3-成员的操作" class="headerlink" title="8.2.3 成员的操作"></a><strong>8.2.3 成员的操作</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Student <span class="comment">//变量声明</span></span><br><span class="line"><span class="comment">//给成员赋值</span></span><br><span class="line">s1.name = <span class="string">&quot;mike&quot;</span> <span class="comment">//等价于 s1.Person.name = &quot;mike&quot;</span></span><br><span class="line">s1.sex = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">s1.age = <span class="number">18</span></span><br><span class="line">s1.id = <span class="number">1</span></span><br><span class="line">s1.addr = <span class="string">&quot;sz&quot;</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//&#123;&#123;mike 109 18&#125; 1 sz&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 Student <span class="comment">//变量声明</span></span><br><span class="line">s2.Person = Person&#123;<span class="string">&quot;lily&quot;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">19</span>&#125;</span><br><span class="line">s2.id = <span class="number">2</span></span><br><span class="line">s2.addr = <span class="string">&quot;bj&quot;</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//&#123;&#123;lily 102 19&#125; 2 bj&#125;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-4-同名字段"><a href="#8-2-4-同名字段" class="headerlink" title="8.2.4 同名字段"></a><strong>8.2.4 同名字段</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person <span class="comment">// 匿名字段，那么默认Student就包含了Person的所有字段</span></span><br><span class="line">    id     <span class="keyword">int</span></span><br><span class="line">    addr   <span class="keyword">string</span></span><br><span class="line">    name   <span class="keyword">string</span> <span class="comment">//和Person中的name同名</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student <span class="comment">//变量声明</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//给Student的name，还是给Person赋值？</span></span><br><span class="line">    s.name = <span class="string">&quot;mike&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//&#123;Person:&#123;name: sex:0 age:0&#125; id:0 addr: name:mike&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//默认只会给最外层的成员赋值</span></span><br><span class="line">    <span class="comment">//给匿名同名成员赋值，需要显示调用</span></span><br><span class="line">    s.Person.name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    <span class="comment">//Person:&#123;name:yoyo sex:0 age:0&#125; id:0 addr: name:mike&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-其它匿名字段"><a href="#8-2-5-其它匿名字段" class="headerlink" title="8.2.5 其它匿名字段"></a><strong>8.2.5 其它匿名字段</strong></h3><h3 id="8-2-5-1-非结构体类型"><a href="#8-2-5-1-非结构体类型" class="headerlink" title="8.2.5.1 非结构体类型"></a><strong>8.2.5.1 非结构体类型</strong></h3><p>所有的内置类型和自定义类型都是可以作为匿名字段的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mystr <span class="keyword">string</span> <span class="comment">//自定义类型</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person <span class="comment">// 匿名字段，结构体类型</span></span><br><span class="line">    <span class="keyword">int</span>     <span class="comment">// 匿名字段，内置类型</span></span><br><span class="line">    mystr   <span class="comment">// 匿名字段，自定义类型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    s1 := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//&#123;Person:&#123;name:mike sex:109 age:18&#125; int:1 mystr:bj&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s1)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//成员的操作，打印结果：mike, m, 18, 1, bj</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s, %c, %d, %d, %s\n&quot;</span>, s1.name, s1.sex, s1.age, s1.<span class="keyword">int</span>, s1.mystr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-2-结构体指针类型"><a href="#8-2-5-2-结构体指针类型" class="headerlink" title="8.2.5.2 结构体指针类型"></a><strong>8.2.5.2 结构体指针类型</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123; <span class="comment">//人</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; <span class="comment">//学生</span></span><br><span class="line">    *Person <span class="comment">// 匿名字段，结构体指针类型</span></span><br><span class="line">    id      <span class="keyword">int</span></span><br><span class="line">    addr    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    s1 := Student&#123;&amp;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//&#123;Person:0xc0420023e0 id:1 addr:bj&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s1)</span><br><span class="line">    <span class="comment">//mike, m, 18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s, %c, %d\n&quot;</span>, s1.name, s1.sex, s1.age)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="keyword">var</span> s2 Student</span><br><span class="line">    s2.Person = <span class="built_in">new</span>(Person) <span class="comment">//分配空间</span></span><br><span class="line">    s2.name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    s2.sex = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    s2.age = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    s2.id = <span class="number">2</span></span><br><span class="line">    s2.addr = <span class="string">&quot;sz&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//yoyo 102 20 2 20</span></span><br><span class="line">    fmt.Println(s2.name, s2.sex, s2.age, s2.id, s2.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-3-方法"><a href="#8-3-方法" class="headerlink" title="8.3 方法"></a><strong>8.3 方法</strong></h1><h3 id="8-3-1-概述"><a href="#8-3-1-概述" class="headerlink" title="8.3.1 概述"></a><strong>8.3.1 概述</strong></h3><p>在面向对象编程中，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些函数，<strong>这种带有接收者的函数，我们称为方法(method)</strong> 。 本质上，一个方法则是一个和特殊类型关联的函数。</p><p>一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p><p>在Go语言中，可以给任意自定义类型（包括内置类型，但不包括指针类型）添加相应的方法。</p><p>⽅法总是绑定对象实例，并隐式将实例作为第⼀实参 (receiver)，方法的语法如下：</p><p><strong>func</strong> (receiver ReceiverType) funcName(parameters) (results)</p><ul><li>  l 参数 receiver 可任意命名。如⽅法中未曾使⽤，可省略参数名。</li><li>  l 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接⼝或指针。</li><li>  l 不支持重载方法，也就是说，不能定义名字相同但是不同参数的方法。</li></ul><h3 id="8-3-2-为类型添加方法"><a href="#8-3-2-为类型添加方法" class="headerlink" title="8.3.2 为类型添加方法"></a><strong>8.3.2 为类型添加方法</strong></h3><h3 id="8-3-2-1-基础类型作为接收者"><a href="#8-3-2-1-基础类型作为接收者" class="headerlink" title="8.3.2.1 基础类型作为接收者"></a><strong>8.3.2.1 基础类型作为接收者</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span> <span class="comment">//自定义类型，给int改名为MyInt</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//在函数定义时，在其名字之前放上一个变量，即是一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a MyInt)</span> <span class="title">Add</span><span class="params">(b MyInt)</span> <span class="title">MyInt</span></span> &#123; <span class="comment">//面向对象</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//传统方式的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b MyInt)</span> <span class="title">MyInt</span></span> &#123; <span class="comment">//面向过程</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a MyInt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b MyInt = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用func (a MyInt) Add(b MyInt)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a.Add(b) = &quot;</span>, a.Add(b)) <span class="comment">//a.Add(b) =  2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用func Add(a, b MyInt)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Add(a, b) = &quot;</span>, Add(a, b)) <span class="comment">//Add(a, b) =  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出，面向对象只是换了一种语法形式来表达。方法是函数的语法糖，因为receiver其实就是方法所接收的第1个参数。</p><p>注意：虽然方法的名字一模一样，但是如果接收者不一样，那么方法就不一样。</p><h3 id="8-3-2-2-结构体作为接收者"><a href="#8-3-2-2-结构体作为接收者" class="headerlink" title="8.3.2.2 结构体作为接收者"></a><strong>8.3.2.2 结构体作为接收者</strong></h3><p>方法里面可以访问接收者的字段，调用方法通过点( <strong>.</strong> )访问，就像struct里面访问字段一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">PrintInfo</span><span class="params">()</span></span> &#123; <span class="comment">//给Person添加方法</span></span><br><span class="line">    fmt.Println(p.name, p.sex, p.age)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125; <span class="comment">//初始化</span></span><br><span class="line">    p.PrintInfo() <span class="comment">//调用func (p Person) PrintInfo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-3-值语义和引用语义"><a href="#8-3-3-值语义和引用语义" class="headerlink" title="8.3.3 值语义和引用语义"></a><strong>8.3.3 值语义和引用语义</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//指针作为接收者，引用语义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetInfoPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//给成员赋值</span></span><br><span class="line">    (*p).name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    p.sex = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    p.age = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//值作为接收者，值语义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetInfoValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//给成员赋值</span></span><br><span class="line">    p.name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    p.sex = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    p.age = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//指针作为接收者，引用语义</span></span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125; <span class="comment">//初始化</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;函数调用前 = &quot;</span>, p1)   <span class="comment">//函数调用前 =  &#123;mike 109 18&#125;</span></span><br><span class="line">    (&amp;p1).SetInfoPointer()</span><br><span class="line">    fmt.Println(<span class="string">&quot;函数调用后 = &quot;</span>, p1) <span class="comment">//函数调用后 =  &#123;yoyo 102 22&#125;</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;==========================&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    p2 := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125; <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//值作为接收者，值语义</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;函数调用前 = &quot;</span>, p2) <span class="comment">//函数调用前 =  &#123;mike 109 18&#125;</span></span><br><span class="line">    p2.SetInfoValue()</span><br><span class="line">    fmt.Println(<span class="string">&quot;函数调用后 = &quot;</span>, p2) <span class="comment">//函数调用后 =  &#123;mike 109 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-4-方法集"><a href="#8-3-4-方法集" class="headerlink" title="8.3.4 方法集"></a><strong>8.3.4 方法集</strong></h3><p>类型的方法集是指可以被该类型的值调用的所有方法的集合。</p><p>用实例实例 value 和 pointer 调用方法（含匿名字段）不受⽅法集约束，编译器编总是查找全部方法，并自动转换 receiver 实参。</p><p>*<em>8.3.4.1 类型 <em>T 方法集</em></em></p><p>一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。</p><p>如果在指针上调用一个接受值的方法，Go语言会聪明地将该指针解引用，并将指针所指的底层值作为方法的接收者。</p><p>类型 *T ⽅法集包含全部 receiver T + *T ⽅法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//指针作为接收者，引用语义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetInfoPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (*p).name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    p.sex = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    p.age = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//值作为接收者，值语义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetInfoValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    p.sex = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">    p.age = <span class="number">33</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//p 为指针类型</span></span><br><span class="line">    <span class="keyword">var</span> p *Person = &amp;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    p.SetInfoPointer() <span class="comment">//func (p) SetInfoPointer()</span></span><br><span class="line"> </span><br><span class="line">    p.SetInfoValue()    <span class="comment">//func (*p) SetInfoValue()</span></span><br><span class="line">    (*p).SetInfoValue() <span class="comment">//func (*p) SetInfoValue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.3.4.2 类型 T 方法集</strong></p><p>一个自定义类型值的方法集则由为该类型定义的接收者类型为值类型的方法组成，但是不包含那些接收者类型为指针的方法。</p><p>但这种限制通常并不像这里所说的那样，因为如果我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这可以借助于Go语言传值的地址能力实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//指针作为接收者，引用语义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetInfoPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (*p).name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    p.sex = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    p.age = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//值作为接收者，值语义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetInfoValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    p.sex = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">    p.age = <span class="number">33</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//p 为普通值类型</span></span><br><span class="line">    <span class="keyword">var</span> p Person = Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    (&amp;p).SetInfoPointer() <span class="comment">//func (&amp;p) SetInfoPointer()</span></span><br><span class="line">    p.SetInfoPointer()    <span class="comment">//func (&amp;p) SetInfoPointer()</span></span><br><span class="line">    </span><br><span class="line">    p.SetInfoValue()      <span class="comment">//func (p) SetInfoValue()</span></span><br><span class="line">    (&amp;p).SetInfoValue()   <span class="comment">//func (*&amp;p) SetInfoValue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-5-匿名字段"><a href="#8-3-5-匿名字段" class="headerlink" title="8.3.5 匿名字段"></a><strong>8.3.5 匿名字段</strong></h3><p><strong>8.3.5.1 方法的继承</strong></p><p>如果匿名字段实现了一个方法，那么包含这个匿名字段的struct也能调用该方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    sex  byte</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//Person定义了方法</span><br><span class="line">func (p *Person) PrintInfo() &#123;</span><br><span class="line">    fmt.Printf(&quot;%s,%c,%d\n&quot;, p.name, p.sex, p.age)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type Student struct &#123;</span><br><span class="line">    Person // 匿名字段，那么Student包含了Person的所有字段</span><br><span class="line">    id     int</span><br><span class="line">    addr   string</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    p := Person&#123;&quot;mike&quot;, &#x27;m&#x27;, 18&#125;</span><br><span class="line">    p.PrintInfo()</span><br><span class="line"> </span><br><span class="line">    s := Student&#123;Person&#123;&quot;yoyo&quot;, &#x27;f&#x27;, 20&#125;, 2, &quot;sz&quot;&#125;</span><br><span class="line">    s.PrintInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.3.5.2 方法的重写</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Person定义了方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">PrintInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Person: %s,%c,%d\n&quot;</span>, p.name, p.sex, p.age)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person <span class="comment">// 匿名字段，那么Student包含了Person的所有字段</span></span><br><span class="line">    id     <span class="keyword">int</span></span><br><span class="line">    addr   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Student定义了方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">PrintInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Student：%s,%c,%d\n&quot;</span>, s.name, s.sex, s.age)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    p.PrintInfo() <span class="comment">//Person: mike,m,18</span></span><br><span class="line"> </span><br><span class="line">    s := Student&#123;Person&#123;<span class="string">&quot;yoyo&quot;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">20</span>&#125;, <span class="number">2</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line">    s.PrintInfo()        <span class="comment">//Student：yoyo,f,20</span></span><br><span class="line">    s.Person.PrintInfo() <span class="comment">//Person: yoyo,f,20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-6-表达式"><a href="#8-3-6-表达式" class="headerlink" title="8.3.6 表达式"></a><strong>8.3.6 表达式</strong></h3><p>类似于我们可以对函数进行赋值和传递一样，方法也可以进行赋值和传递。</p><p>根据调用者不同，方法分为两种表现形式：方法值和方法表达式。两者都可像普通函数那样赋值和传参，区别在于方法值绑定实例，⽽方法表达式则须显式传参。</p><p><strong>8.3.6.1 方法值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">PrintInfoPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, p, p)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">PrintInfoValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, &amp;p, p)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    p.PrintInfoPointer() <span class="comment">//0xc0420023e0, &amp;&#123;mike 109 18&#125;</span></span><br><span class="line"> </span><br><span class="line">    pFunc1 := p.PrintInfoPointer <span class="comment">//方法值，隐式传递 receiver</span></span><br><span class="line">    pFunc1()                     <span class="comment">//0xc0420023e0, &amp;&#123;mike 109 18&#125;</span></span><br><span class="line"> </span><br><span class="line">    pFunc2 := p.PrintInfoValue</span><br><span class="line">    pFunc2() <span class="comment">//0xc042048420, &#123;mike 109 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.3.6.2 方法表达式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">PrintInfoPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, p, p)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">PrintInfoValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, &amp;p, p)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    p.PrintInfoPointer() <span class="comment">//0xc0420023e0, &amp;&#123;mike 109 18&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方法表达式， 须显式传参</span></span><br><span class="line">    <span class="comment">//func pFunc1(p *Person))</span></span><br><span class="line">    pFunc1 := (*Person).PrintInfoPointer</span><br><span class="line">    pFunc1(&amp;p) <span class="comment">//0xc0420023e0, &amp;&#123;mike 109 18&#125;</span></span><br><span class="line"> </span><br><span class="line">    pFunc2 := Person.PrintInfoValue</span><br><span class="line">    pFunc2(p) <span class="comment">//0xc042002460, &#123;mike 109 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-4-接口"><a href="#8-4-接口" class="headerlink" title="8.4 接口"></a><strong>8.4 接口</strong></h1><h3 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a><strong>8.4.1 概述</strong></h3><p>在Go语言中，接口(interface)是一个自定义类型，接口类型具体描述了一系列方法的集合。</p><p>接口类型是一种抽象的类型，它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合，它们只会展示出它们自己的方法。因此接口类型不能将其实例化。</p><p>Go通过接口实现了鸭子类型(duck-typing)：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p><p>接口其实就是纯虚函数，只定义方法，不实现。 面向接口编程就是向外界只提供调用的方法，至于怎么实现的你不用关心，至于实现多少个版本不用你关心，你只用关心你想用哪个版本就行了。</p><h3 id="8-4-2-接口的使用"><a href="#8-4-2-接口的使用" class="headerlink" title="8.4.2 接口的使用"></a><strong>8.4.2 接口的使用</strong></h3><h3 id="8-4-2-1-接口定义"><a href="#8-4-2-1-接口定义" class="headerlink" title="8.4.2.1 接口定义"></a><strong>8.4.2.1 接口定义</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  l 接⼝命名习惯以 er 结尾</li><li>  l 接口只有方法声明，没有实现，没有数据字段</li><li>  l 接口可以匿名嵌入其它接口，或嵌入到结构中</li></ul><h3 id="8-4-2-2-接口实现"><a href="#8-4-2-2-接口实现" class="headerlink" title="8.4.2.2 接口实现"></a><strong>8.4.2.2 接口实现</strong></h3><p>接口是用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现，一个实现了这些方法的具体类型是这个接口类型的实例。</p><p>如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; <span class="comment">//学生</span></span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Student实现SayHi()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Student[%s, %f] say hi!!\n&quot;</span>, s.name, s.score)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123; <span class="comment">//老师</span></span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    group <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Teacher实现SayHi()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Teacher[%s, %s] say hi!!\n&quot;</span>, t.name, t.group)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> MyStr <span class="keyword">string</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//MyStr实现SayHi()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(str MyStr)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;MyStr[%s] say hi!!\n&quot;</span>, str)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//普通函数，参数为Humaner类型的变量i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WhoSayHi</span><span class="params">(i Humaner)</span></span> &#123;</span><br><span class="line">    i.SayHi()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;Student&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">88.88</span>&#125;</span><br><span class="line">    t := &amp;Teacher&#123;<span class="string">&quot;yoyo&quot;</span>, <span class="string">&quot;Go语言&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> tmp MyStr = <span class="string">&quot;测试&quot;</span></span><br><span class="line"> </span><br><span class="line">    s.SayHi()   <span class="comment">//Student[mike, 88.880000] say hi!!</span></span><br><span class="line">    t.SayHi()   <span class="comment">//Teacher[yoyo, Go语言] say hi!!</span></span><br><span class="line">    tmp.SayHi() <span class="comment">//MyStr[测试] say hi!!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//多态，调用同一接口，不同表现</span></span><br><span class="line">    WhoSayHi(s)   <span class="comment">//Student[mike, 88.880000] say hi!!</span></span><br><span class="line">    WhoSayHi(t)   <span class="comment">//Teacher[yoyo, Go语言] say hi!!</span></span><br><span class="line">    WhoSayHi(tmp) <span class="comment">//MyStr[测试] say hi!!</span></span><br><span class="line"> </span><br><span class="line">    x := <span class="built_in">make</span>([]Humaner, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = s, t, tmp</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x &#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Student[mike, 88.880000] say hi!!</span></span><br><span class="line"><span class="comment">        Teacher[yoyo, Go语言] say hi!!</span></span><br><span class="line"><span class="comment">        MyStr[测试] say hi!!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码，你会发现接口就是一组抽象方法的集合，它必须由其他非接口类型实现，而不能自我实现。</p><h3 id="8-4-3-接口组合"><a href="#8-4-3-接口组合" class="headerlink" title="8.4.3 接口组合"></a><strong>8.4.3 接口组合</strong></h3><h3 id="8-4-3-1-接口嵌入"><a href="#8-4-3-1-接口嵌入" class="headerlink" title="8.4.3.1 接口嵌入"></a><strong>8.4.3.1 接口嵌入</strong></h3><p>如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Personer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Humaner <span class="comment">//这里想写了SayHi()一样</span></span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; <span class="comment">//学生</span></span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Student实现SayHi()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Student[%s, %f] say hi!!\n&quot;</span>, s.name, s.score)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Student实现Sing()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Student sing[%s]!!\n&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;Student&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">88.88</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> i2 Personer</span><br><span class="line">    i2 = s</span><br><span class="line">    i2.SayHi()     <span class="comment">//Student[mike, 88.880000] say hi!!</span></span><br><span class="line">    i2.Sing(<span class="string">&quot;学生哥&quot;</span>) <span class="comment">//Student sing[学生哥]!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-3-2-接口转换"><a href="#8-4-3-2-接口转换" class="headerlink" title="8.4.3.2 接口转换"></a><strong>8.4.3.2 接口转换</strong></h3><p>超集接⼝对象可转换为⼦集接⼝，反之出错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Personer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Humaner <span class="comment">//这里像写了SayHi()一样</span></span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; <span class="comment">//学生</span></span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Student实现SayHi()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Student[%s, %f] say hi!!\n&quot;</span>, s.name, s.score)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Student实现Sing()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Student sing[%s]!!\n&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//var i1 Humaner = &amp;Student&#123;&quot;mike&quot;, 88.88&#125;</span></span><br><span class="line">    <span class="comment">//var i2 Personer = i1 //err</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Personer为超集，Humaner为子集</span></span><br><span class="line">    <span class="keyword">var</span> i1 Personer = &amp;Student&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">88.88</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> i2 Humaner = i1</span><br><span class="line">    i2.SayHi() <span class="comment">//Student[mike, 88.880000] say hi!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-4-空接口"><a href="#8-4-4-空接口" class="headerlink" title="8.4.4 空接口"></a><strong>8.4.4 空接口</strong></h3><p>空接口(interface{})不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。它有点类似于C语言的void *类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span>     <span class="comment">// 将int类型赋值给interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;abc&quot;</span> <span class="comment">// 将string类型赋值给interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> v3 <span class="keyword">interface</span>&#123;&#125; = &amp;v2   <span class="comment">// 将*interface&#123;&#125;类型赋值给interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> v4 <span class="keyword">interface</span>&#123;&#125; = <span class="keyword">struct</span>&#123; X <span class="keyword">int</span> &#125;&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v5 <span class="keyword">interface</span>&#123;&#125; = &amp;<span class="keyword">struct</span>&#123; X <span class="keyword">int</span> &#125;&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标准库fmt中PrintXXX系列的函数，例如：</p><p><strong>func</strong> Printf(fmt string, args …<strong>interface</strong>{})</p><p><strong>func</strong> Println(args …<strong>interface</strong>{})</p><h3 id="8-4-5-类型查询"><a href="#8-4-5-类型查询" class="headerlink" title="8.4.5 类型查询"></a><strong>8.4.5 类型查询</strong></h3><p>我们知道interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么我们怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p><p>l comma-ok断言</p><p>l switch测试</p><h3 id="8-4-5-1-comma-ok断言"><a href="#8-4-5-1-comma-ok断言" class="headerlink" title="8.4.5.1 comma-ok断言"></a><strong>8.4.5.1 comma-ok断言</strong></h3><p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p><p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>([]Element, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span>       <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is [%s, %d]\n&quot;</span>, index, value.name, value.age)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*  打印结果：</span></span><br><span class="line"><span class="comment">    list[0] is an int and its value is 1</span></span><br><span class="line"><span class="comment">    list[1] is a string and its value is Hello</span></span><br><span class="line"><span class="comment">    list[2] is a Person and its value is [mike, 18]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-5-2-switch测试"><a href="#8-4-5-2-switch测试" class="headerlink" title="8.4.5.2 switch测试"></a><strong>8.4.5.2 switch测试</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>([]Element, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span>       <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is [%s, %d]\n&quot;</span>, index, value.name, value.age)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】复合类型-结构体</title>
      <link href="/202107/15495/"/>
      <url>/202107/15495/</url>
      
        <content type="html"><![CDATA[<h2 id="7-6-结构体"><a href="#7-6-结构体" class="headerlink" title="7.6 结构体"></a>7.6 结构体</h2><h3 id="7-6-1-结构体类型"><a href="#7-6-1-结构体类型" class="headerlink" title="7.6.1 结构体类型"></a>7.6.1 结构体类型</h3><p>有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。</p><p>结构体是一种聚合的数据类型，它是由一系列具有相同类型或不同类型的数据构成的数据集合。每个数据称为结构体的成员。</p><h3 id="7-6-2-结构体初始化"><a href="#7-6-2-结构体初始化" class="headerlink" title="7.6.2 结构体初始化"></a>7.6.2 结构体初始化</h3><h4 id="7-6-2-1-普通变量"><a href="#7-6-2-1-普通变量" class="headerlink" title="7.6.2.1 普通变量"></a>7.6.2.1 普通变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//1、顺序初始化，必须每个成员都初始化</span></span><br><span class="line">    <span class="keyword">var</span> s1 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line">    s2 := Student&#123;<span class="number">2</span>, <span class="string">&quot;yoyo&quot;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">20</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//s3 := Student&#123;2, &quot;tom&quot;, &#x27;m&#x27;, 20&#125; //err, too few values in struct initializer</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2、指定初始化某个成员，没有初始化的成员为零值</span></span><br><span class="line">    s4 := Student&#123;id: <span class="number">2</span>, name: <span class="string">&quot;lily&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-2-2-指针变量"><a href="#7-6-2-2-指针变量" class="headerlink" title="7.6.2.2 指针变量"></a>7.6.2.2 指针变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex  <span class="keyword">byte</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s5 *Student = &amp;Student&#123;<span class="number">3</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">16</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    s6 := &amp;Student&#123;<span class="number">4</span>, <span class="string">&quot;rocco&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">3</span>, <span class="string">&quot;sh&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-3-结构体成员的使用"><a href="#7-6-3-结构体成员的使用" class="headerlink" title="7.6.3 结构体成员的使用"></a>7.6.3 结构体成员的使用</h3><h4 id="7-6-3-1-普通变量"><a href="#7-6-3-1-普通变量" class="headerlink" title="7.6.3.1 普通变量"></a>7.6.3.1 普通变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===============结构体变量为普通变量</span></span><br><span class="line">    <span class="comment">//1、打印成员</span></span><br><span class="line">    <span class="keyword">var</span> s1 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//结果：id = 1, name = mike, sex = m, age = 18, addr = sz</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;id = %d, name = %s, sex = %c, age = %d, addr = %s\n&quot;</span>,</span><br><span class="line">        s1.id, s1.name, s1.sex, s1.age, s1.addr)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2、成员变量赋值</span></span><br><span class="line">    <span class="keyword">var</span> s2 Student</span><br><span class="line">    s2.id = <span class="number">2</span></span><br><span class="line">    s2.name = <span class="string">&quot;yoyo&quot;</span></span><br><span class="line">    s2.sex = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    s2.age = <span class="number">16</span></span><br><span class="line">    s2.addr = <span class="string">&quot;guangzhou&quot;</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//&#123;2 yoyo 102 16 guangzhou&#125;</span></span><br></pre></td></tr></table></figure><h4 id="7-6-3-2-指针变量"><a href="#7-6-3-2-指针变量" class="headerlink" title="7.6.3.2 指针变量"></a>7.6.3.2 指针变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===============结构体变量为指针变量</span></span><br><span class="line"><span class="comment">//3、先分配空间，再赋值</span></span><br><span class="line">s3 := <span class="built_in">new</span>(Student)</span><br><span class="line">s3.id = <span class="number">3</span></span><br><span class="line">s3.name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">fmt.Println(s3) <span class="comment">//&amp;&#123;3 xxx 0 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、普通变量和指针变量类型打印</span></span><br><span class="line"><span class="keyword">var</span> s4 Student = Student&#123;<span class="number">4</span>, <span class="string">&quot;yyy&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;s4 = %v, &amp;s4 = %v\n&quot;</span>, s4, &amp;s4) </span><br><span class="line"><span class="comment">//s4 = &#123;4 yyy 109 18 sz&#125;, &amp;s4 = &amp;&#123;4 yyy 109 18 sz&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *Student = &amp;s4</span><br><span class="line"><span class="comment">//p.成员 和(*p).成员 操作是等价的</span></span><br><span class="line">p.id = <span class="number">5</span></span><br><span class="line">(*p).name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">fmt.Println(p, *p, s4) <span class="comment">//&amp;&#123;5 zzz 109 18 sz&#125; &#123;5 zzz 109 18 sz&#125; &#123;5 zzz 109 18 sz&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7-6-4-结构体比较"><a href="#7-6-4-结构体比较" class="headerlink" title="7.6.4 结构体比较"></a>7.6.4 结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 == 或 != 运算符进行比较，但不支持 &gt; 或 &lt; 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    s1 := Student&#123;1, &quot;mike&quot;, &#x27;m&#x27;, 18, &quot;sz&quot;&#125;</span><br><span class="line">    s2 := Student&#123;1, &quot;mike&quot;, &#x27;m&#x27;, 18, &quot;sz&quot;&#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(&quot;s1 == s2&quot;, s1 == s2) //s1 == s2 true</span><br><span class="line">    fmt.Println(&quot;s1 != s2&quot;, s1 != s2) //s1 != s2 false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-5-结构体作为函数参数"><a href="#7-6-5-结构体作为函数参数" class="headerlink" title="7.6.5 结构体作为函数参数"></a>7.6.5 结构体作为函数参数</h3><h4 id="7-6-5-1-值传递"><a href="#7-6-5-1-值传递" class="headerlink" title="7.6.5.1 值传递"></a>7.6.5.1 值传递</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStudentValue</span><span class="params">(tmp Student)</span></span> &#123;</span><br><span class="line">    tmp.id = <span class="number">250</span></span><br><span class="line">    <span class="comment">//printStudentValue tmp =  &#123;250 mike 109 18 sz&#125;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;printStudentValue tmp = &quot;</span>, tmp)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    printStudentValue(s)        <span class="comment">//值传递，形参的修改不会影响到实参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main s = &quot;</span>, s) <span class="comment">//main s =  &#123;1 mike 109 18 sz&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-5-2-引用传递"><a href="#7-6-5-2-引用传递" class="headerlink" title="7.6.5.2 引用传递"></a>7.6.5.2 引用传递</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStudentPointer</span><span class="params">(p *Student)</span></span> &#123;</span><br><span class="line">    p.id = <span class="number">250</span></span><br><span class="line">    <span class="comment">//printStudentPointer p =  &amp;&#123;250 mike 109 18 sz&#125;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;printStudentPointer p = &quot;</span>, p)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>, <span class="string">&quot;sz&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    printStudentPointer(&amp;s)     <span class="comment">//引用(地址)传递，形参的修改会影响到实参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main s = &quot;</span>, s) <span class="comment">//main s =  &#123;250 mike 109 18 sz&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-2-可见性"><a href="#7-6-2-可见性" class="headerlink" title="7.6.2 可见性"></a>7.6.2 可见性</h3><p>Go语言对关键字的增加非常吝啬，其中没有private、 protected、 public这样的关键字。</p><blockquote><p>要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母开头。</p></blockquote><h3 id="7-6-7-结构体tag"><a href="#7-6-7-结构体tag" class="headerlink" title="7.6.7 结构体tag"></a>7.6.7 结构体tag</h3><p>正常情况下，你定义的结构体是这样子的，每个字段都由名字和字段类型组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">    Addr string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有例外，就像下面这样子，字段上还可以额外再加一个属性，用反引号（Esc键下面的那个键）包含的字符串，称之为 Tag，也就是标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name string `json:&quot;name&quot;`</span><br><span class="line">    Age  int    `json:&quot;age&quot;`</span><br><span class="line">    Addr string `json:&quot;addr,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个标签有什么用呢？</p><p>这边先以 <code>encoding/json</code> 库的用法抛砖引玉，看一下它能起到什么样的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">type Person struct &#123;</span><br><span class="line">    Name string `json:&quot;name&quot;`</span><br><span class="line">    Age  int    `json:&quot;age&quot;`</span><br><span class="line">    Addr string `json:&quot;addr,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        Name: &quot;Jack&quot;,</span><br><span class="line">        Age:  22,</span><br><span class="line">    &#125;</span><br><span class="line">    data1, err := json.Marshal(p1)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    // p1 没有 Addr，就不会打印了</span><br><span class="line">    fmt.Printf(&quot;%s\n&quot;, data1)</span><br><span class="line">    // ================</span><br><span class="line">    p2 := Person&#123;</span><br><span class="line">        Name: &quot;Jack&quot;,</span><br><span class="line">        Age:  22,</span><br><span class="line">        Addr: &quot;China&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    data2, err := json.Marshal(p2)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    // p2 则会打印所有</span><br><span class="line">    fmt.Printf(&quot;%s\n&quot;, data2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Person 结构体里的 Addr 字段有 omitempty 属性，因此 encoding/json 在将对象转化 json 字符串时，只要发现对象里的 Addr 为 false， 0， 空指针，空接口，空数组，空切片，空映射，空字符串中的一种，就会被忽略。</p><p>因此运行后，输出的结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run demo.go</span><br><span class="line">&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:22&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:22,&quot;addr&quot;:&quot;China&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="如何定义获取-Tag-？"><a href="#如何定义获取-Tag-？" class="headerlink" title="如何定义获取 Tag ？"></a>如何定义获取 Tag ？</h4><p>Tag 由反引号包含，由一对或几对的键值对组成，通过空格来分割键值。格式如下</p><p><code>key01:&quot;value01&quot; key02:&quot;value02&quot; key03:&quot;value03&quot;</code></p><p>定义完后，如何从结构体中，取出 Tag 呢？</p><p>答案就是，我们上一节学过的 “反射”。</p><p>获取 Tag 可以分为三个步骤：</p><ol><li> 获取字段 field</li><li> 获取标签 tag</li><li> 获取键值对 key:value</li></ol><p>演示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 三种获取 field</span><br><span class="line">field := reflect.TypeOf(obj).FieldByName(&quot;Name&quot;)</span><br><span class="line">field := reflect.ValueOf(obj).Type().Field(i)  // i 表示第几个字段</span><br><span class="line">field := reflect.ValueOf(&amp;obj).Elem().Type().Field(i)  // i 表示第几个字段</span><br><span class="line">// 获取 Tag</span><br><span class="line">tag := field.Tag</span><br><span class="line">// 获取键值对</span><br><span class="line">labelValue := tag.Get(&quot;label&quot;)</span><br><span class="line">labelValue,ok := tag.Lookup(&quot;label&quot;)</span><br><span class="line">//获取键值对，有Get 和 Lookup 两种方法，但其实 Get 只是对 Lookup 函数的简单封装而已，当没有获取到对应 tag 的内容，会返回空字符串。</span><br><span class="line">func (tag StructTag) Get(key string) string &#123;</span><br><span class="line">    v, _ := tag.Lookup(key)</span><br><span class="line">    return v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空 Tag 和不设置 Tag 效果是一样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">``</span></span><br><span class="line">    Age <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := reflect.TypeOf(Person&#123;&#125;)</span><br><span class="line">    name, _ := p.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, name.Tag) <span class="comment">//输出 &quot;&quot;</span></span><br><span class="line">    age, _ := p.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, age.Tag) <span class="comment">// 输出 &quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-实战一下：利用-Tag-搞点事情？"><a href="#3-实战一下：利用-Tag-搞点事情？" class="headerlink" title="3. 实战一下：利用 Tag 搞点事情？"></a>3. 实战一下：利用 Tag 搞点事情？</h4><p>学会了如何定义 tag 和 获取 tag，可以试着利用 tag 来做一些事情，来练习一下。</p><p>这边我举个例子吧。</p><p>如果我想实现一个函数（就叫 Print 吧），在打印 person 对象时，能够美化输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name        string</span><br><span class="line">    Age         int</span><br><span class="line">    Gender      string</span><br><span class="line">&#125;</span><br><span class="line">person := Person&#123;</span><br><span class="line">    Name:        &quot;MING&quot;,</span><br><span class="line">    Age:         29,</span><br><span class="line">&#125;</span><br><span class="line">Print(person)</span><br><span class="line">就像下面这样，key 和 value 之间有个 is:，如果没有指定 Gender 的值，那么显示为unknown（未知）。</span><br><span class="line">Name is: MING</span><br><span class="line">Age is: 29</span><br><span class="line">Gender is: unknown</span><br></pre></td></tr></table></figure><p>那该怎么做呢？</p><p>先改造下 Person 结构体，给每个字段加上 tag 标签，三个字段的tag 都有 label 属性，而 Gender 多了一个 default 属性，意在指定默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name        <span class="keyword">string</span> <span class="string">`label:&quot;Name is: &quot;`</span></span><br><span class="line">    Age         <span class="keyword">int</span>    <span class="string">`label:&quot;Age is: &quot;`</span></span><br><span class="line">    Gender      <span class="keyword">string</span> <span class="string">`label:&quot;Gender is: &quot; default:&quot;unknown&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后来写一下这个 Print 函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取 Value</span></span><br><span class="line">    v := reflect.ValueOf(obj)</span><br><span class="line">    <span class="comment">// 解析字段</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">        <span class="comment">// 取tag</span></span><br><span class="line">        field := v.Type().Field(i)</span><br><span class="line">        tag := field.Tag</span><br><span class="line">        <span class="comment">// 解析label 和 default</span></span><br><span class="line">        label := tag.Get(<span class="string">&quot;label&quot;</span>)</span><br><span class="line">        defaultValue := tag.Get(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">        value := fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, v.Field(i))</span><br><span class="line">        <span class="keyword">if</span> value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有指定值，则用默认值替代</span></span><br><span class="line">            value = defaultValue</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(label + value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最后执行一下，看了下输出，符合我们的预期：</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run demo.<span class="keyword">go</span></span><br><span class="line">Name is: MING</span><br><span class="line">Age is: <span class="number">29</span></span><br><span class="line">Gender is: unknown</span><br></pre></td></tr></table></figure><p>到此，我们就把 Tag 的用法介绍完了。</p><h1 id="新手常见的问题"><a href="#新手常见的问题" class="headerlink" title="新手常见的问题"></a>新手常见的问题</h1><h2 id="new-和-var-一个结构体的区别"><a href="#new-和-var-一个结构体的区别" class="headerlink" title="new 和 var 一个结构体的区别"></a>new 和 var 一个结构体的区别</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">//这里返回的是值</span></span><br><span class="line">    <span class="comment">//ScaleFunc(v, 5)  // 编译错误！</span></span><br><span class="line">    ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> v1 = <span class="built_in">new</span>(Vertex)<span class="comment">//这里返回的是指针</span></span><br><span class="line">    ScaleFunc(v1, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(v1)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> v Vertex</span><br><span class="line">    v.Scale(<span class="number">5</span>)  <span class="comment">// OK 解释为 (&amp;v).Scale(5)。</span></span><br><span class="line">    p := &amp;v</span><br><span class="line">    p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 </span></span><br><span class="line"><span class="comment">    也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(v, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AbsFunc(v Vertex) float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    v := Vertex&#123;3, 4&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">    fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">    p := &amp;Vertex&#123;4, 3&#125;</span><br><span class="line">    fmt.Println(p.Abs())</span><br><span class="line">    fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">接受一个值作为参数的函数必须接受一个指定类型的值：</span><br><span class="line"></span><br><span class="line">var v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  // OK</span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br><span class="line"></span><br><span class="line">而以值为接收者的方法被调用时，接收者既能为值又能为指针：</span><br><span class="line"></span><br><span class="line">var v Vertex</span><br><span class="line">fmt.Println(v.Abs()) // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) // OK</span><br><span class="line">这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>方法的接收可以自动兼容。</p><p>函数的接收会严格校验</p><h2 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h2><p>使用指针接收者的原因有二：</p><p>首先，方法能够修改其接收者指向的值。</p><p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    v := &amp;Vertex&#123;3, 4&#125;</span><br><span class="line">    fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</span><br><span class="line">    v.Scale(5)</span><br><span class="line">    fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】复合类型-map</title>
      <link href="/202107/55300/"/>
      <url>/202107/55300/</url>
      
        <content type="html"><![CDATA[<h2 id="7-5-map"><a href="#7-5-map" class="headerlink" title="7.5 map"></a>7.5 map</h2><h3 id="7-5-1-概述"><a href="#7-5-1-概述" class="headerlink" title="7.5.1 概述"></a>7.5.1 概述</h3><p>Go语言中的map(映射、字典)是一种内置的数据结构，它是一个无序的key—value对的集合，比如以身份证号作为唯一键来标识一个人的信息。</p><p>map格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure><p>在一个map里所有的键都是唯一的，而且必须是支持==和!=操作符的类型，切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[ []<span class="keyword">string</span> ]<span class="keyword">int</span>&#123;&#125; <span class="comment">//err, invalid map key type []string</span></span><br></pre></td></tr></table></figure><p>map值可以是任意类型，没有限制。map里所有键的数据类型必须是相同的，值也必须如何，但键和值的数据类型可以不相同。</p><p><strong><strong>注意</strong></strong>：map是无序的，我们无法决定它的返回顺序，所以，每次打印结果的顺利有可能不同。</p><h3 id="7-5-2-创建和初始化"><a href="#7-5-2-创建和初始化" class="headerlink" title="7.5.2 创建和初始化"></a>7.5.2 创建和初始化</h3><h4 id="7-5-2-1-map的创建"><a href="#7-5-2-1-map的创建" class="headerlink" title="7.5.2.1 map的创建"></a>7.5.2.1 map的创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>  <span class="comment">//只是声明一个map，没有初始化, 此为空(nil)map</span></span><br><span class="line">fmt.Println(m1 == <span class="literal">nil</span>) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//m1[1] = &quot;mike&quot; //err, panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m2, m3的创建方法是等价的</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(m2, m3) <span class="comment">//map[] map[]</span></span><br><span class="line"></span><br><span class="line">m4 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>) <span class="comment">//第2个参数指定容量</span></span><br><span class="line">fmt.Println(m4)                <span class="comment">//map[]</span></span><br></pre></td></tr></table></figure><h4 id="7-5-2-2-初始化"><a href="#7-5-2-2-初始化" class="headerlink" title="7.5.2.2 初始化"></a>7.5.2.2 初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="keyword">var</span> scores <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法 自动推导</span></span><br><span class="line">scores := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方法</span></span><br><span class="line">scores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scores[<span class="string">&quot;english&quot;</span>] = <span class="number">80</span></span><br><span class="line">scores[<span class="string">&quot;chinese&quot;</span>] = <span class="number">85</span></span><br></pre></td></tr></table></figure><p>要注意的是，第一种方法如果拆分成多步（声明、初始化、再赋值），和其他两种有很大的不一样了，相对会比较麻烦。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个名为 score 的字典</span></span><br><span class="line">    <span class="keyword">var</span> scores <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未初始化的 score 的零值为nil，无法直接进行赋值</span></span><br><span class="line">    <span class="keyword">if</span> scores == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 需要使用 make 函数先对其初始化</span></span><br><span class="line">        scores = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过初始化后，就可以直接赋值</span></span><br><span class="line">    scores[<span class="string">&quot;chinese&quot;</span>] = <span class="number">90</span></span><br><span class="line">    fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-3-常用操作"><a href="#7-5-3-常用操作" class="headerlink" title="7.5.3 常用操作"></a>7.5.3 常用操作</h3><h4 id="7-5-3-1-赋值"><a href="#7-5-3-1-赋值" class="headerlink" title="7.5.3.1 赋值"></a>7.5.3.1 赋值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;mike&quot;</span>, <span class="number">2</span>: <span class="string">&quot;yoyo&quot;</span>&#125;</span><br><span class="line">m1[<span class="number">1</span>] = <span class="string">&quot;xxx&quot;</span>   <span class="comment">//修改</span></span><br><span class="line">m1[<span class="number">3</span>] = <span class="string">&quot;lily&quot;</span>  <span class="comment">//追加， go底层会自动为map分配空间</span></span><br><span class="line">fmt.Println(m1) <span class="comment">//map[1:xxx 2:yoyo 3:lily]</span></span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>) <span class="comment">//创建map</span></span><br><span class="line">m2[<span class="number">0</span>] = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">m2[<span class="number">1</span>] = <span class="string">&quot;bbb&quot;</span></span><br><span class="line">fmt.Println(m2)           <span class="comment">//map[0:aaa 1:bbb]</span></span><br><span class="line">fmt.Println(m2[<span class="number">0</span>], m2[<span class="number">1</span>]) <span class="comment">//aaa bbb</span></span><br></pre></td></tr></table></figure><h4 id="7-5-3-2-遍历"><a href="#7-5-3-2-遍历" class="headerlink" title="7.5.3.2 遍历"></a>7.5.3.2 遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">scores := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代遍历1，第一个返回值是key，第二个返回值是value</span></span><br><span class="line"><span class="keyword">for</span> subject, score := <span class="keyword">range</span> scores &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;key: %s, value: %d\n&quot;</span>, subject, score)</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代遍历2,只要key,这里注意不用占用符。</span></span><br><span class="line"><span class="keyword">for</span> subject := <span class="keyword">range</span> scores &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;key: %s\n&quot;</span>, subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代遍历3，只获取 value，用一个占位符替代。</span></span><br><span class="line"><span class="keyword">for</span> _, score := <span class="keyword">range</span> scores &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;value: %d\n&quot;</span>, score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个key所对应的value是否存在, 第一个返回值是value(如果存在的话)</span></span><br><span class="line">value, ok := m1[<span class="number">1</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;value = &quot;</span>, value, <span class="string">&quot;, ok = &quot;</span>, ok) <span class="comment">//value =  mike , ok =  true</span></span><br><span class="line"></span><br><span class="line">value2, ok2 := m1[<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;value2 = &quot;</span>, value2, <span class="string">&quot;, ok2 = &quot;</span>, ok2) <span class="comment">//value2 =   , ok2 =  false</span></span><br></pre></td></tr></table></figure><h4 id="7-5-3-3-删除"><a href="#7-5-3-3-删除" class="headerlink" title="7.5.3.3 删除"></a>7.5.3.3 删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;mike&quot;</span>, <span class="number">2</span>: <span class="string">&quot;yoyo&quot;</span>, <span class="number">3</span>: <span class="string">&quot;lily&quot;</span>&#125;</span><br><span class="line"><span class="comment">//迭代遍历1，第一个返回值是key，第二个返回值是value</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    <span class="comment">//1 ----&gt; mike</span></span><br><span class="line">    <span class="comment">//2 ----&gt; yoyo</span></span><br><span class="line">    <span class="comment">//3 ----&gt; lily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m1, <span class="number">2</span>) <span class="comment">//删除key值为3的map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    <span class="comment">//1 ----&gt; mike</span></span><br><span class="line">    <span class="comment">//3 ----&gt; lily</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-4-map做函数参数"><a href="#7-5-4-map做函数参数" class="headerlink" title="7.5.4 map做函数参数"></a>7.5.4 map做函数参数</h3><p>在函数间传递映射并不会制造出该映射的一个副本，不是值传递，而是引用传递：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(m, key) <span class="comment">//删除key值为3的map</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(m)=%d, %d ----&gt; %s\n&quot;</span>, <span class="built_in">len</span>(m), k, v)</span><br><span class="line">        <span class="comment">//len(m)=2, 1 ----&gt; mike</span></span><br><span class="line">        <span class="comment">//len(m)=2, 3 ----&gt; lily</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;mike&quot;</span>, <span class="number">2</span>: <span class="string">&quot;yoyo&quot;</span>, <span class="number">3</span>: <span class="string">&quot;lily&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    DeleteMap(m, <span class="number">2</span>) <span class="comment">//删除key值为3的map</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(m)=%d, %d ----&gt; %s\n&quot;</span>, <span class="built_in">len</span>(m), k, v)</span><br><span class="line">        <span class="comment">//len(m)=2, 1 ----&gt; mike</span></span><br><span class="line">        <span class="comment">//len(m)=2, 3 ----&gt; lily</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-map"><a href="#sync-map" class="headerlink" title="sync map"></a>sync map</h2><p>map是存在并发危险的，并发读没有关系，但是一个协程在读，一个协程在写，很容易panic，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = m[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以往往我们会加锁，像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">然后读写的时候去加锁解锁</span><br></pre></td></tr></table></figure><p>然后有一个维护好并发的map库：sync map</p><p>具体可以看：<br><a href="https://juejin.cn/post/6994390901476818957/">https://juejin.cn/post/6994390901476818957/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】Go语言复合类型-数组和切片</title>
      <link href="/202107/30984/"/>
      <url>/202107/30984/</url>
      
        <content type="html"><![CDATA[<h2 id="7-3-数组"><a href="#7-3-数组" class="headerlink" title="7.3 数组"></a>7.3 数组</h2><h3 id="7-3-1-概述"><a href="#7-3-1-概述" class="headerlink" title="7.3.1 概述"></a>7.3.1 概述</h3><p>数组是指一系列同一类型数据的集合。数组中包含的每个数据被称为数组元素（element），一个数组包含的元素个数被称为数组的长度。</p><p>数组⻓度必须是常量，且是类型的组成部分。 [2]int 和 [3]int 是不同类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a [n]<span class="keyword">int</span>  <span class="comment">//err, non-constant array bound n</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">10</span>]<span class="keyword">int</span> <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><h3 id="7-3-2-操作数组"><a href="#7-3-2-操作数组" class="headerlink" title="7.3.2 操作数组"></a>7.3.2 操作数组</h3><p>数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//range具有两个返回值，第一个返回值是元素的数组下标，第二个返回值是元素的值</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a[&quot;</span>, i, <span class="string">&quot;]=&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置函数 len(长度) 和 cap(容量) 都返回数组⻓度 (元素数量)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := [10]int&#123;&#125;</span><br><span class="line">fmt.Println(len(a), cap(a))//10 10</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0</span></span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;      <span class="comment">// 通过初始化值确定数组长度</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 通过索引号初始化元素，未初始化元素值为 0</span></span><br><span class="line">fmt.Println(a, b, c)        <span class="comment">//[1 2 0] [1 2 3] [0 0 100 0 200]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持多维数组</span></span><br><span class="line">d := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">10</span>, <span class="number">11</span>&#125;, &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, &#123;<span class="number">30</span>, <span class="number">31</span>&#125;, &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125;</span><br><span class="line">e := [...][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">10</span>, <span class="number">11</span>&#125;, &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, &#123;<span class="number">30</span>, <span class="number">31</span>&#125;, &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125; <span class="comment">//第二维不能写&quot;...&quot;</span></span><br><span class="line">f := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, <span class="number">3</span>: &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125;</span><br><span class="line">g := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">0</span>: <span class="number">20</span>&#125;, <span class="number">3</span>: &#123;<span class="number">1</span>: <span class="number">41</span>&#125;&#125;</span><br><span class="line">fmt.Println(d, e, f, g)</span><br></pre></td></tr></table></figure><p>相同类型的数组之间可以使用 == 或 != 进行比较，但不可以使用 &lt; 或 &gt;，也可以相互赋值：\</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">c := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(a == b, b == c) <span class="comment">//true false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">d = a</span><br><span class="line">fmt.Println(d) <span class="comment">//[1 2 3]</span></span><br></pre></td></tr></table></figure><h3 id="7-3-3-在函数间传递数组"><a href="#7-3-3-在函数间传递数组" class="headerlink" title="7.3.3 在函数间传递数组"></a>7.3.3 在函数间传递数组</h3><p>根据内存和性能来看，在函数间传递数组是一个开销很大的操作。在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 试图修改数组的第一个元素</span></span><br><span class="line">    <span class="comment">//In modify(), array values: [10 2 3 4 5]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;In modify(), array values:&quot;</span>, array)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 定义并初始化一个数组</span></span><br><span class="line">    modify(array)                  <span class="comment">// 传递给一个函数，并试图在函数体内修改这个数组内容</span></span><br><span class="line">    <span class="comment">//In main(), array values: [1 2 3 4 5]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;In main(), array values:&quot;</span>, array)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">数组指针做函数参数：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    (*array)[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    <span class="comment">//In modify(), array values: [10 2 3 4 5]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;In modify(), array values:&quot;</span>, *array)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 定义并初始化一个数组</span></span><br><span class="line">    modify(&amp;array)                 <span class="comment">// 数组指针</span></span><br><span class="line">    <span class="comment">//In main(), array values: [10 2 3 4 5]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;In main(), array values:&quot;</span>, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-4-数组指针"><a href="#7-3-4-数组指针" class="headerlink" title="7.3.4 数组指针"></a>7.3.4 数组指针</h3><p>一个int需要8套别墅，8个int需要64套别墅，一样的道理，只需要告诉别人首地址，然后后面64套都是我的，别人怎么知道64？因为通过类型和长度可以推导出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//必须有个main包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(p *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    (*p)[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;modify *a = &quot;</span>, *p) <span class="comment">//modify *a =  [666 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//初始化</span></span><br><span class="line">    modify(&amp;a) <span class="comment">//地址传递</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main: a = &quot;</span>, a) <span class="comment">//main: a =  [666 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-slice"><a href="#7-4-slice" class="headerlink" title="7.4 slice"></a>7.4 slice</h2><h3 id="7-4-1-概述"><a href="#7-4-1-概述" class="headerlink" title="7.4.1 概述"></a>7.4.1 概述</h3><p>数组的缺点：长度在定义之后无法再次修改；数组是值类型，每次传递都将产生一份副本。</p><p>显然这种数据结构无法完全满足开发者的真实需求。Go语言提供了数组切片（slice）来弥补数组的不足。</p><p>切片并不是数组或数组指针，它通过内部指针和相关属性引⽤数组⽚段，以实现变⻓⽅案。</p><p>slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfa3691ed0dc474fa0a7f0fac3eb85a1~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfa3691ed0dc474fa0a7f0fac3eb85a1~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片2.png" title="图片2.png"></p><h3 id="7-4-2-切片的创建和初始化"><a href="#7-4-2-切片的创建和初始化" class="headerlink" title="7.4.2 切片的创建和初始化"></a>7.4.2 切片的创建和初始化</h3><p>slice和数组的区别：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span> <span class="comment">//声明切片和声明array一样，只是少了长度，此为空(nil)切片</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make([]T, length, capacity) //capacity省略，则和length的值相同</span></span><br><span class="line"><span class="keyword">var</span> s3 []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">s5 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">//创建切片并初始化</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：make只能创建slice、map和channel，并且返回一个有初始值(非零)。</p><blockquote><p>提示：如果可以提前预估数组大小，建议根据预估的大小，创建切片，避免切片动态调整数组大小带来的数据拷贝的性能消耗。</p></blockquote><h3 id="7-4-3-切片的操作"><a href="#7-4-3-切片的操作" class="headerlink" title="7.4.3 切片的操作"></a>7.4.3 切片的操作</h3><h4 id="7-4-3-1-切片截取"><a href="#7-4-3-1-切片截取" class="headerlink" title="7.4.3.1 切片截取"></a>7.4.3.1 切片截取</h4><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>s[n]</td><td>切片s中索引位置为n的项</td></tr><tr><td>s[:]</td><td>从切片s的索引位置0到len(s)-1处所获得的切片</td></tr><tr><td>s[low:]</td><td>从切片s的索引位置low到len(s)-1处所获得的切片</td></tr><tr><td>s[:high]</td><td>从切片s的索引位置0到high处所获得的切片，len=high</td></tr><tr><td>s[low:high]</td><td>从切片s的索引位置low到high处所获得的切片，len=high-low</td></tr><tr><td>s[low:high:max]</td><td>从切片s的索引位置low到high处所获得的切片，len=high-low，cap=max-low</td></tr><tr><td>len(s)</td><td>切片s的长度，总是&lt;=cap(s)</td></tr><tr><td>cap(s)</td><td>切片s的容量，总是&gt;=len(s)</td></tr></tbody></table><p>示例说明：</p><pre><code>array := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</code></pre><table><thead><tr><th>操作</th><th>结果</th><th>len</th><th>cap</th><th>说明</th></tr></thead><tbody><tr><td>array [:6:8]</td><td>[0 1 2 3 4 5]</td><td>6</td><td>8</td><td>省略 low</td></tr><tr><td>array[5:]</td><td>[5 6 7 8 9]</td><td>5</td><td>5</td><td>省略 high、 max</td></tr><tr><td>array[:3]</td><td>[0 1 2]</td><td>3</td><td>10</td><td>省略 high、 max</td></tr><tr><td>array[:]</td><td>[0 1 2 3 4 5 6 7 8 9]</td><td>10</td><td>10</td><td>全部省略</td></tr></tbody></table><h4 id="7-4-3-2-切片和底层数组关系"><a href="#7-4-3-2-切片和底层数组关系" class="headerlink" title="7.4.3.2 切片和底层数组关系"></a>7.4.3.2 切片和底层数组关系</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := s[<span class="number">2</span>:<span class="number">5</span>]       <span class="comment">//[2 3 4]</span></span><br><span class="line">s1[<span class="number">2</span>] = <span class="number">100</span>        <span class="comment">//修改切片某个元素改变底层数组</span></span><br><span class="line">fmt.Println(s1, s) <span class="comment">//[2 3 100] [0 1 2 3 100 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">s2 := s1[<span class="number">2</span>:<span class="number">6</span>] <span class="comment">// 新切片依旧指向原底层数组 [100 5 6 7]</span></span><br><span class="line">s2[<span class="number">3</span>] = <span class="number">200</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 5 6 200]</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s) <span class="comment">//[0 1 2 3 100 5 6 200 8 9]</span></span><br></pre></td></tr></table></figure><h4 id="7-4-3-3-内建函数"><a href="#7-4-3-3-内建函数" class="headerlink" title="7.4.3.3 内建函数"></a>7.4.3.3 内建函数</h4><h5 id="1-append"><a href="#1-append" class="headerlink" title="1) append"></a>1) append</h5><p>append函数向 slice 尾部添加数据，返回新的 slice 对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span> <span class="comment">//创建nil切换</span></span><br><span class="line"><span class="comment">//s1 := make([]int, 0)</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>)       <span class="comment">//追加1个元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">//追加2个元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">//追加3个元素</span></span><br><span class="line">fmt.Println(s1)          <span class="comment">//[1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">6</span>)</span><br><span class="line">fmt.Println(s2) <span class="comment">//[0 0 0 0 0 6]</span></span><br><span class="line"></span><br><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s3 = <span class="built_in">append</span>(s3, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(s3)<span class="comment">//[1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>append函数会智能地底层数组的容量增长，一旦超过原底层数组容量，通常以2倍容量重新分配底层数组，并复制原来的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    c := <span class="built_in">cap</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        <span class="keyword">if</span> n := <span class="built_in">cap</span>(s); n &gt; c &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;cap: %d -&gt; %d\n&quot;</span>, c, n)</span><br><span class="line">            c = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cap: 1 -&gt; 2</span></span><br><span class="line"><span class="comment">        cap: 2 -&gt; 4</span></span><br><span class="line"><span class="comment">        cap: 4 -&gt; 8</span></span><br><span class="line"><span class="comment">        cap: 8 -&gt; 16</span></span><br><span class="line"><span class="comment">        cap: 16 -&gt; 32</span></span><br><span class="line"><span class="comment">        cap: 32 -&gt; 64</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>copy</li></ol><p>函数 copy 在两个 slice 间复制数据，复制⻓度以 len 小的为准，两个 slice 可指向同⼀底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">s1 := data[<span class="number">8</span>:]  <span class="comment">//&#123;8, 9&#125;</span></span><br><span class="line">s2 := data[:<span class="number">5</span>] <span class="comment">//&#123;0, 1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="built_in">copy</span>(s2, s1)    <span class="comment">// dst:s2, src:s1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s2)   <span class="comment">//[8 9 2 3 4]</span></span><br><span class="line">fmt.Println(data) <span class="comment">//[8 9 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure><h3 id="7-4-4-切片做函数参数"><a href="#7-4-4-切片做函数参数" class="headerlink" title="7.4.4 切片做函数参数"></a>7.4.4 切片做函数参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//切片做函数参数</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test : &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;s[%d]=%d, &quot;</span>, i, v)</span><br><span class="line">        <span class="comment">//s[0]=-1, s[1]=1, s[2]=2, s[3]=3, s[4]=4, s[5]=5, s[6]=6, s[7]=7, s[8]=8, s[9]=9,</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    test(slice)</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;main : &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;slice[%d]=%d, &quot;</span>, i, v)</span><br><span class="line">        <span class="comment">//slice[0]=-1, slice[1]=1, slice[2]=2, slice[3]=3, </span></span><br><span class="line">        <span class="comment">//slice[4]=4, slice[5]=5, slice[6]=6, slice[7]=7, slice[8]=8, slice[9]=9,</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：切片只是引用数组，所以效率非常高，例如在函数传参的时候，使用切片传递数组参数，不会复制数组。</p></blockquote><h3 id="7-4-5-cap和len的区别"><a href="#7-4-5-cap和len的区别" class="headerlink" title="7.4.5 cap和len的区别"></a>7.4.5 cap和len的区别</h3><p>简单点说，len(sli)表示可见元素有几个（即直接打印元素看到的元素个数），而cap(sli)表示所有元素有几个，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">sli := arr[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(sli) <span class="comment">//[3 5 7]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(sli))<span class="comment">//3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(sli))<span class="comment">//5</span></span><br></pre></td></tr></table></figure><h3 id="7-4-6-切片和底层数组"><a href="#7-4-6-切片和底层数组" class="headerlink" title="7.4.6 切片和底层数组"></a>7.4.6 切片和底层数组</h3><p>同一个数组可以生成多个切片，当修改A切片时，底层数组会直接变，如果B切片刚好引用了同一个地方，则也会被改变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//必须有个main包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"> </span><br><span class="line">    s1 := a[<span class="number">2</span>:<span class="number">5</span>] </span><br><span class="line">    s2 := s1[<span class="number">1</span>:<span class="number">7</span>]</span><br><span class="line"> </span><br><span class="line">    s1[<span class="number">1</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;s1 = &quot;</span>, s1) <span class="comment">//s1 =  [2 666 4]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a) <span class="comment">//a =  [0 1 2 666 4 5 6 7 8 9]</span></span><br><span class="line"> </span><br><span class="line">    s2[<span class="number">1</span>] = <span class="number">777</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2) <span class="comment">//s2 =  [666 777 5 6 7 8]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a) <span class="comment">//a =  [0 1 2 666 777 5 6 7 8 9]</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;s1 = &quot;</span>, s1)<span class="comment">//s1 =  [2 666 777]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以看出，切片其实是通过指针，取的底层数组的一部分数据。</p><blockquote><p>提示：可以从数组中定义切片，也可以从切片中定义新的切片。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】Go语言复合类型-指针</title>
      <link href="/202107/7741/"/>
      <url>/202107/7741/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-分类"><a href="#7-1-分类" class="headerlink" title="7.1 分类"></a>7.1 分类</h2><ul><li>pointer  指针</li><li>array 数组</li><li>slice 切片</li><li>map 字典</li><li>struct 结构体</li></ul><h2 id="7-2指针"><a href="#7-2指针" class="headerlink" title="7.2指针"></a>7.2指针</h2><p>指针是一个代表着某个内存地址的值。这个内存地址往往是在内存中存储的另一个变量的值的起始位置。</p><h3 id="7-2-1-基本操作"><a href="#7-2-1-基本操作" class="headerlink" title="7.2.1 基本操作"></a>7.2.1 基本操作</h3><p>Go语言虽然保留了指针，但与其它编程语言不同的是：</p><ul><li> 默认值 nil，没有 NULL 常量</li><li> 操作符 “&amp;” 取变量地址， “*” 通过指针访问目标对象</li><li> 不支持指针运算，不支持 “-&gt;” 运算符，直接⽤ “.” 访问目标成员</li></ul><p>如果将计算的内存看成一排别墅，每个别墅里面只装0或者1，一个int型数据需要8栋别墅，但是我告诉别人我的地址是0001-0008，只需要说从0001开始，后面8套都是我的。这个0001就叫<strong>首地址</strong>。取变量地址也就是首地址。而别墅里面的内容就叫目标对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="comment">//每个变量有2层含义：变量的内存，变量的地址</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a) <span class="comment">//内存中存放的东西，也就是别墅里面的0或者1。</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;&amp;a = %v\n&quot;</span>, &amp;a) <span class="comment">//内存的首地址，也就是0001。</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*输出</span></span><br><span class="line"><span class="comment">        a = 10</span></span><br><span class="line"><span class="comment">        &amp;a = 0xc000010080</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//现在需要存储这个地址，指针就是专门存放这种地址的。</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span> <span class="comment">//定义指针类型变量,int型的数据就要用*int 为什么？因为要告诉后面8套都是我的。这个8是根据类型来的。</span></span><br><span class="line">    p = &amp;a <span class="comment">//把a的地址赋值给p</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p = %v, &amp;a = %v\n&quot;</span>, p, &amp;a)<span class="comment">//p = 0xc000010080, &amp;a = 0xc000010080</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//再来改p里面的数据，会直接改动a</span></span><br><span class="line">    *p = <span class="number">666</span> <span class="comment">//*p操作的不是p的内存，是p所指向的内存(就是a)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;*p = %v, a = %v\n&quot;</span>, *p, a)<span class="comment">//*p = 666, a = 666</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//既然P是一个变量，那么它也肯定有地址存储</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;&amp;p = %v\n&quot;</span>, &amp;p)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//再把这个地址用指针存储起来,需要再加一个*</span></span><br><span class="line">    <span class="keyword">var</span> p2 **<span class="keyword">int</span>  </span><br><span class="line">    p2 = &amp;p</span><br><span class="line">    fmt.Printf(<span class="string">&quot;&amp;p = %v\n&quot;</span>, p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-new函数"><a href="#7-2-2-new函数" class="headerlink" title="7.2.2 new函数"></a>7.2.2 new函数</h3><p>表达式new(T)将创建一个T类型的匿名变量，所做的是为T类型的新值分配并清零一块内存空间，然后将这块内存空间的地址作为结果返回，而这个结果就是指向这个新的T类型值的指针值，<strong>返回的指针类型为*T</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 *<span class="keyword">int</span></span><br><span class="line">    p1 = <span class="built_in">new</span>(<span class="keyword">int</span>)              <span class="comment">//p1为*int 类型, 指向匿名的int变量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*p1 = &quot;</span>, *p1) <span class="comment">//*p1 =  0</span></span><br><span class="line"> </span><br><span class="line">    p2 := <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">//p2为*int 类型, 指向匿名的int变量</span></span><br><span class="line">    *p2 = <span class="number">111</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*p2 = &quot;</span>, *p2) <span class="comment">//*p1 =  111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需使用new()函数，无需担心其内存的生命周期或怎样将其删除，因为Go语言的内存管理系统会帮我们打理一切。</p><p>这里有人可能会联想到其他语言的new或者malloc，是不是在堆区申请的？Go的变量具体在堆还是栈，是有个逃逸分析的，编译器会判断你适合在堆还是栈。</p><h3 id="7-2-3-指针做函数参数"><a href="#7-2-3-指针做函数参数" class="headerlink" title="7.2.3 指针做函数参数"></a>7.2.3 指针做函数参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap01</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a, b = b, a</span><br><span class="line">    fmt.Printf(<span class="string">&quot;swap01 a = %d, b = %d\n&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap02</span><span class="params">(x, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x, *y = *y, *x</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//swap01(a, b) //值传递</span></span><br><span class="line">    swap02(&amp;a, &amp;b) <span class="comment">//变量地址传递</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-4-野指针"><a href="#7-2-4-野指针" class="headerlink" title="7.2.4 野指针"></a>7.2.4 野指针</h3><p>如果我说0001是我的首地址，但是其实这个位置有人了，这样会导致改变他人的数据。</p><p>如果我说0000是我的首地址，但是这个地址都不存在，或者是不可用的地址，那我就是野指针。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    p = <span class="literal">nil</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;p = &quot;</span>, p)<span class="comment">//p =  &lt;nil&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//*p = 666 //err, 因为p没有合法指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>GO其实在很大程度上简化了指针，不用像C那样考虑指针的指针，但是依然要考虑内存，比如内存屏障、页的置换等，尤其是在高并发场景。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】Go语言的工程管理</title>
      <link href="/202107/51142/"/>
      <url>/202107/51142/</url>
      
        <content type="html"><![CDATA[<h2 id="06-工程管理"><a href="#06-工程管理" class="headerlink" title="06.工程管理"></a>06.工程管理</h2><p>在实际的开发工作中，直接调用编译器进行编译和链接的场景是少而又少，因为在工程中不会简单到只有一个源代码文件，且源文件之间会有相互的依赖关系。如果这样一个文件一个文件逐步编译，那不亚于一场灾难。 Go语言的设计者作为行业老将，自然不会忽略这一点。早期Go语言使用makefile作为临时方案，到了Go 1发布时引入了强大无比的Go命令行工具。</p><p>Go命令行工具的革命性之处在于彻底消除了工程文件的概念，完全用目录结构和包名来推导工程结构和构建顺序。针对只有一个源文件的情况讨论工程管理看起来会比较多余，因为这可以直接用go run和go build搞定。下面我们将用一个更接近现实的虚拟项目来展示Go语言的基本工程管理方法。</p><h2 id="6-1-工作区"><a href="#6-1-工作区" class="headerlink" title="6.1 工作区"></a>6.1 工作区</h2><h3 id="6-1-1-工作区介绍"><a href="#6-1-1-工作区介绍" class="headerlink" title="6.1.1 工作区介绍"></a>6.1.1 工作区介绍</h3><p>Go代码必须放在工作区（goPath）中（现在有mod就不一定了）。包含3个子目录：src目录、pkg目录和bin目录。</p><ul><li> src目录：用于以代码包的形式组织并保存Go源码文件。（比如：.go .c .h .s等）</li><li> pkg目录：用于存放经由go install命令构建安装后的代码包（包含Go库源码文件）的“.a”归档文件。</li><li> bin目录：与pkg目录类似，在通过go install命令完成安装后，保存由Go命令源码文件生成的可执行文件。</li></ul><p>目录src用于包含所有的源代码，是Go命令行工具一个强制的规则，而pkg和bin则无需手动创建，如果必要Go命令行工具在构建过程中会自动创建这些目录。</p><p>需要特别注意的是：只有当环境变量GOPATH中只包含一个工作区的目录路径时，go install命令才会把命令源码安装到当前工作区的bin目录下。若环境变量GOPATH中包含多个工作区的目录路径，像这样执行go install命令就会失效，此时必须设置环境变量GOBIN。</p><h3 id="6-1-2-GOPATH设置"><a href="#6-1-2-GOPATH设置" class="headerlink" title="6.1.2 GOPATH设置"></a>6.1.2 GOPATH设置</h3><p>为了能够构建这个工程，需要先把所需工程的根目录加入到环境变量GOPATH中。否则，即使处于同一工作目录(工作区)，代码之间也无法通过绝对代码包路径完成调用。</p><p>在实际开发环境中，工作目录往往有多个。这些工作目录的目录路径都需要添加至GOPATH。当有多个目录时，请注意分隔符，多个目录的时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，默认会将go get的内容放在第一个目录下。</p><h2 id="6-2-包"><a href="#6-2-包" class="headerlink" title="6.2 包"></a>6.2 包</h2><p>所有 Go 语言的程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都可以作为很小的复用单元，被其他项目引用。</p><p>一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。</p><ul><li>文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。</li><li>文件夹名与包名没有直接关系，并非需要一致。</li><li>同一个文件夹下的文件只能有一个包名，否则编译报错。</li><li>同一个文件夹下（同一个包）互相调用函数不用引用包。（本质上可以看做是一个文件）</li></ul><blockquote><p>一个文件夹一个包，包内调用不用加引用，但是注意调用的函数需要首字母大写，表示public。</p></blockquote><h3 id="6-2-1-自定义包"><a href="#6-2-1-自定义包" class="headerlink" title="6.2.1 自定义包"></a>6.2.1 自定义包</h3><p>对于一个较大的应用程序，我们应该将它的功能性分隔成逻辑的单元，分别在不同的包里实现。我们创建的的自定义包最好放在GOPATH的src目录下（或者GOPATH src的某个子目录）。</p><p>在Go语言中，代码包中的源码文件名可以是任意的。但是，这些任意名称的源码文件都必须以包声明语句作为文件中的第一行，每个包都对应一个独立的名字空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package calc</span><br></pre></td></tr></table></figure><p>包中成员以名称⾸字母⼤⼩写决定访问权限：</p><ul><li>  public: ⾸字母⼤写，可被包外访问</li><li>  private: ⾸字母⼩写，仅包内成员可以访问</li></ul><p><strong>注意：</strong> 同一个目录下不能定义不同的package。</p><h3 id="6-2-2-main包"><a href="#6-2-2-main包" class="headerlink" title="6.2.2 main包"></a>6.2.2 main包</h3><p>在 Go 语言里，命名为 main 的包具有特殊的含义。 Go 语言的编译程序会试图把这种名字的包编译为二进制可执行文件。所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。一个可执行程序有且仅有一个 main 包。</p><p>当编译器发现某个包的名字为 main 时，它一定也会发现名为 main()的函数，否则不会创建可执行文件。 main()函数是程序的入口，所以，如果没有这个函数，程序就没有办法开始执行。程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。</p><h3 id="6-2-3-main函数和init函数"><a href="#6-2-3-main函数和init函数" class="headerlink" title="6.2.3 main函数和init函数"></a>6.2.3 main函数和init函数</h3><p>Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。</p><p>Go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。</p><p>每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。<strong>所有被编译器发现的 init 函数都会安排在 main 函数之前执行。</strong> init 函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。</p><p>程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。</p><p>有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。</p><p>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22da5d9af9d64cc39061020b894d062d~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22da5d9af9d64cc39061020b894d062d~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="init.png" title="init.png"></p><p>示例代码目录结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa8955f629ba411d86fa476d2b941dec~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa8955f629ba411d86fa476d2b941dec~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片1.png" title="图片1.png"></p><p><strong><strong>main</strong></strong> <strong><strong>.go</strong></strong>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go main() is called&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    test.Test()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">test.<span class="keyword">go</span>示例代码如下：</span><br><span class="line"><span class="comment">//test.go</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;test.go init() is called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;test.go Test() is called&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93898ef83c9d41dab6b0f1ce93a39b75~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93898ef83c9d41dab6b0f1ce93a39b75~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" title="image.png"></p><h3 id="6-2-4-导入包"><a href="#6-2-4-导入包" class="headerlink" title="6.2.4 导入包"></a>6.2.4 导入包</h3><p>导入包需要使用关键字import，它会告诉编译器你想引用该位置的包内的代码。包的路径可以是相对路径，也可以是绝对路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;calc&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;calc&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>标准库中的包会在安装 Go 的位置找到。 Go 开发者创建的包会在 GOPATH 环境变量指定的目录里查找。GOPATH 指定的这些目录就是开发者的个人工作空间。</p><p>如果编译器查遍 GOPATH 也没有找到要导入的包，那么在试图对程序执行 run 或者 build的时候就会出错。</p><p><strong>注意：如果导入包之后，未调用其中的函数或者类型将会报出编译错误。</strong></p><h4 id="6-2-4-1-点操作"><a href="#6-2-4-1-点操作" class="headerlink" title="6.2.4.1 点操作"></a>6.2.4.1 点操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//这个点操作的含义是这个包导入之后在你调用这个包的函数时，可以省略前缀的包名</span></span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-4-2-别名操作"><a href="#6-2-4-2-别名操作" class="headerlink" title="6.2.4.2 别名操作"></a>6.2.4.2 别名操作</h4><p>在导⼊时，可指定包成员访问⽅式，⽐如对包重命名，以避免同名冲突：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    io <span class="string">&quot;fmt&quot;</span> <span class="comment">//fmt改为为io</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    io.Println(<span class="string">&quot;hello go&quot;</span>) <span class="comment">//通过io别名调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-4-3-操作"><a href="#6-2-4-3-操作" class="headerlink" title="6.2.4.3 _操作"></a>6.2.4.3 _操作</h4><p>有时，用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用空白标识符_来重命名这个导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】函数</title>
      <link href="/202107/6545/"/>
      <url>/202107/6545/</url>
      
        <content type="html"><![CDATA[<h1 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h1><h2 id="5-1-定义格式"><a href="#5-1-定义格式" class="headerlink" title="5.1 定义格式"></a>5.1 定义格式</h2><p>函数构成代码执行的逻辑结构。</p><p>在Go语言中，函数的基本组成为：关键字func、函数名、参数列表、返回值、函数体和返回语句。</p><p>Go 语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(/*参数列表*/)</span> <span class="params">(o1 type1, o2 type2/*返回类型*/)</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> v1, v2 <span class="comment">//返回多个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义说明：</p><ul><li>func：函数由关键字 func 开始声明</li><li>FuncName：函数名称，根据约定，函数名首字母小写即为private，大写即为public</li><li>参数列表：函数可以有0个或多个参数，参数格式为：变量名 类型，如果有多个参数通过逗号分隔，不支持默认参数</li><li>返回类型：<ol><li>上面返回值声明了两个变量名o1和o2(命名返回参数)，这个不是必须，可以只有类型没有变量名</li><li>如果只有一个返回值且不声明返回值变量，那么你可以省略，包括返回值的括号</li><li>如果没有返回值，那么就直接省略最后的返回信息</li><li>如果有返回值， 那么必须在函数的内部添加return语句</li></ol></li></ul><h2 id="5-2-自定义函数"><a href="#5-2-自定义函数" class="headerlink" title="5.2 自定义函数"></a>5.2 自定义函数</h2><h3 id="5-2-1-无参无返回值"><a href="#5-2-1-无参无返回值" class="headerlink" title="5.2.1 无参无返回值"></a>5.2.1 无参无返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123; <span class="comment">//无参无返回值函数定义</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;this is a test func&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test() <span class="comment">//无参无返回值函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-有参无返回值"><a href="#5-2-2-有参无返回值" class="headerlink" title="5.2.2 有参无返回值"></a>5.2.2 有参无返回值</h3><h4 id="5-2-2-1-普通参数列表"><a href="#5-2-2-1-普通参数列表" class="headerlink" title="5.2.2.1 普通参数列表"></a>5.2.2.1 普通参数列表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test01</span><span class="params">(v1 <span class="keyword">int</span>, v2 <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//方式1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;v1 = %d, v2 = %d\n&quot;</span>, v1, v2)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test02</span><span class="params">(v1, v2 <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//方式2, v1, v2都是int类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;v1 = %d, v2 = %d\n&quot;</span>, v1, v2)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test01(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//函数调用</span></span><br><span class="line">    Test02(<span class="number">11</span>, <span class="number">22</span>) <span class="comment">//函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-2-不定参数列表"><a href="#5-2-2-2-不定参数列表" class="headerlink" title="5.2.2.2 不定参数列表"></a>5.2.2.2 不定参数列表</h4><ol><li>不定参数类型<br>不定参数是指函数传入的参数个数为不定数量。</li></ol><p>为了做到这点，首先需要将函数定义为接受不定参数类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形如...type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> args &#123; <span class="comment">//遍历参数列表</span></span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数调用，可传0到多个参数</span></span><br><span class="line">    Test()</span><br><span class="line">    Test(<span class="number">1</span>)</span><br><span class="line">    Test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>不定参数的传递<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc01</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;MyFunc01&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> args &#123; <span class="comment">//遍历参数列表</span></span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc02</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;MyFunc02&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> args &#123; <span class="comment">//遍历参数列表</span></span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    MyFunc01(args...)     <span class="comment">//按原样传递, Test()的参数原封不动传递给MyFunc01</span></span><br><span class="line">    MyFunc02(args[<span class="number">1</span>:]...) <span class="comment">//Test()参数列表中，第1个参数及以后的参数传递给MyFunc02</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多个类型不一致的参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyPrintf</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">        <span class="keyword">switch</span> arg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">            fmt.Println(arg, <span class="string">&quot;is an int value.&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Println(arg, <span class="string">&quot;is a string value.&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Println(arg, <span class="string">&quot;is an int64 value.&quot;</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(arg, <span class="string">&quot;is an unknown type.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> v2 <span class="keyword">int64</span> = <span class="number">234</span></span><br><span class="line">    <span class="keyword">var</span> v3 <span class="keyword">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">var</span> v4 <span class="keyword">float32</span> = <span class="number">1.234</span></span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-无参有返回值"><a href="#5-2-3-无参有返回值" class="headerlink" title="5.2.3 无参有返回值"></a>5.2.3 无参有返回值</h3>有返回值的函数，必须有明确的终止语句，否则会引发编译错误。</li></ol><h4 id="5-2-3-1-一个返回值"><a href="#5-2-3-1-一个返回值" class="headerlink" title="5.2.3.1 一个返回值"></a>5.2.3.1 一个返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test01</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">//方式1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">250</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test02</span><span class="params">()</span> <span class="params">(value <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//方式2, 给返回值命名</span></span><br><span class="line">    value = <span class="number">250</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test03</span><span class="params">()</span> <span class="params">(value <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//方式3, 给返回值命名</span></span><br><span class="line">    value = <span class="number">250</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := Test01() <span class="comment">//函数调用</span></span><br><span class="line">    v2 := Test02() <span class="comment">//函数调用</span></span><br><span class="line">    v3 := Test03() <span class="comment">//函数调用</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;v1 = %d, v2 = %d, v3 = %d\n&quot;</span>, v1, v2, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-3-2-多个返回值"><a href="#5-2-3-2-多个返回值" class="headerlink" title="5.2.3.2 多个返回值"></a>5.2.3.2 多个返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test01</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123; <span class="comment">//方式1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">250</span>, <span class="string">&quot;sb&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test02</span><span class="params">()</span> <span class="params">(a <span class="keyword">int</span>, str <span class="keyword">string</span>)</span></span> &#123; <span class="comment">//方式2, 给返回值命名</span></span><br><span class="line">    a = <span class="number">250</span></span><br><span class="line">    str = <span class="string">&quot;sb&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1, v2 := Test01() <span class="comment">//函数调用</span></span><br><span class="line">    _, v3 := Test02()  <span class="comment">//函数调用， 第一个返回值丢弃</span></span><br><span class="line">    v4, _ := Test02()  <span class="comment">//函数调用， 第二个返回值丢弃</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;v1 = %d, v2 = %s, v3 = %s, v4 = %d\n&quot;</span>, v1, v2, v3, v4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-4-有参有返回值"><a href="#5-2-4-有参有返回值" class="headerlink" title="5.2.4 有参有返回值"></a>5.2.4 有参有返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求2个数的最小值和最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MinAndMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(min <span class="keyword">int</span>, max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt; num2 &#123; <span class="comment">//如果num1 大于 num2</span></span><br><span class="line">        min = num2</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">        min = num1</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    min, max := MinAndMax(<span class="number">33</span>, <span class="number">22</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;min = %d, max = %d\n&quot;</span>, min, max) <span class="comment">//min = 22, max = 33</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-递归函数"><a href="#5-3-递归函数" class="headerlink" title="5.3 递归函数"></a>5.3 递归函数</h2><p>递归指函数可以直接或间接的调用自身。</p><p>递归函数通常有相同的结构：一个跳出条件和一个递归体。<br>所谓跳出条件就是根据传入的参数判断是否需要停止递归，而递归体则是函数自身所做的一些处理。</p><p>函数调用顺序：</p><blockquote><p>和C一样，是栈的形式。被调用者先执行。 </p></blockquote><p>比如ABC三个函数，调用顺序为C–&gt;B–&gt;A，则A会最先执行。</p><p>同样，递归就是自己调用自己，假设3–&gt;2–&gt;1，则会最先输出1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过循环实现1+2+3……+100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test01</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过递归实现1+2+3……+100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test02</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> num + Test02(num<span class="number">-1</span>) <span class="comment">//函数调用本身</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过递归实现1+2+3……+100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test03</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> num + Test03(num+<span class="number">1</span>) <span class="comment">//函数调用本身</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(Test01())    <span class="comment">//5050</span></span><br><span class="line">    fmt.Println(Test02(<span class="number">100</span>)) <span class="comment">//5050</span></span><br><span class="line">    fmt.Println(Test03(<span class="number">1</span>))   <span class="comment">//5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-函数类型"><a href="#5-4-函数类型" class="headerlink" title="5.4 函数类型"></a>5.4 函数类型</h2><p>在Go语言中，函数也是一种数据类型，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型。类似于重写（同名覆盖）。</p><p>回调函数：函数有一个参数是函数类型，这个函数就是回调函数。</p><p>更准确地说是将一个函数的指针作为参数传递给另一个函数。而回调函数的定义则是不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span> //声明一个函数类型, <span class="title">func</span>后面没有函数名</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数中有一个参数类型为函数类型：f FuncType</span></span><br><span class="line"><span class="comment">//回调函数，函数有一个参数是函数类型，这个函数就是回调函数</span></span><br><span class="line"><span class="comment">//计算器，可以进行四则运算</span></span><br><span class="line"><span class="comment">//多态，多种形态，调用同一个接口，不同的表现，可以实现不同表现，加减乘除//现有想法，后面再实现功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="keyword">int</span>, f FuncType)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result = f(a, b) <span class="comment">//通过调用f()实现任务</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数调用，第三个参数为函数名字，此函数的参数，返回值必须和FuncType类型一致</span></span><br><span class="line">    result := Calc(<span class="number">1</span>, <span class="number">1</span>, Add)</span><br><span class="line">    fmt.Println(result) <span class="comment">//2</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> f FuncType = Minus</span><br><span class="line">    fmt.Println(<span class="string">&quot;result = &quot;</span>, f(<span class="number">10</span>, <span class="number">2</span>)) <span class="comment">//result =  8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-匿名函数与闭包"><a href="#5-5-匿名函数与闭包" class="headerlink" title="5.5 匿名函数与闭包"></a>5.5 匿名函数与闭包</h2><p>所谓闭包就是一个函数“捕获”了和它在同一作用域的其它常量和变量。这就意味着当闭包被调用的时候，不管在程序什么地方调用，闭包能够使用这些常量或者变量。它不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在。</p><p>在Go语言里，所有的匿名函数(Go语言规范中称之为函数字面量)都是闭包。匿名函数是指不需要定义函数名的一种函数实现方式，它并不是一个新概念，最早可以回溯到1958年的Lisp语言。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    str := <span class="string">&quot;mike&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//匿名函数，无参无返回值</span></span><br><span class="line">        <span class="comment">//引用到函数外的变量</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;方式1：i = %d, str = %s\n&quot;</span>, i, str)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    f1() <span class="comment">//函数调用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方式1的另一种方式</span></span><br><span class="line">    <span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">()</span> //声明函数类型, 无参无返回值</span></span><br><span class="line">    <span class="keyword">var</span> f2 FuncType = f1</span><br><span class="line">    f2() <span class="comment">//函数调用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方式2</span></span><br><span class="line">    <span class="keyword">var</span> f3 FuncType = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;方式2：i = %d, str = %s\n&quot;</span>, i, str)</span><br><span class="line">    &#125;</span><br><span class="line">    f3() <span class="comment">//函数调用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方式3</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//匿名函数，无参无返回值</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;方式3：i = %d, str = %s\n&quot;</span>, i, str)</span><br><span class="line">    &#125;() <span class="comment">//别忘了后面的(), ()的作用是，此处直接调用此匿名函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方式4, 匿名函数，有参有返回值</span></span><br><span class="line">    v := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        result = a + b</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//别忘了后面的(1, 1), (1, 1)的作用是，此处直接调用此匿名函数， 并传参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;v = &quot;</span>, v)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包捕获外部变量特点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    str := <span class="string">&quot;mike&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i = <span class="number">100</span></span><br><span class="line">        str = <span class="string">&quot;go&quot;</span></span><br><span class="line">        <span class="comment">//内部：i = 100, str = go</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部：i = %d, str = %s\n&quot;</span>, i, str)</span><br><span class="line">    &#125;() <span class="comment">//别忘了后面的(), ()的作用是，此处直接调用此匿名函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//外部：i = 100, str = go</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;外部：i = %d, str = %s\n&quot;</span>, i, str)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">函数返回值为匿名函数：</span><br><span class="line"><span class="comment">// squares返回一个匿名函数，func() int</span></span><br><span class="line"><span class="comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">//匿名函数</span></span><br><span class="line">        x++ <span class="comment">//捕获外部变量</span></span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;4&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;9&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用时匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。</p><p>通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p><h2 id="5-6-闭包"><a href="#5-6-闭包" class="headerlink" title="5.6 闭包"></a>5.6 闭包</h2><p>闭包，要理解起来会麻烦一点。首先我们要知道几个概念，当函数调用结束后，所有局部变量会释放，除了返回值。函数A中定义了函数B，则B外面的叫外函数，里面的叫内函数，假如外函数有有个临时变量a，内函数有个临时变量B。 此时，内函数使用了a，且函数A的返回值是函数B的引用，则叫闭包。 比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数A</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add_function_generator</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里是外函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数B，也叫闭包</span></span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//这里是内函数</span></span><br><span class="line">        sum = i + j</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;(i,j)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := add_function_generator(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。<br>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//必须</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数的返回值是一个匿名函数，返回一个函数类型</span></span><br><span class="line"><span class="comment">//该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数被调用时，x才分配空间，才初始化为0</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">//4</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">//9</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">//16</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">//25</span></span><br><span class="line">    <span class="comment">//在这里squares()里面的x才释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//一般函数，函数结束了就释放局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> <span class="comment">//没有初始化，值为0</span></span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x * x <span class="comment">//函数调用完毕，x自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回值为一个匿名函数，返回一个函数类型，通过f来调用返回的匿名函数，f来调用闭包函数</span></span><br><span class="line">    <span class="comment">//它不关心这些捕获了的变量和常量是否已经超出了作用域,所以只有闭包还在使用它，这些变量就还会存在。</span></span><br><span class="line">    test()</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(test01())<span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01())<span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01())<span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01())<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其实本质来说，就跟宏替换一样，把闭包里面的函数体直接替换到外函数就成了这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">int</span> <span class="comment">//这个变量原来会由系统生成，记录返回值</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> </span><br><span class="line">    </span><br><span class="line">    x++</span><br><span class="line">    res =  x * x</span><br><span class="line">    fmt.Println(res) </span><br><span class="line"> </span><br><span class="line">    x++</span><br><span class="line">    res =  x * x</span><br><span class="line">    fmt.Println(res) </span><br><span class="line"> </span><br><span class="line">    x++</span><br><span class="line">    res =  x * x</span><br><span class="line">    fmt.Println(res) </span><br><span class="line"> </span><br><span class="line">    x++</span><br><span class="line">    res =  x * x</span><br><span class="line">    fmt.Println(res) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在这里x才释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-延迟调用defer"><a href="#5-6-延迟调用defer" class="headerlink" title="5.6 延迟调用defer"></a>5.6 延迟调用defer</h2><h3 id="5-6-1-defer作用"><a href="#5-6-1-defer作用" class="headerlink" title="5.6.1 defer作用"></a>5.6.1 defer作用</h3><p>关键字 defer ⽤于延迟一个函数或者方法（或者当前所创建的匿名函数）的执行。注意，defer语句只能出现在函数或方法的内部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;this is a defer&quot;</span>) <span class="comment">//main结束前调用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        运行结果：</span></span><br><span class="line"><span class="comment">        this is a test</span></span><br><span class="line"><span class="comment">        this is a defer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p><h3 id="5-6-2-多个defer执行顺序"><a href="#5-6-2-多个defer执行顺序" class="headerlink" title="5.6.2 多个defer执行顺序"></a>5.6.2 多个defer执行顺序</h3><p>如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执⾏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="number">100</span> / x)<span class="comment">//x为0时，产生异常</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;bbbbbbbb&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">defer</span> test(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;cccccccc&quot;</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">    cccccccc</span></span><br><span class="line"><span class="comment">    bbbbbbbb</span></span><br><span class="line"><span class="comment">    aaaaaaaa</span></span><br><span class="line"><span class="comment">    panic: runtime error: integer divide by zero</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-3-defer和匿名函数结合使用"><a href="#5-6-3-defer和匿名函数结合使用" class="headerlink" title="5.6.3 defer和匿名函数结合使用"></a>5.6.3 defer和匿名函数结合使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// a以值传递方式传给x</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;defer:&quot;</span>, x, b) <span class="comment">// b 闭包引用</span></span><br><span class="line">    &#125;(a)</span><br><span class="line"> </span><br><span class="line">    a += <span class="number">10</span></span><br><span class="line">    b += <span class="number">100</span></span><br><span class="line"> </span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        运行结果：</span></span><br><span class="line"><span class="comment">        a = 20, b = 120</span></span><br><span class="line"><span class="comment">        defer: 10 120</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-4-defer-与-return-孰先孰后"><a href="#5-6-4-defer-与-return-孰先孰后" class="headerlink" title="5.6.4 defer 与 return 孰先孰后"></a>5.6.4 defer 与 return 孰先孰后</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;go&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="string">&quot;python&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;myfunc 函数里的name：%s\n&quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myname := myfunc()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;main 函数里的name: %s\n&quot;</span>, name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main 函数里的myname: &quot;</span>, myname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myfunc 函数里的name：go</span><br><span class="line">main 函数里的name: python</span><br><span class="line">main 函数里的myname:  go</span><br></pre></td></tr></table></figure><p> defer 是return 后才调用的。所以在执行 defer 前，myname 已经被赋值成 go 了。</p><h2 id="5-7-获取命令行参数"><a href="#5-7-获取命令行参数" class="headerlink" title="5.7 获取命令行参数"></a>5.7 获取命令行参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span>    <span class="comment">//os.Args所需的包</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    args := os.Args <span class="comment">//获取用户输入的所有参数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果用户没有输入,或参数个数不够,则调用该函数提示用户</span></span><br><span class="line">    <span class="keyword">if</span> args == <span class="literal">nil</span> || <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;err: xxx ip port&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ip := args[<span class="number">1</span>]   <span class="comment">//获取输入的第一个参数</span></span><br><span class="line">    port := args[<span class="number">2</span>] <span class="comment">//获取输入的第二个参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ip = %s, port = %s\n&quot;</span>, ip, port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8-作用域"><a href="#5-8-作用域" class="headerlink" title="5.8 作用域"></a>5.8 作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p><p>函数内定义的变量称为局部变量。<br>函数外定义的变量称为全局变量。<br>在不同作用域可以声明同名的变量，其访问原则为：在同一个作用域内，就近原则访问最近的变量，如果此作用域没有此变量声明，则访问全局变量，如果全局变量也没有，则报错。</p><h3 id="5-8-1-局部变量"><a href="#5-8-1-局部变量" class="headerlink" title="5.8.1 局部变量"></a>5.8.1 局部变量</h3><p>在函数体内声明的变量、参数和返回值变量就是局部变量，它们的作用域只在函数体内：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//a, b, c = 1, 2, 3 //err, a, b, c不属于此作用域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">        i = <span class="number">10</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;i = %d\n&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//i = 20 //err, i不属于此作用域</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> a := <span class="number">3</span>; a == <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a = 4 //err，a只能if内部使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8-2-全局变量"><a href="#5-8-2-全局变量" class="headerlink" title="5.8.2 全局变量"></a>5.8.2 全局变量</h3><p>在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> <span class="comment">//全局变量的声明</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;test a = %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;main a = %d\n&quot;</span>, a) <span class="comment">//main a = 10</span></span><br><span class="line"> </span><br><span class="line">    test() <span class="comment">//test a = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8-3-不同作用域同名变量"><a href="#5-8-3-不同作用域同名变量" class="headerlink" title="5.8.3 不同作用域同名变量"></a>5.8.3 不同作用域同名变量</h3><p>在不同作用域可以声明同名的变量，其访问原则为：在同一个作用域内，就近原则访问最近的变量，如果此作用域没有此变量声明，则访问全局变量，如果全局变量也没有，则报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> <span class="comment">//全局变量的声明</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(a <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a type = %T\n&quot;</span>, a) <span class="comment">//a type = float32</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a type = %T\n&quot;</span>, a) <span class="comment">//a type = int, 说明使用全局变量的a</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">uint8</span> <span class="comment">//局部变量声明</span></span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="keyword">float64</span>                  <span class="comment">//局部变量声明</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;a type = %T\n&quot;</span>, a) <span class="comment">//a type = float64</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Printf(<span class="string">&quot;a type = %T\n&quot;</span>, a) <span class="comment">//a type = uint8</span></span><br><span class="line"> </span><br><span class="line">    test01(<span class="number">3.14</span>)</span><br><span class="line">    test02()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a type = %T\n&quot;</span>, a) <span class="comment">//a type = int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】运算符和流程控制</title>
      <link href="/202107/34776/"/>
      <url>/202107/34776/</url>
      
        <content type="html"><![CDATA[<h1 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h1><h2 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h2><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10  5</td><td>50</td></tr><tr><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>后自增，没有前自增</td><td>a=0; a++</td><td>a=1</td></tr><tr><td>–</td><td>后自减，没有前自减</td><td>a=2; a–</td><td>a=1</td></tr></tbody></table><h2 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h2><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>false</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>false</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>true</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>false</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>true</td></tr></tbody></table><h2 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3 逻辑运算符"></a>3.3 逻辑运算符</h2><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真；如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>| |</td><td>或</td><td>a</td><td></td></tr></tbody></table><h2 id="3-4-位运算符"><a href="#3-4-位运算符" class="headerlink" title="3.4 位运算符"></a>3.4 位运算符</h2><table><thead><tr><th>运算符</th><th>术语</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>参与运算的两数各对应的二进位相与</td><td>60 &amp; 13 结果为12</td></tr><tr><td>|</td><td>按位或</td><td>参与运算的两数各对应的二进位相或</td><td>60</td></tr><tr><td>^</td><td>异或</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1</td><td>60 ^ 13 结果为240</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>左移n位就是乘以2的n次方。 左边丢弃，右边补0。</td><td>4 &lt;&lt; 2 结果为16</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>右移n位就是除以2的n次方。 右边丢弃，左边补位。</td><td>4 &gt;&gt; 2 结果为1</td></tr></tbody></table><h2 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5 赋值运算符"></a>3.5 赋值运算符</h2><table><thead><tr><th>运算符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>=</td><td>普通赋值</td><td>c = a + b 将 a + b 表达式结果赋值给 c</td></tr><tr><td>+=</td><td>相加后再赋值</td><td>c += a 等价于 c = c + a</td></tr><tr><td>-=</td><td>相减后再赋值</td><td>c -= a 等价于 c = c - a</td></tr><tr><td>=</td><td>相乘后再赋值</td><td>c = a 等价于 c = c  a</td></tr><tr><td>/=</td><td>相除后再赋值</td><td>c /= a 等价于 c = c / a</td></tr><tr><td>%=</td><td>求余后再赋值</td><td>c %= a 等价于 c = c % a</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td><td>c &lt;&lt;= 2 等价于 c = c &lt;&lt; 2</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td><td>c &gt;&gt;= 2 等价于 c = c &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td><td>c &amp;= 2 等价于 c = c &amp; 2</td></tr><tr><td>^=</td><td>按位异或后赋值</td><td>c ^= 2 等价于 c = c ^ 2</td></tr><tr><td></td><td>=</td><td>按位或后赋值</td></tr></tbody></table><h2 id="3-6-其他运算符"><a href="#3-6-其他运算符" class="headerlink" title="3.6 其他运算符"></a>3.6 其他运算符</h2><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>取地址运算符</td><td>&amp;a</td><td>变量a的地址</td></tr><tr><td></td><td>取值运算符</td><td>a</td><td>指针变量a所指向内存的值</td></tr></tbody></table><h2 id="3-7-运算符-优先级"><a href="#3-7-运算符-优先级" class="headerlink" title="3.7 运算符 优先级"></a>3.7 运算符 优先级</h2><p>在Go语言中，一元运算符拥有最高的优先级，二元运算符的运算方向均是从左至右。</p><p>下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>7</td><td>^      !</td></tr><tr><td>6</td><td>*       /    %    &lt;&lt;    &gt;&gt;    &amp;      &amp;^</td></tr><tr><td>5</td><td>+      -</td></tr><tr><td>4</td><td>==   !=   &lt;    &lt;=    &gt;=    &gt;</td></tr><tr><td>3</td><td>&lt;-</td></tr><tr><td>2</td><td>&amp;&amp;</td></tr><tr><td>1</td><td>| |</td></tr></tbody></table><h1 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h1><p>Go语言支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构。</p><ul><li>顺序结构：程序按顺序执行，不发生跳转。</li><li>选择结构：依据是否满足条件，有选择的执行相应功能。</li><li>循环结构：依据条件是否满足，循环多次执行某段代码。</li></ul><p>大概有以下几种：</p><ul><li>if - else 条件语句</li><li>switch - case 选择语句</li><li>for - range 循环语句</li><li>goto 无条件跳转语句</li><li>defer 延迟执行</li></ul><h2 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h2><h3 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h3><h3 id="4-1-1-1-if"><a href="#4-1-1-1-if" class="headerlink" title="4.1.1.1 if"></a>4.1.1.1 if</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="number">3</span> &#123; <span class="comment">//条件表达式没有括号</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a==3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持一个初始化表达式, 初始化字句和条件表达式直接需要用分号分隔</span></span><br><span class="line"><span class="keyword">if</span> b := <span class="number">3</span>; b == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b==3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-1-2-if-…-else"><a href="#4-1-1-2-if-…-else" class="headerlink" title="4.1.1.2 if … else"></a>4.1.1.2 if … else</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a := <span class="number">3</span>; a == <span class="number">4</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a==4&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//左大括号必须和条件语句或else在同一行</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a!=4&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-1-3-if-…-else-if-…-else"><a href="#4-1-1-3-if-…-else-if-…-else" class="headerlink" title="4.1.1.3 if … else if … else"></a>4.1.1.3 if … else if … else</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a := <span class="number">3</span>; a &gt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a&gt;3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a&lt;3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a==3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-switch语句"><a href="#4-1-2-switch语句" class="headerlink" title="4.1.2 switch语句"></a>4.1.2 switch语句</h3><p>Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score <span class="keyword">int</span> = <span class="number">90</span></span><br><span class="line"><span class="keyword">switch</span> score &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line">    <span class="comment">//fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;良好&quot;</span>)</span><br><span class="line">    <span class="comment">//fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>: <span class="comment">//一个case多个条件</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;一般&quot;</span>)</span><br><span class="line">    <span class="comment">//fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;差&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用任何类型或表达式作为条件语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">switch</span> s1 := <span class="number">90</span>; s1 &#123; <span class="comment">//初始化语句;条件</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;良好&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;一般&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> s2 <span class="keyword">int</span> = <span class="number">90</span></span><br><span class="line"><span class="keyword">switch</span> &#123; <span class="comment">//这里没有写条件</span></span><br><span class="line">    <span class="keyword">case</span> s2 &gt;= <span class="number">90</span>: <span class="comment">//这里写判断语句</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> s2 &gt;= <span class="number">80</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;良好&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;一般&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">switch</span> s3 := <span class="number">90</span>; &#123; <span class="comment">//只有初始化语句，没有条件</span></span><br><span class="line">    <span class="keyword">case</span> s3 &gt;= <span class="number">90</span>: <span class="comment">//这里写判断语句</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> s3 &gt;= <span class="number">80</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;良好&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;一般&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-循环语句"><a href="#4-2-循环语句" class="headerlink" title="4.2 循环语句"></a>4.2 循环语句</h2><h3 id="4-2-1-for"><a href="#4-2-1-for" class="headerlink" title="4.2.1 for"></a>4.2.1 for</h3><blockquote><p>for 初始化条件 ;  判断条件 ;  条件变化</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, sum <span class="keyword">int</span></span><br><span class="line"><span class="comment">//1) 初始化条件  i := 1</span></span><br><span class="line"><span class="comment">//2) 判断条件是否为真， i &lt;= 100， 如果为真，执行循环体，如果为假，跳出循环</span></span><br><span class="line"><span class="comment">//3) 条件变化 i++</span></span><br><span class="line"><span class="comment">//4) 重复2， 3， 4</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;sum = &quot;</span>, sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接写判断条件也是OK的</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> a &lt;= <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    a ++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-range"><a href="#4-2-2-range" class="headerlink" title="4.2.2 range"></a>4.2.2 range</h3><p>关键字 range 会返回两个值，第一个返回值是元素的数组下标，第二个返回值是元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; <span class="comment">//支持 string/array/slice/map。</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, s[i])</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123; <span class="comment">// 忽略 index</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d, %c\n&quot;</span>, i, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> str &#123; <span class="comment">//第2个返回值，默认丢弃，返回元素的位置(下标)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> str &#123; <span class="comment">//第2个返回值，默认丢弃，返回元素的位置(下标)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d]=%c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h2><h3 id="4-3-1-break和continue"><a href="#4-3-1-break和continue" class="headerlink" title="4.3.1 break和continue"></a>4.3.1 break和continue</h3><p>在循环里面有两个关键操作break和continue，break操作是跳出当前循环，continue是跳过本次循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> == i &#123;</span><br><span class="line">        <span class="comment">//break    //break操作是跳出当前循环</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment">//continue是跳过本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：break可⽤于for、switch、select，⽽continue仅能⽤于for循环。</p><h3 id="4-3-2-goto"><a href="#4-3-2-goto" class="headerlink" title="4.3.2 goto"></a>4.3.2 goto</h3><p>用goto跳转到必须在当前函数内定义的标签：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            <span class="keyword">goto</span> LABEL <span class="comment">//跳转到标签LABEL，从标签处，执行代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">&quot;this is test&quot;</span>)</span><br><span class="line"> </span><br><span class="line">LABEL:</span><br><span class="line">    fmt.Println(<span class="string">&quot;it is over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：goto语句和标签之间不能有变量定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">goto</span> flag</span><br><span class="line">    <span class="keyword">var</span> say = <span class="string">&quot;hello oldboy&quot;</span>  <span class="comment">//编译错误：goto flag jumps over declaration of say at</span></span><br><span class="line">    fmt.Println(say)</span><br><span class="line"> </span><br><span class="line"> flag:</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】基本数据类型</title>
      <link href="/202107/57305/"/>
      <url>/202107/57305/</url>
      
        <content type="html"><![CDATA[<p>Go的数据类型还是很简单的。和C一样，简约而不简单。</p><h1 id="2-基础类型"><a href="#2-基础类型" class="headerlink" title="2.基础类型"></a>2.基础类型</h1><h2 id="2-1-命名"><a href="#2-1-命名" class="headerlink" title="2.1 命名"></a>2.1 命名</h2><p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：</p><blockquote><p>一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。</p></blockquote><p>大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</p><p>Go语言中类似if和switch的关键字有25个(均为小写)。关键字不能用于自定义名字，只能在特定语法结构中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break       default         func         interface        select</span><br><span class="line">case        defer           go           map              struct</span><br><span class="line">chan        else            goto         package          switch</span><br><span class="line">const       fallthrough     if           range            type</span><br><span class="line">continue    for             import       return           var</span><br></pre></td></tr></table></figure><p>此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内建常量: </span><br><span class="line">    true false iota nil</span><br><span class="line">内建类型: </span><br><span class="line">        int int8 int16 int32 int64</span><br><span class="line">        uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">        float32 float64 complex128 complex64</span><br><span class="line">        bool byte rune string error</span><br><span class="line">内建函数: </span><br><span class="line">        make len cap new append copy close delete</span><br><span class="line">        complex real imag</span><br><span class="line">        panic recover</span><br></pre></td></tr></table></figure><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>变量是几乎所有编程语言中最基本的组成元素，变量是程序运行期间可以改变的量。</p><p>从根本上说，变量相当于是对一块数据存储空间的命名，程序可以通过定义一个变量来申请一块数据存储空间，之后可以通过引用变量名来使用这块存储空间。</p><h3 id="2-2-1-变量声明"><a href="#2-2-1-变量声明" class="headerlink" title="2.2.1 变量声明"></a>2.2.1 变量声明</h3><p>Go语言的变量声明方式与C和C++语言有明显的不同。对于纯粹的变量声明， Go语言引入了关键字var，而类型信息放在变量名之后，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一次定义多个变量</span></span><br><span class="line"><span class="keyword">var</span> v3, v4 <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v5 <span class="keyword">int</span></span><br><span class="line">    v6 <span class="keyword">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="2-2-2-变量初始化"><a href="#2-2-2-变量初始化" class="headerlink" title="2.2.2 变量初始化"></a>2.2.2 变量初始化</h3><p>对于声明变量时需要进行初始化的场景， var关键字可以保留，但不再是必要的元素，如下所示： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span> = <span class="number">10</span>  <span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="number">10</span>       <span class="comment">// 方式2，编译器自动推导出v2的类型</span></span><br><span class="line">v3 := <span class="number">10</span>           <span class="comment">// 方式3，编译器自动推导出v3的类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;v3 type is &quot;</span>, reflect.TypeOf(v3)) <span class="comment">//v3 type is  int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动推导类型</span></span><br><span class="line"><span class="comment">//出现在 := 左侧的变量不应该是已经被声明过，:=定义时必须初始化</span></span><br><span class="line"><span class="keyword">var</span> v4 <span class="keyword">int</span></span><br><span class="line">v4 := <span class="number">2</span> <span class="comment">//err</span></span><br><span class="line"><span class="comment">//注意：自动推导类型只能在函数内部使用</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-变量赋值"><a href="#2-2-3-变量赋值" class="headerlink" title="2.2.3 变量赋值"></a>2.2.3 变量赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span></span><br><span class="line">v1 = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v2, v3, v4 <span class="keyword">int</span></span><br><span class="line">v2, v3, v4 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>    <span class="comment">//多重赋值</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">j := <span class="number">20</span></span><br><span class="line">i, j = j, i    <span class="comment">//多重赋值</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-匿名变量"><a href="#2-2-4-匿名变量" class="headerlink" title="2.2.4 匿名变量"></a>2.2.4 匿名变量</h3><p>_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_, i, _, j := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">250</span>, <span class="string">&quot;sb&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">_, str := test()</span><br></pre></td></tr></table></figure><blockquote><p>用途：回收变量，常用于接收函数的返回值，因为go的函数是可以有多个返回值的，如果只想用其中的一个， 就可以用匿名变量丢弃其他变量。</p></blockquote><h2 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3 常量"></a>2.3 常量</h2><p>在Go语言中，常量是指编译期间就已知且不可改变的值。常量可以是数值类型（包括整型、浮点型和复数类型）、布尔类型、字符串类型等。</p><h3 id="2-3-1-字面常量-常量值"><a href="#2-3-1-字面常量-常量值" class="headerlink" title="2.3.1 字面常量(常量值)"></a>2.3.1 字面常量(常量值)</h3><p>所谓字面常量（literal），是指程序中硬编码的常量，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">3.1415</span>  <span class="comment">// 浮点类型的常量</span></span><br><span class="line"><span class="number">3.2</span>+<span class="number">12i</span> <span class="comment">// 复数类型的常量</span></span><br><span class="line"><span class="literal">true</span>  <span class="comment">// 布尔类型的常量</span></span><br><span class="line"><span class="string">&quot;foo&quot;</span> <span class="comment">// 字符串常量</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-常量定义"><a href="#2-3-2-常量定义" class="headerlink" title="2.3.2 常量定义"></a>2.3.2 常量定义</h3><p>变量：程序运行期间，可以改变的量， 变量声明需要var</p><p>常量：程序运行期间，不可以改变的量，常量声明需要const</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="keyword">float64</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span> <span class="comment">// 浮点常量, 自动推导类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// 常量组</span></span><br><span class="line">    size <span class="keyword">int64</span> = <span class="number">1024</span></span><br><span class="line">    eof        = <span class="number">-1</span> <span class="comment">// 整型常量, 自动推导类型</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> u, v <span class="keyword">float32</span> = <span class="number">0</span>, <span class="number">3</span> <span class="comment">// u = 0.0, v = 3.0，常量的多重赋值</span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// a = 3, b = 4, c = &quot;foo&quot;    //err, 常量不能修改</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-iota枚举"><a href="#2-2-3-iota枚举" class="headerlink" title="2.2.3 iota枚举"></a>2.2.3 iota枚举</h3><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。</p><p>在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">        y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">        z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">        w  <span class="comment">// 这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">        b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">        c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">        d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3 如果是同一行，值都一样</span></span><br><span class="line">        g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        x1 = <span class="literal">iota</span> * <span class="number">10</span> <span class="comment">// x1 == 0</span></span><br><span class="line">        y1 = <span class="literal">iota</span> * <span class="number">10</span> <span class="comment">// y1 == 10</span></span><br><span class="line">        z1 = <span class="literal">iota</span> * <span class="number">10</span> <span class="comment">// z1 == 20</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">fmt.Println(a,b,c,d,e,f,g,h,i)<span class="comment">//0 1 2 ha ha 100 100 7 8</span></span><br></pre></td></tr></table></figure><h2 id="2-4-基础数据类型"><a href="#2-4-基础数据类型" class="headerlink" title="2.4 基础数据类型"></a>2.4 基础数据类型</h2><h3 id="2-4-1-分类"><a href="#2-4-1-分类" class="headerlink" title="2.4.1 分类"></a>2.4.1 分类</h3><p>Go语言内置以下这些基础类型：</p><table><thead><tr><th>类型</th><th>名称</th><th>长度</th><th>零值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>1</td><td>false</td><td>其值不为真即为家，不可以用数字代表true或false</td></tr><tr><td>byte</td><td>字节型</td><td>1</td><td>0</td><td>uint8别名</td></tr><tr><td>rune</td><td>字符类型</td><td>4</td><td>0</td><td>专用于存储unicode编码，等价于uint32</td></tr><tr><td>int, uint</td><td>整型</td><td>4或8</td><td>0</td><td>32位或64位</td></tr><tr><td>int8, uint8</td><td>整型</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255</td></tr><tr><td>int16, uint16</td><td>整型</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>整型</td><td>4</td><td>0</td><td>-21亿 ~ 21 亿, 0 ~ 42 亿</td></tr><tr><td>int64, uint64</td><td>整型</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>浮点型</td><td>4</td><td>0.0</td><td>小数位精确到7位</td></tr><tr><td>float64</td><td>浮点型</td><td>8</td><td>0.0</td><td>小数位精确到15位</td></tr><tr><td>complex64</td><td>复数类型</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>复数类型</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>整型</td><td>4或8</td><td></td><td>⾜以存储指针的uint32或uint64整数</td></tr><tr><td>string</td><td>字符串</td><td></td><td>“”</td><td>utf-8字符串</td></tr></tbody></table><h3 id="2-4-2布尔类型"><a href="#2-4-2布尔类型" class="headerlink" title="2.4.2布尔类型"></a>2.4.2布尔类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">bool</span></span><br><span class="line">v1 = <span class="literal">true</span></span><br><span class="line">v2 := (<span class="number">1</span> == <span class="number">2</span>) <span class="comment">// v2也会被推导为bool类型</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">b = <span class="number">1</span> <span class="comment">// err, 编译错误</span></span><br><span class="line">b = <span class="keyword">bool</span>(<span class="number">1</span>) <span class="comment">// err, 编译错误</span></span><br></pre></td></tr></table></figure><h4 id="bool转int"><a href="#bool转int" class="headerlink" title="bool转int"></a>bool转int</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bool2int</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="int转bool"><a href="#int转bool" class="headerlink" title="int转bool"></a>int转bool</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">int2bool</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-整型"><a href="#2-4-3-整型" class="headerlink" title="2.4.3 整型"></a>2.4.3 整型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int32</span></span><br><span class="line">v1 = <span class="number">123</span></span><br><span class="line">v2 := <span class="number">64</span> <span class="comment">// v1将会被自动推导为int类型</span></span><br></pre></td></tr></table></figure><p>int 和 uint 的区别就在于一个 u，有 u 说明是无符号，没有 u 代表有符号。</p><h4 id="解释这个符号的区别"><a href="#解释这个符号的区别" class="headerlink" title="解释这个符号的区别:"></a>解释这个符号的区别:</h4><p>以 int8 和 uint8 举例，8 代表 8个bit，能表示的数值个数有 2^8 = 256。</p><ul><li>uint8 是无符号，能表示的都是正数，0-255，刚好256个数。</li><li>int8 是有符号，既可以正数，也可以负数，那怎么办？对半分呗，-128-127，也刚好 256个数。</li></ul><p>int8 int16 int32 int64 这几个类型的最后都有一个数值，这表明了它们能表示的数值个数是固定的。</p><p>而 int 并没有指定它的位数，说明它的大小，是可以变化的，那根据什么变化呢？</p><ul><li>  当你在32位的系统下，int 和 uint 都占用 4个字节，也就是32位。</li><li>  若你在64位的系统下，int 和 uint 都占用 8个字节，也就是64位。</li></ul><p>出于这个原因，在某些场景下，你应当避免使用 int 和 uint ，而使用更加精确的 int32 和 int64，比如在二进制传输、读写文件的结构描述（为了保持文件的结构不会受到不同编译目标平台字节长度的影响）</p><h3 id="2-4-4-浮点型"><a href="#2-4-4-浮点型" class="headerlink" title="2.4.4 浮点型"></a>2.4.4 浮点型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 <span class="keyword">float32</span></span><br><span class="line">f1 = <span class="number">12</span></span><br><span class="line">f2 := <span class="number">12.0</span> <span class="comment">// 如果不加小数点， fvalue2会被推导为整型而不是浮点型，float64</span></span><br></pre></td></tr></table></figure><h4 id="float32-和-float64"><a href="#float32-和-float64" class="headerlink" title="float32 和 float64"></a>float32 和 float64</h4><p>Go语言中提供了两种精度的浮点数 float32 和 float64。</p><p><strong>float32</strong>，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/3c45a34591e84afba7cf8f1234560dd6~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/3c45a34591e84afba7cf8f1234560dd6~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" title="image.png"></p><p><strong>float64</strong>，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数</p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/8fd643b688c84c4d94d898d4cb115737~tplv-k3u1fbpfcp-zoom-1.image" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/8fd643b688c84c4d94d898d4cb115737~tplv-k3u1fbpfcp-zoom-1.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" title="image.png"></p><p><strong>那么精度是什么意思？有效位有多少位？</strong></p><p>精度主要取决于尾数部分的位数。</p><p>对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2^-23，约等于1.19*10^-7，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。</p><p>同理 float64（单精度）的尾数部分为 52位，最小为2^-52，约为2.22*10^-16，所以精确到小数点后15位，加上小数点前的一位，有效位数为16位。</p><p>通过以上，可以总结出以下几点：</p><p><strong>一、float32 和 float64 可以表示的数值很多</strong></p><p>浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：</p><ul><li>  常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；</li><li>  常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；</li><li>  float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。</li></ul><p><strong>二、数值很大但精度有限</strong></p><p>人家虽然能表示的数值很大，但精度位却没有那么大。</p><ul><li>  float32的精度只能提供大约6个十进制数（表示后科学计数法后，小数点后6位）的精度\</li><li>  float64的精度能提供大约15个十进制数（表示后科学计数法后，小数点后15位）的精度\</li></ul><p>这里的精度是什么意思呢？</p><p>比如 10000018这个数，用 float32 的类型来表示的话，由于其有效位是7位，将10000018 表示成科学计数法，就是 1.0000018 * 10^7，能精确到小数点后面6位。</p><p>此时用科学计数法表示后，小数点后有7位，刚刚满足我们的精度要求，意思是什么呢？此时你对这个数进行+1或者-1等数学运算，都能保证计算结果是精确的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myfloat <span class="keyword">float32</span> = <span class="number">10000018</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat)</span><br><span class="line">  fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myfloat: 1.0000018e+07</span></span><br><span class="line"><span class="comment">myfloat: 1.0000019e+07</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><p>上面举了一个刚好满足精度要求数据的临界情况，为了做对比，下面也举一个刚好不满足精度要求的例子。只要给这个数值多加一位数就行了。</p><p>换成 100000187，同样使用 float32类型，表示成科学计数法，由于精度有限，表示的时候小数点后面7位是准确的，但若是对其进行数学运算，由于第八位无法表示，所以运算后第七位的值，就会变得不精确。</p><p>这里我们写个代码来验证一下，按照我们的理解下面 myfloat01 = 100000182 ，对其+5 操作后，应该等于 myfloat02 = 100000187，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myfloat01 <span class="keyword">float32</span> = <span class="number">100000182</span></span><br><span class="line"><span class="keyword">var</span> myfloat02 <span class="keyword">float32</span> = <span class="number">100000187</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat01)</span><br><span class="line">    fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat01+<span class="number">5</span>)</span><br><span class="line">    fmt.Println(myfloat02 == myfloat01+<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于其类型是 float32，精度不足，导致最后比较的结果是不相等（从小数点后第七位开始不精确）</p><blockquote><p>myfloat: 1.00000184e+08</p><p>myfloat: 1.0000019e+08</p><p><strong>false</strong></p></blockquote><p>由于精度的问题，就会出现这种很怪异的现象，myfloat == myfloat +1 会返回 true 。</p><h3 id="2-4-5-字符类型"><a href="#2-4-5-字符类型" class="headerlink" title="2.4.5 字符类型"></a>2.4.5 字符类型</h3><p>在Go语言中支持两个字符类型，一个是byte（实际上是uint8的别名），代表utf-8字符串的单个字节的值；另一个是rune，代表单个unicode字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch1, ch2, ch3 <span class="keyword">byte</span></span><br><span class="line">    ch1 = <span class="string">&#x27;a&#x27;</span>  <span class="comment">//字符赋值</span></span><br><span class="line">    ch2 = <span class="number">97</span>   <span class="comment">//字符的ascii码赋值</span></span><br><span class="line">    ch3 = <span class="string">&#x27;\n&#x27;</span> <span class="comment">//转义字符</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ch1 = %c, ch2 = %c, %c&quot;</span>, ch1, ch2, ch3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大写转小写，小写转大写, 大小写相差32，小写大</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;大写：%d， 小写：%d\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)<span class="comment">//大写：65， 小写：97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;大写转小写：%c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>+<span class="number">32</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;小写转大写：%c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span><span class="number">-32</span>)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-6-字符串"><a href="#2-4-6-字符串" class="headerlink" title="2.4.6 字符串"></a>2.4.6 字符串</h3><p>在Go语言中，字符串也是一种基本类型：</p><ol><li>双引号</li><li>字符串有1个或多个字符组成</li><li>字符串都是隐藏了一个结束符，’\0’</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span>                                    <span class="comment">// 声明一个字符串变量</span></span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>                                       <span class="comment">// 字符串赋值</span></span><br><span class="line">ch := str[<span class="number">0</span>]                                      <span class="comment">// 取字符串的第一个字符</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;str = %s, len = %d\n&quot;</span>, str, <span class="built_in">len</span>(str)) <span class="comment">//内置的函数len()来取字符串的长度</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;str[0] = %c, ch = %c\n&quot;</span>, str[<span class="number">0</span>], ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">//`(反引号)括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。</span></span><br><span class="line">str2 := <span class="string">`hello</span></span><br><span class="line"><span class="string">    mike \n \r测试</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">fmt.Println(<span class="string">&quot;str2 = &quot;</span>, str2)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str2 =  hello</span></span><br><span class="line"><span class="comment">mike \n \r测试</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2-4-7-复数类型"><a href="#2-4-7-复数类型" class="headerlink" title="2.4.7 复数类型"></a>2.4.7 复数类型</h3><p>复数实际上由两个实数（在计算机中用浮点数表示）构成，一个表示实部（real），一个表示虚部（imag）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">complex64</span> <span class="comment">// 由2个float32构成的复数类型</span></span><br><span class="line">v1 = <span class="number">3.2</span> + <span class="number">12i</span></span><br><span class="line">v2 := <span class="number">3.2</span> + <span class="number">12i</span>        <span class="comment">// v2是complex128类型</span></span><br><span class="line">v3 := <span class="built_in">complex</span>(<span class="number">3.2</span>, <span class="number">12</span>) <span class="comment">// v3结果同v2</span></span><br><span class="line"></span><br><span class="line">fmt.Println(v1, v2, v3)</span><br><span class="line"><span class="comment">//内置函数real(v1)获得该复数的实部</span></span><br><span class="line"><span class="comment">//通过imag(v1)获得该复数的虚部</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(v1), <span class="built_in">imag</span>(v1))</span><br></pre></td></tr></table></figure><h2 id="2-5-fmt包的格式化输出输入"><a href="#2-5-fmt包的格式化输出输入" class="headerlink" title="2.5 fmt包的格式化输出输入"></a>2.5 fmt包的格式化输出输入</h2><h3 id="2-5-1-格式说明"><a href="#2-5-1-格式说明" class="headerlink" title="2.5.1 格式说明"></a>2.5.1 格式说明</h3><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%%</td><td>一个%字面量</td></tr><tr><td>%b</td><td>一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数</td></tr><tr><td>%c</td><td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td></tr><tr><td>%d</td><td>一个十进制数值(基数为10)</td></tr><tr><td>%e</td><td>以科学记数法e表示的浮点数或者复数值</td></tr><tr><td>%E</td><td>以科学记数法E表示的浮点数或者复数值</td></tr><tr><td>%f</td><td>以标准记数法表示的浮点数或者复数值</td></tr><tr><td>%g</td><td>以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td></tr><tr><td>%G</td><td>以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td></tr><tr><td>%o</td><td>一个以八进制表示的数字(基数为8)</td></tr><tr><td>%p</td><td>以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示</td></tr><tr><td>%q</td><td>使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字</td></tr><tr><td>%s</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td></tr><tr><td>%t</td><td>以true或者false输出的布尔值</td></tr><tr><td>%T</td><td>使用Go语法输出的值的类型</td></tr><tr><td>%U</td><td>一个用Unicode表示法表示的整型码点，默认值为4个数字字符</td></tr><tr><td>%v</td><td>使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话</td></tr><tr><td>%x</td><td>以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示</td></tr><tr><td>%X</td><td>以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示</td></tr></tbody></table><h3 id="2-5-2-输出"><a href="#2-5-2-输出" class="headerlink" title="2.5.2 输出"></a>2.5.2 输出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整型</span></span><br><span class="line">a := <span class="number">15</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a = %b\n&quot;</span>, a) <span class="comment">//a = 1111</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%%\n&quot;</span>)        <span class="comment">//只输出一个%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符</span></span><br><span class="line">ch := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ch = %c, %c\n&quot;</span>, ch, <span class="number">97</span>) <span class="comment">//a, a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型</span></span><br><span class="line">f := <span class="number">3.14</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;f = %f, %g\n&quot;</span>, f, f) <span class="comment">//f = 3.140000, 3.14</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;f type = %T\n&quot;</span>, f)   <span class="comment">//f type = float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类型</span></span><br><span class="line">v := <span class="built_in">complex</span>(<span class="number">3.2</span>, <span class="number">12</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;v = %f, %g\n&quot;</span>, v, v) <span class="comment">//v = (3.200000+12.000000i), (3.2+12i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;v type = %T\n&quot;</span>, v)   <span class="comment">//v type = complex128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%t, %t\n&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>) <span class="comment">//true, false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line">str := <span class="string">&quot;hello go&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;str = %s\n&quot;</span>, str) <span class="comment">//str = hello go</span></span><br></pre></td></tr></table></figure><h3 id="2-5-3-输入"><a href="#2-5-3-输入" class="headerlink" title="2.5.3 输入"></a>2.5.3 输入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入一个整型：&quot;</span>)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;v)</span><br><span class="line"><span class="comment">//fmt.Scan(&amp;v)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;v = &quot;</span>, v)</span><br></pre></td></tr></table></figure><h2 id="2-6-类型转换"><a href="#2-6-类型转换" class="headerlink" title="2.6 类型转换"></a>2.6 类型转换</h2><p>Go语言中不允许隐式转换，所有类型转换必须显式声明，而且转换只能发生在两种相互兼容的类型之间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;flag = %t\n&quot;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool类型不能转换为int</span></span><br><span class="line"><span class="comment">//fmt.Printf(&quot;flag = %d\n&quot;, int(flag))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0就是假，非0就是真</span></span><br><span class="line"><span class="comment">//整型也不能转换为bool</span></span><br><span class="line"><span class="comment">//flag = bool(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span></span><br><span class="line">ch = <span class="string">&#x27;a&#x27;</span> <span class="comment">//字符类型本质上就是整型</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">t = <span class="keyword">int</span>(ch) <span class="comment">//类型转换，把ch的值取出来后，转成int再给t赋值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;t = &quot;</span>, t)</span><br></pre></td></tr></table></figure><h2 id="2-7-类型别名"><a href="#2-7-类型别名" class="headerlink" title="2.7 类型别名"></a>2.7 类型别名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bigint <span class="keyword">int64</span> <span class="comment">//int64类型改名为bigint</span></span><br><span class="line"><span class="keyword">var</span> x bigint = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    myint <span class="keyword">int</span>    <span class="comment">//int改名为myint</span></span><br><span class="line">    mystr <span class="keyword">string</span> <span class="comment">//string改名为mystr</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】Hello World</title>
      <link href="/202107/36573/"/>
      <url>/202107/36573/</url>
      
        <content type="html"><![CDATA[<p>书接上回，上回说到了为什么要学习Go语言，今天我们来实际写一下，感受一下Go语言的精美之处。</p><h2 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h2><h3 id="1-2-1-安装和设置"><a href="#1-2-1-安装和设置" class="headerlink" title="1.2.1 安装和设置"></a>1.2.1 安装和设置</h3><h4 id="1-2-1-1-Windows"><a href="#1-2-1-1-Windows" class="headerlink" title="1.2.1.1 Windows:"></a>1.2.1.1 Windows:</h4><ol><li>Go安装包下载网址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></li><li>有zip压缩版和msi安装版两个按本下载。（这里使用msi安装版，比较方便）。</li><li>运行msi安装文件，千万不要在安装路径中出现中文，一路Next。</li><li>由于使用msi安装文件，Go语言的环境变量已经自动设置好了。</li></ol><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/14d7cfe036ed46c7bbf75c2aa4beeca3~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/14d7cfe036ed46c7bbf75c2aa4beeca3~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>打开Windows中的命令提示符（cmd.exe）执行命令：</p><p>查看版本 <code>go vresion</code></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/7ebe85a12b84463c99e9746d76c3b32c~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/7ebe85a12b84463c99e9746d76c3b32c~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>查看环境 <code>go env</code></p><p><img src="https://gitee.com/HappyTeemo/cdn/raw/master/2021/b3ca97449000456c8cc64d8a9f697714~tplv-k3u1fbpfcp-watermark.image" class="lazyload" data-srcset="https://gitee.com/HappyTeemo/cdn/raw/master/2021/b3ca97449000456c8cc64d8a9f697714~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h4 id="1-2-1-2-MacOs"><a href="#1-2-1-2-MacOs" class="headerlink" title="1.2.1.2 MacOs"></a>1.2.1.2 MacOs</h4><p>方法一：官网下载安装包，比较快</p><p>方法二：brew install go</p><p>添加环境变量</p><pre><code class="go">//编辑~/.bash_profile文件vim ~/.bash_profile//在~/.bash_profile文件中添加:export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/binexport PATH=&quot;/Users/teemo/go/bin:$PATH&quot;//使配置生效localhost:~ zxy$ source ~/.bash_profile```go#### 1.2.1.3 Linux`wget $tar -xvf go1.16.1.linux-amd64.tar.gz`设置环境变量```go$vim /etc/profile添加export GOROOT=/data/work/goexport GOPATH=/data/work/gopathexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin source /etc/profilego version```go### 1.2.2 标准命令概述Go语言中包含了大量用于处理Go语言代码的命令和工具。其中，go命令就是最常用的一个，它有许多子命令。这些子命令都拥有不同的功能，如下所示：- build：用于编译给定的代码包或Go语言源码文件及其依赖包。- clean：用于清除执行其他go命令后遗留的目录和文件。- doc：用于执行godoc命令以打印指定代码包。- env：用于打印Go语言环境信息。- fix：用于执行go tool fix命令以修正给定代码包的源码文件中包含的过时语法和代码调用。- fmt：用于执行gofmt命令以格式化给定代码包中的源码文件。- get：用于下载和安装给定代码包及其依赖包(提前安装git或hg)。- list：用于显示给定代码包的信息。- run：用于编译并运行给定的命令源码文件。- install：编译包文件并编译整个程序。- test：用于测试给定的代码包。- tool：用于运行Go语言的特殊工具。- version：用于显示当前安装的Go语言的版本信息。### 1.2.3 选择编辑器- 首选GoLand，破解问题自行百度或私信我，也可以氪金。- 其次VSCode。- 剩余编辑器首选vim，其他编辑器哪个顺手用哪个。我用的是GoLand，看一下配置：![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/f8d4191b202845d2bd174394e6a94751~tplv-k3u1fbpfcp-watermark.image)![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/b436467cb84f41c99c9fc9faf9b104bc~tplv-k3u1fbpfcp-watermark.image)![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/b974ea23d6e44cc3b739743e84f6bcee~tplv-k3u1fbpfcp-watermark.image) 主要是go mod中添加代理：`GOPROXY=https://goproxy.io ` go mod就是包管理工具，加代理是为了下载海外包更快。 ## 1.3 hello world 每个语言入门的标志不就是会写hello world么？![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/3f88248c136443f8acd8342e291a425d~tplv-k3u1fbpfcp-watermark.image)```gogopackage mainimport (   &quot;fmt&quot;)func main() &#123;   fmt.Println(&quot;Hello World!&quot;)&#125;```gomain旁边有个运行，直接点击运行就好了。![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/c6e63218e7914e4da63356c33f7ee3a6~tplv-k3u1fbpfcp-watermark.image)![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a2c666e93254bd2a1696af5ab895bc9~tplv-k3u1fbpfcp-watermark.image)好了，恭喜入门，撒花！！![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/c8dcc2c8017146eca41eb9745e863c31~tplv-k3u1fbpfcp-watermark.image)### 1.3.1 代码分析```go// 定义包， 一个程序通常只有一个main包，作为程序的入口package main// 导入包，这里导入fmt包import &quot;fmt&quot;// 通过func关键字定义函数// 这里定义的是程序的入口函数main, 程序从这个函数开始执行func main() &#123;    // 调用fmt包的Println函数，打印一个字符串。    fmt.Println(&quot;Hello, world&quot;)&#125;```go可以看出，和C的风格真的很像很像。```goc#include &lt;stdio.h&gt; //导入包//主函数int main()&#123;     //打印    printf(&quot;Hello World&quot;);     return 0;&#125; ```go不同的是，GO的创始人就是喜欢换行的括号风格，如果你像C这样使用花括号，则会报语法错误。这也许就是程序员的浪漫吧。我们也可以试试命令编译执行该程序。![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/632edd8c8a9c4e0bb78a22b6ed5ce7fc~tplv-k3u1fbpfcp-watermark.image)或者直接运行， 不编译生成可执行文件。![image.png](https://gitee.com/HappyTeemo/cdn/raw/master/2021/3ec4ba5931f34156975dbdf947c082c9~tplv-k3u1fbpfcp-watermark.image)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手把手教你写Go】为什么要选择Go语言</title>
      <link href="/202107/58089/"/>
      <url>/202107/58089/</url>
      
        <content type="html"><![CDATA[<p>一门语言的兴起一定有他的原因，所谓天下苦Java久矣，Go的到来可以说很多后端开发的福音，尤其是在微服务、分布式这么火的今天，那么，他的优势到底是什么呢？</p><p>首先，我们需要现有后端语言的优势痛点：</p><blockquote><p>其实每个语言的优势和痛点往往是同一个，毕竟这个世界上没有完美的东西，你要享受它的好，就要承受他的痛。</p></blockquote><ul><li>PHP，脚本语言，开发速度飞快，而且可复用性高，如果是写全栈代码，可以说是神器。<ul><li>脚本语言，写起来快，运行时慢。好处就是上传了实时生效，不用重启。坏处就是运行时编译，效率低。（如果是小型公司创业初期，或者你只是做一个小型网站，PHP真的是首选 ）</li><li>一个请求一个进程。不用考虑并发问题，这也是PHPer转Go最大的问题。这也使得PHP的并发量天然受限。</li><li>swoole的出现很大程度上改善了PHP的效率问题，但并发、异步、定时器之类的处理依然不够。</li></ul></li><li>Java，强类型，编译型语言。<ul><li>Java可以说是工业级语言，是一把宰牛刀，如果企业的业务量起来了，用Java重构是个很好的选择。但是同样的，这使得它运行起点很高，可能我网站请求才用2%的CPU，jvm可能就用了20%了。</li><li>开发较慢。强类型、编译久、一切从类开始，使得开发效率会相对慢一些。</li></ul></li><li>go，小而强。<ul><li>在我看来，Go就是服务端界的c，它很小巧，但它很强，参考我的C语言相关的文章。<a href="https://juejin.cn/post/6988787262603395079">【重看C语言】hello world</a></li><li>编译快，一键异步，自带定时器、通道、协程、锁。可以说让那些因为进程间关系掉的头发又长了回来。</li><li>包的体积小，无依赖，直接放到服务器就可以运行，让被PHP.ini和nginx各种配置折磨的phper如沐春风。</li></ul></li></ul><p>可以说，Go的前景还是很可观的。但是，我希望大家学习一门语言的时候，千万不要只是因为很多人学，要明白，语言只是工具。就好比，如果我现在写一个后台，还是会用PHP，为什么？查询好写，开发快，还可以直接全栈。找到一门语言的优势和它的精髓才是重点。</p><blockquote><p>很多人学习一门语言就是看看语法，然后找找框架，看看CURD怎么写，最后把原来的查询翻译过来，完事。</p></blockquote><p>好了，进入正题，开始学习Go语言。</p><h1 id="1、初识Go语言"><a href="#1、初识Go语言" class="headerlink" title="1、初识Go语言"></a>1、初识Go语言</h1><h2 id="1-1-Go语言简介"><a href="#1-1-Go语言简介" class="headerlink" title="1.1 Go语言简介"></a>1.1 Go语言简介</h2><h3 id="1-1-1-Go语言是什么"><a href="#1-1-1-Go语言是什么" class="headerlink" title="1.1.1 Go语言是什么"></a>1.1.1 Go语言是什么</h3><p>2009年11月10日，Go语言正式成为开源编程语言家庭的一员。</p><p>Go语言（或称Golang）是云计算时代的C语言。Go语言的诞生是为了让程序员有更高的生产效率，Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。</p><p>开发人员在为项目选择语言时，不得不在快速开发和性能之间做出选择。C和C++这类语言提供了很快的执行速度，而 Ruby 和 Python 这类语言则擅长快速开发。Go语言在这两者间架起了桥梁，不仅提供了高性能的语言，同时也让开发更快速。</p><p>Go语言是一门并发支持、垃圾回收的编译型语言。</p><p>从某种意义上可以说是C的优化版本。</p><h3 id="1-1-2-Go语言优势"><a href="#1-1-2-Go语言优势" class="headerlink" title="1.1.2 Go语言优势"></a>1.1.2 Go语言优势</h3><ul><li><p>直接编译成机器码，不依赖其他库，glibc的版本有一定要求，部署就是扔一个文件上去就完成了。</p></li><li><p> 静态类型语言，但是有动态语言的感觉，静态类型的语言就是可以在编译的时候检查出来隐藏的大多数问题，动态语言的感觉就是有很多的包可以使用，写起来的效率很高。</p></li><li><p>语言层面支持并发，这个就是Go最大的特色，天生的支持并发。Go就是基因里面支持的并发，可以充分的利用多核，很容易的使用并发。</p></li><li><p>内置runtime，支持垃圾回收，这属于动态语言的特性之一吧，虽然目前来说GC(内存垃圾回收机制)不算完美，但是足以应付我们所能遇到的大多数情况，特别是Go1.1之后的GC。</p></li><li><p>简单易学，Go语言的作者都有C的基因，那么Go自然而然就有了C的基因，那么Go关键字是25个，但是表达能力很强大，几乎支持大多数你在其他语言见过的特性：继承、重载、对象等。</p></li><li><p>丰富的标准库，Go目前已经内置了大量的库，特别是网络库非常强大。</p></li><li><p>内置强大的工具，Go语言里面内置了很多工具链，最好的应该是gofmt工具，自动化格式化代码，能够让团队review变得如此的简单，代码格式一模一样，想不一样都很困难。</p></li><li><p>跨平台编译，如果你写的Go代码不包含cgo，那么就可以做到window系统编译linux的应用，如何做到的呢？Go引用了plan9的代码，这就是不依赖系统的信息。</p></li><li><p>内嵌C支持，Go里面也可以直接包含C代码，利用现有的丰富的C库。</p></li></ul><h3 id="1-1-3-Go适合做什么"><a href="#1-1-3-Go适合做什么" class="headerlink" title="1.1.3 Go适合做什么"></a>1.1.3 Go适合做什么</h3><ul><li><p>服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</p></li><li><p>分布式系统，数据库代理器等。</p></li><li><p>网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用。</p></li><li><p>内存数据库，如google开发的groupcache，couchbase的部分组建。</p></li><li><p>云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。</p></li></ul><h3 id="1-1-4-Go的语言特点"><a href="#1-1-4-Go的语言特点" class="headerlink" title="1.1.4 Go的语言特点"></a>1.1.4 Go的语言特点</h3><ol><li>保留但大幅度简化指针</li><li>多参数返回</li><li>array slice map等内置基本数据结构</li><li>错误处理（panic recover error）</li><li>interface</li><li>goroutine</li><li>多核处理和网络开发</li><li>部分函数式编程（匿名函数、闭包），反射，语言交互性</li><li>Package即目录</li></ol><p> </p><h3 id="1-1-5-Go的哲学"><a href="#1-1-5-Go的哲学" class="headerlink" title="1.1.5 Go的哲学"></a>1.1.5 Go的哲学</h3><p>连接：组件的耦合方式，组件是如何被连接起来的</p><p>组合：形成复合对象的基础。</p><blockquote><p>Less can be more<br>大道至简,小而蕴真 </p></blockquote><p>让事情变得复杂很容易，让事情变得简单才难，深刻的工程文化。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
>>>>>>> Stashed changes
  
  
</search>
